<br/> 

###### Top

- [언어? 코딩? 컴파일? 기계어? 실행에 관하여](#언어-코딩-컴파일-기계어-실행에-관하여)

- [컴퓨터는 왜 이진법을 사용하는가?](#컴퓨터는-왜-이진법을-사용하는가)
- [컴퓨터의 기본 구조3가지](#컴퓨터의-기본-구조3가지)

- <details markdown="1">
  <summary>언어분류</summary>
  <div markdown="1">
  
  - [언어분류](#언어분류)
    - [언어수준(저수준언어, 고수준언어)](#언어수준저수준언어--고수준언어)
    - [타입별(강한타입, 약한타입)](#타입별강한타입-약한타입)
    - [처리수준(컴파일언어, JIT컴파일언어, 인터프리터)](#처리수준컴파일언어--jit컴파일언어--인터프리터)
    - [메모리관리(매니지드, 언매니지드)](#메모리관리매니지드-언매니지드)
    - [프로그래밍 패러다임(절차적언어, 개체지향 언어[OOP])](#프로그래밍-패러다임절차적언어-개체지향-언어oop))
  </div>
  </details>

- [스택, 힙, 코드, 데이터영역](#스택-힙-코드-데이터영역)
- [프레임워크, 라이브러리](#프레임워크-라이브러리)
- [디버그(debug)빌드, 릴리즈(release)빌드](#디버그debug빌드-릴리즈release빌드)
- [컴파일(Compile)](#컴파일compile)
- [자료크기](#자료크기)
- [값형, 참조형](#값형-참조형)
- [접두사](#접두사)
- [형변환](#형변환)
- [이스케이프문자](#이스케이프문자)
- [음수-표현법](#음수-표현법)
- [문자인코딩](#문자인코딩)
- [유리수표현법](#유리수표현법)
- [불대수](#불대수)
- [빅오 표기법(시간복잡도)](#빅오-표기법시간복잡도)
- [알고리즘](#알고리즘)
- [자료구조](#자료구조)
- [CLI(CMD,터미널,쉘)](#clicmd터미널쉘)
- [컴퓨터가 사진을 다루는법(그래픽 카드의 원리, VGA)](#컴퓨터가-사진을-다루는법그래픽-카드의-원리-vga)
- [컴퓨터가 글자를 다루는법](#컴퓨터가-글자를-다루는법)
- [기타, 도움링크](#기타-도움링크)

- <details markdown="1">
  <summary>진수</summary>
  <div markdown="1">
  
  - [진수](#진수)
    - [진법](#진법)
    - [8진법, 16진법, 32진법](#8진법-16진법-32진법)
    - [진수변환](#진수변환)
    - [비트,바이트](#비트바이트)
    - [비트, 음수와 양수의 관계 및 수의표현, 및 최하위 비트로 짝수 홀 수 판단](#비트-음수와-양수의-관계-및-수의표현-및-최하위-비트로-짝수-홀-수-판단)
    - [비트마스킹(bit masking)](#비트마스킹bit-masking)
  </div>
  </details>


- <details markdown="1">
  <summary>연산자</summary>
  <div markdown="1">
  
  - [연산자](#연산자)
    - [증감 연산자](#증감-연산자)
    - [비트이동연산자](#비트이동연산자)
    - [비트연산자](#비트연산자)
  </div>
  </details>


- <details markdown="1">
  <summary>Network기초</summary>
  <div markdown="1">
  
  우선, 유투브에서 ‘널널한 개발자’로 활동중이신, 최호성님의 강의를 보고. 많은 부분에서 정리와, 캡쳐한 내용임으로 출처를 밝힙니다!
https://www.youtube.com/watch?v=k1gyh9BlOT8 

  - [Network기초](#network기초)
    - [컴퓨터구조, 네트워크 계층](#컴퓨터구조-네트워크-계층)
    - [Port, IP, MAC](#port-ip-mac)
    - [LAN, WAN](#lan-wan)
    - [Host, Switch, End-point, Network](#host-switch-end-point-network)
    - [IP주소 종류](#ip주소-종류)
    - [DNS](#dns)
    - [웹 서비스 구조](#웹-서비스-구조)
    - [GET, POST](#get-post)
    - [네트워크 데이터 단위](#네트워크-데이터-단위)
    - [패킷의 생성 원리](#패킷의-생성-원리)
    - [Router의 구조, Inline, Out of path](#router의-구조-inline-out-of-path)
    - [Proxy](#proxy)
    - [TCP/IP 송수신 원리](#tcpip-송수신-원리)
    - [L2스위치](#l2스위치)
    - [TCP/IP통신시 MAC주소 변화](#tcpip통신시-mac주소-변화)
    - [L2스위치 작동원리, ARP](#l2스위치-작동원리-arp)
    - [TTL](#ttl)
    - [3 way handshake](#3-way-handshake)
    - [MTU, Packet 단편화](#mtu-packet-단편화)
    - [Unicast, Broadcast, Multicast](#unicast-broadcast-multicast)
    - [서브넷팅](#서브넷팅)
    - [공유기 작동원리](#공유기-작동원리)
    - [부하분산(Load Balancer)](#부하분산load-balancer)
    - [VPN작동원리(L3, IPSec)](#vpn작동원리l3-ipsec)
    - [네트워크 보안 종류](#네트워크-보안-종류)
    - [wireshark(패킷 분석 프로그램)](#wireshark패킷-분석-프로그램)
    
  </div>
  </details>


- <details markdown="1">
  <summary>운영체제</summary>
  <div markdown="1">
  
  - [운영체제](#운영체제)
    - [32비트와 64비트](#32비트와-64비트)
    - [기억 장치의 종류](#기억-장치의-종류)
    - [HDD의 논리적 구조와 SSD](#hdd의-논리적-구조와-ssd)
    - [API, Kernel, System Call, Interrupt](#api-kernel-system-call-interrupt)
    - [DMA(Direct Memory Access)](#dmadirect-memory-access)
    - [CPU와GPU](#cpu와gpu)
    - [Virtual Memory](#virtual-memory)
    - [Process와 Thread](#process와-thread)
    - [Process간 통신 IPC](#process간-통신-ipc)
    - [메모리관리](#메모리관리)
    
  </div>
  </details>

<br/>
<br/>

***

# 언어? 코딩? 컴파일? 기계어? 실행에 관하여

  - Native Code : CPU와 운영체제가 직접적으로 실행할 수 있는 코드이다. C와 C++언어 같은 경우 '컴파일'이라는 과정(전처리->컴파일->어셈블->링크)을 거쳐서 '실행파일인 기계어'가 된다. 프로그램을 실행하면, 이미 바로 기계가 이해할 수 있는 기계어 이기 때문에 바로 실행하게 된다. 하지만 단점으로는, OS및 HW환경이 달라지만 실행이 불가능 하게 된다.(C언어 C++언어 -> 컴파일(윈도우 API와 맞춰지면서 원시코드로 변경) -> 원시 코드를 실행 시켜서 작동)
  - 가상환경 위에서 작성되는 코드(C#, 자바 등)  : 각각의 언어들은 컴파일 및 실행을위한 가상 환경을 필요로 한다. 컴파일 하게 되면 각각의 언어들이 가지는 중간 언어로 작성된 실행 파일을 만든다. 프로그램을 실행 시키면, 가상환경에서 중간 코드를 읽어 들여 CPU 및 하드웨어가 이해할 수 있는 네이티브 코드로 컴파일한 후에 실행하게 된다. C#을 컴파일한 후 JIT 컴파일러에 의해 생성된 네이티브 코드는 C 및 C++용으로 컴파일된 기계어 코드와 동일하지 않다. 런타임 시 JIT 컴파일러에 의해 생성되는 플랫폼별 코드인 반면, C 및 C++용 머신 코드는 일반적으로 특정 플랫폼에 대해 미리 별도의 컴파일러에 의해 생성된다. JIT 컴파일러에 의해 생성된 코드는 실행 중인 특정 아키텍처 및 운영 체제에 맞게 최적화될 수 있으며 C 및 C++용 머신 코드는 특정 대상 플랫폼에 맞게 최적화된다.
  - C# API는 WIN32 API를 직접 래핑한 것이 아니다. C# API는 WIN32 API에서 제공하는 일부 서비스를 포함하여 다양한 시스템 서비스에 액세스하기 위한 상위 수준의 관리 인터페이스를 제공한다. C# API의 일부는 WIN32 API를 사용하여 구현되지만 C# API는 기본 시스템 서비스에 대한 상위 수준의 추상화된 보기를 제공하므로 하위 수준 WIN32 API와 직접 상호 작용하지 않고도 애플리케이션을 더 쉽게 개발할 수 있다.
  - 안드로이드 개발시 , 자바코드 -> 컴파일(자바 중간 언어,ART) -> 에뮬레이터 위에서 실행 -> 자바중간언어가 에뮬레이터안에 있는 안드로이드 API와 맞춰지면서 안드로이드 원시코드로 변경 되면서 실행 및 작동

###### [언어? 코딩? 컴파일? 기계어? 실행에 관하여](#언어-코딩-컴파일-기계어-실행에-관하여)
###### [Top](#top)

<br/>
<br/>

***

# 컴퓨터는 왜 이진법을 사용하는가?
  - 하드웨어 적으로 컴퓨터는 '전기가 흐른다 1', '전기가 흐르지 않는다 0'라는 두가지 상태밖에 없기 때문
  - 2진법을 사용

###### [컴퓨터는 왜 이진법을 사용하는가?](#컴퓨터는-왜-이진법을-사용하는가)
###### [Top](#top)

<br/>
<br/>

***

# 컴퓨터의 기본 구조3가지
  - C언어 같은 네이티브 언어는, OS에 직접적으로 의존적인 언어가 된다

![image](https://user-images.githubusercontent.com/39178978/209467550-f66135b7-f6fc-4a64-9f63-bb0300b7e469.png)

###### [컴퓨터의 기본 구조3가지](#컴퓨터의-기본-구조3가지)
###### [Top](#top)

<br/>
<br/>

***

# 언어분류
  - [언어수준(저수준언어, 고수준언어)](#언어수준저수준언어--고수준언어)
  - [타입별(강한타입, 약한타입)](#타입별강한타입-약한타입)
  - [처리수준(컴파일언어, JIT컴파일언어, 인터프리터)](#처리수준컴파일언어--jit컴파일언어--인터프리터)
  - [메모리관리(매니지드, 언매니지드)](#메모리관리매니지드-언매니지드)
  - [프로그래밍 패러다임(절차적언어, 개체지향 언어[OOP])](#프로그래밍-패러다임절차적언어-개체지향-언어oop))

###### [언어분류](#언어분류)
###### [Top](#top)

<br/>
<br/>

# 언어수준(저수준언어 , 고수준언어)
  - 컴퓨터가 이해하지 쉬운 언어에 가까울수록 저수준 언어
    - 0과1로만 이루어짐(= 기계어)
  - 인간이 이해하기 쉬운 언어에 가까울수록 고수준
    - 어셈블리어, C, C++ 등등
      - 어셈블리어는 기계어와 1:1대응하는 언어기 때문에 사실상 저수준 언어..(다른 언어는 1:1대응이 아님)
  - 언어의 수준은 상대적인 부분이 있음(ex 어셈블리어는 C 보다 상대적으로 저수준 언어)

###### [언어분류](#언어분류)
###### [Top](#top)

<br/>
<br/>

# 타입별(강한타입, 약한타입)
  - 타입검사에 엄격한가, 엄격하지 않은가에 대한것. 컴퓨터가 이해하는 데이터는 수로 이루어져 있기 때문에 사람 입장에서는 그 수만 보아서는 실제로 정수를
의미하는지 문자열을 의미하는지 알 수가 없기 때문에 타입지정이 생겨났음.따라서 강한타입일 수록 타입 검사에 엄격하기 때문에 추후에 생길 버그나 오류를 줄 일 수 있다.
  - ex) 파이썬 같은 경우는 변수형을 비선언 한다.

###### [언어분류](#언어분류)
###### [Top](#top)

<br/>
<br/>

# 처리수준(컴파일언어 , JIT컴파일언어 , 인터프리터)
  - 컴파일언어(코드 - 컴파일[기계어로 바꿔줌] - 기계어[실행파일로 바꿔줌 exe파일] - 실행)
    - 실행만 할 경우 마지막 두 단계만 왔다 갔다 하는것
    - 코드를 바꿔야 할 경유 처음부터 순서를 밟아 다시 진행한다
    - 다양한 최적화 가능(2시간 동안 컴파일, 0.1초 만에 실행)
    - 기계어가 나오기 때문에(다른 CPU에서 이해 불가능) 플랫폼마다 다른 exe파일을 컴파일 해야함
    - C, C++
  - JIT컴파일언어(코드 - 컴파일러[중간언어로 바꿔줌] - 중간언어["exe" <- 실행 파일이라고 하기 뭐함..] - JIT컴파일러(기계어) - 실행)
    - 프로그램 실행 중에 VM이 중간 언어를 기계가 이해하는 언어로 바꿔서 실행
    - 플랫폼 별로 VM(가상머신)을 설치해야함
    - 플랫폼에 종속적이지 않고 VM에 종속적임
    - C#, Java 등
  - 인터프리터언어(코드 - 인터프리터[기계어로 바꿔줌 <- 실행하면서 실시간으로 바꿔줌] - 실행)
    - 실제로 실행하기 전까지 코드의 문제를 잡아낼 수 없음

###### [언어분류](#언어분류)
###### [Top](#top)

<br/>
<br/>

# 메모리관리(매니지드, 언매니지드)
  - 매니지드 언어 : 언어가 메모리를 관리해줌
    - 언어가 자체적으로 모든 상황에서, 충분한 판단으로 메모리를 반환하기 때문에 명시적으로 반환하는 것보다 효율적이지 않음
  - 언매니지드 언어 : 언어가 메모리를 관리 안해줌
    - 명시적으로 메모리를 반환하기 때문에 효율적임
    - 프로그래머가 신경써 줘야 되기 때문에 실수가 나올 수 있음
    - 성능이 필요할 경우에 사용
    - 메모리동작원리, CPU동작원리, 컴퓨터처럼 생각하는 방법, 매니지드 언어에서 지원하는 마법같은 기능의 동작원리 등을 알 수 있고 이해할 수 있게 된다.

###### [언어분류](#언어분류)
###### [Top](#top)

<br/>
<br/>

# 프로그래밍 패러다임(절차적언어, 개체지향 언어[OOP])
  - 절차적 언어 : 순서에 따라 위에서 부터 아래로 절차적으로 코드를 실행하는 것. 컴퓨터의 처리구조와 유사해 속도가 빠름
  - 개체지향 언어(클래스) : 기능과 자료를 하나의 개체에 합침
    - 사람에게 직관적. ex)사물을 볼때 하나의 정보만 보는 것이 아니라 컬러,질감,모양,무게 등 다양한 정보로 하나의 사물을 바라봄
    - 복잡한 프로그램의 구조를 잡기 쉽다, 재사용성 증가, 변형가능성을 높일 수 있음

###### [언어분류](#언어분류)
###### [Top](#top)

<br/>
<br/>

***

# 스택, 힙, 코드, 데이터영역
  - OS에서 프로세스가 바라보는 메모리 영역은 크게 코드(Code), 데이터(Data), 힙(Heap), 스택(stack) 영역으로 나뉘어진다. 
  - Code 영역
    - 실행할 코드와 매크로 상수가 기계어의 형태로 저장
    - 컴파일 타임에 결정
    - 중간에 코드를 바꿀 수 없게 Read-Only 로 지정
    - CPU는 코드 영역에 저장된 명령을 하나씩 가져가서 처리한
  - Data 영역
    - 전역 변수와 정적(static) 변수가 저장되는 영역
    - 전역변수/static 값을 참조한 코드는 컴파일 하고 나면 Data 영역의 주소값을 가르키도록 변경됨
    - Read-Write로 지정
  - Stack 영역 
    - 지역변수, 매개변수, 리턴값, 돌아올 주소 등등이 저장되고 함수 호출시 기록하고 종료되면 제거
    - 후위선출(LIFO) 방식
    - 컴파일 타임에 크기가 결정
    - 재귀함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 stack overflow 에러가 발생
  - Heap 영역
    - malloc() 또는 new 연산자를 통해 메모리를 할당
    - Heap은 런타임에 결정
    - 스택보다 할당할 수 있는 메모리 공간이 많다
    - 메모리 영역을 접근해야 하기 때문에 다른 자료구조에 비해서 데이터를 읽고 쓰는게 느리다

###### [스택, 힙, 코드, 데이터영역](#스택-힙-코드-데이터영역)
###### [Top](#top)

<br/>
<br/>

***

# 프레임워크, 라이브러리
  - 라이브러리 : 여러 함수들을 모아 놓은 집합. 프로그래머가 필요할때 가져와서 대체해 사용할 수 있음
  - 프레임워크 : 라이브러리의 상위 개념, 제공받은 일정한 요소와 틀, 규약을 가지고 무언가를 만들어 낼 수 있음
  - 라이브러리와 프레임워크의 차이는, 라이브러리는 필요할때 필요한 함수를 프로그래머가 불러다가 쓸 수 있지만, 프레임워크는 프로그래머가 부르는 것이 아니라, 프로그래머가 그 안에 들어가 일정한 틀과 규약을 준수 하면서 개발을 해날갈때 쓰는 도구 같은것.
  - C#은 최상단에 'Using'지시어 뒤에 사용할 라이브러리(= 네임 스페이스 라고도 부름) 이름을 넣는다.

###### [프레임워크, 라이브러리](#프레임워크-라이브러리)
###### [Top](#top)

<br/>
<br/>

***

# 디버그(debug)빌드, 릴리즈(release)빌드
  - 디버그빌드 : 개발자가 개발 중에 사용하는 실행파일
    - 디버깅에 유용한 많은 정보가 담겨 있음
    - 성능 떨어짐
  - 릴리즈빌드 : 실제 사용자에게 배포하는 실행파일
    - 디버깅을 위한 정보는 빠지게 됨
    - 성능 빠름

###### [디버그(debug)빌드, 릴리즈(release)빌드](#디버그debug빌드-릴리즈release빌드)
###### [Top](#top)

<br/>
<br/>

***

# 컴파일(Compile)
  - 소스코드를 기계 또는 VM(Virtual Machine)이 이해할 수 있는 언어로 변경하는 행위
    - 컴파일로(compiler)라는 프로그램이 진행해줌 ex)IDE(통합개발 환경)
    - 컴파일 할때 오류또는 경고가 발생할 수 있음

###### [컴파일(Compile)](#컴파일compile)
###### [Top](#top)

<br/>
<br/>

***

# 자료크기
  - 비트(bit) : 최소단위 1혹은0을 담을 수 있음
  - 바이트(byte) : 8비트가 모인것
  - 1024바이트 = 1킬로 바이트(KB)
  - 1024킬로바이트 = 1메가 바이트(MB)
  - 기가,테라,페타....

<br/>

  - 하지만 현재 판매하고 있는 하드디스크, 네트워크, 인터넷망 등은 1000바이트 = 1킬로 바이트, 1000킬로바이트 = 1메가 바이트 이렇게 되어 있음. 그래서 1GB외장 하드를 구매 해서 컴퓨터에서 본다면 데이터를 잃어 버리는 격이 된다.(하드디스크 : 1GB = 1,000,000,000바이트, 컴퓨터 : 1,000,000,000 / 1024 / 1024 / 1024 = 0.931GB)

###### [자료크기](#자료크기)
###### [Top](#top)

<br/>
<br/>

***

# 값형, 참조형
  - 값형 : 자신이 직접 데이터를 저장해서 보관하는 자료형(스택 영역에 저장)
    - 스택은 메모리에 아래서부터 데이터가 쌓였다가 데이터가 제거될 때는 맨 위에 있는 데이터부터 차례로 제거되는 방식이다
  - 참조형 : 데이터가 저장되어 있는 힙의 위치만 자신이 저장하고 있다가 필요할 때 그 데이터가 있는 곳으로 가서 데이터를 얻어오는 자료형(힙 영역에 저장)  
    - 힙은 쌓여 있는 구조가 아니라, 임의의 메모리에 데이터를 저장한다. 그러한 특성 때문에 힙은 자유 기억 공간이라고도 한다

###### [값형, 참조형](#값형-참조형)
###### [Top](#top)

<br/>
<br/>

***

# 접두사
  - 0b- : 2진수 ex) int num1 = 0b10  //이때 num1에 들어가는 수는 2가됨
  - 0x- : 16진수 ex) int num1 = 0x10 //이때 num1에 들어가는 수는 16이됨  

###### [접두사](#접두사)
###### [Top](#top)

<br/>
<br/>

***

# 형변환
  - 묵시적 변환 : 컴파일러가 '알아서' 해주는것
    - 모든 자료형을 바꿀 수 있는 것은 아님
  - 명시적 변환 : 프로그래머가 명시적으로 형변환을 지시함(전부x)
  - 승격 : 컴파일러가 자동으로 실수형이나 부동소수형 자료의 이진 표현을 확장 하는것
    - double num1 = 5.5, int num2 = 3 / num1 + num2 = 8.5가 나오게 된다. double로 승격하여 계산 한것
      - [꼼수 : 승격을 이용하여double number = 123.456 을 소수점 첫째 자리만 나타내기
](https://github.com/BuMinKyoo/TIL/tree/main/C%23/%EA%BC%BC%EC%88%98...)

###### [형변환](#형변환)
###### [Top](#top)

<br/>
<br/>

***

# 이스케이프문자
  - \n -> 줄바꿈
  - \t -> 탭
  - \' -> 작은따옴표 출력
  - \" -> 큰따옴표 출력
  - \\ -> 백슬래시 출력
  - \x(숫자) -> 아스키값16진수 출력 ex) \x120출력 -> ?가 출력됨

###### [이스케이프문자](#이스케이프문자)
###### [Top](#top)

<br/>
<br/>

***

# 음수 표현법
  - 공부한 블로그 링크 : https://st-lab.tistory.com/189 
  - 부호 절대값(Sign-Magnitude) : 컴퓨터 세계에서 부호를 붙이기 위해서 8비트의 최상위 비트가 0이면 양수, 1이면 음수로 지정하게 됨
    - 단점
      - +0과, -0둘다 존재하는것
      - 양수+양수 덧셈은 문제가 없지만, 음수+양수, 양수+음수, 음수+음수를 할때 각 상황마다 다르게 고려해야 된다.

<img src="https://user-images.githubusercontent.com/39178978/155979686-84fee69b-40e6-4c00-b021-39c656c943ed.png"/>

  - 1의 보수 (One's Complement)
    - ex) 7에 대한 10의 보수 : 7 + 3 = 10 => 3 / 17에 대한 10의 보수 : 17 + 83 = 100 => 83
    - ex) 7에 대한 9의 보수 : 7 + 2 = 9 => 2 / 17에 대한 9의 보수 : 17 + 92 = 99 => 82
    - ex) 10의 보수를 이용한 계산(-20+45) : (100-20)+45-100 => 80+45-100 => 125-100(올림이 발생하니 버림) = 25
    - ex) 0000 0011에 대한 1의 보수 : 0000 0011 + 1111 1100 = 1111 1111 => 1111 1100(음수는 양수의 비트를 반전시킨 값)
    - 8비트짜리 정수일경우 0과 +0이 존재 하기 때문에 수의 범위는 [-127,127]
    - 단점
      - +0과, -0둘다 존재하는것
      - 계산시 캐리가 발생하면 +1을 해줘야함

<img src="https://user-images.githubusercontent.com/39178978/155984631-d0175195-6254-4aa8-99cf-86a2675d8f4c.png"/>

  - 2의 보수 (Two's Complement)
    - 1의 보수에서 사용하면 -0(1111 1111)을 없애고 -1씩 대응시키게됨
    - 어떤 수의 부호를 바꾸고자 하면 비트를 반전시키고 거기에 1을 더하면됨
    - 부호 절대값과 1의 보수에 있었던 문제를 모두 해결하게 됨
    - 8비트짜리 정수일 경우 0이 하나만 존재 하기 때문에 수의 범위는 [-128,127]
    - 장점
      - 0이 1개 밖에 없음
      - 캐리가 발생해도 +1을 하지 않아도 됨
      - 양수+양수, 양수+음수, 음수+양수, 음수+음수의 모두 계산이 문제가 없음

<img src="https://user-images.githubusercontent.com/39178978/155987419-97bcb7b8-b958-41b7-8039-c88b5ca37a2c.png"/>

###### [음수-표현법](#음수-표현법)
###### [Top](#top)

<br/>
<br/>

***

# 문자인코딩
  - 아스키(ASCII)
    - 영어 알파펫과 기호들을 컴퓨터에서 표현하는 규약
    - 최초의 아스키는 총 128개의문자를 표현(7비트사용, 1비트는 오류 검증으로 사용)
    - 영어권에서는 주로 아스키를 사용함(영어와, 특수문자가 다 들어가 있기 때문)
  - ANSI(Windows-1252, CP-1252)
    - ASCII의 확장판
    - 영어뿐만 아니라 다른 라틴문자 기반의 언어를 표시하기 위해 만든 문자 인코딩
    - 256개의 문자를 표현(8비트를 모두사용) => 하지만 이렇게 해도 세상의 모든 언어를 표시 할 수 없기 때문에 CodePage개념이 추가됬다.
    - ANSI = ASCII Code(7bit) + CodePage(1bit)
  - 멀티바이트(Multibyte)_MBCS
    - Ms사가 급부상 하게 되었을때, Ms사가 만들었음
    - 표기할 문자가 많은, 1바이트에 담을 수 없는 언어들을 위해서 나옴
    - 기본적으로 아스키코드에 들어가 있는 1바이트(영문,숫자,기본적인 특수문자)는 그대로 가고, 그다음에 더 필요한 문자들을 채워 넣음
    - ex) EUC-KR, EUC-CN, EUC-TW 등등...
    - 여러 언어를 한번에 표현 하지 못하기 때문에, 한페이지에 다른 나라 언어가 적혀 있으다면 동시에 표현이 안됨
    - 영문 한글자 = 1byte처리, 한글 한글자 = 2byte처리
  - 유니코드(Unicode)
    - 전 세계의 모든 문자 및 이모지까지 '일관되게'표현할 수 있는 규격
    - 2021년09월14일에 Unicode 14.0이 나왔고 144,697문자를 표현한다, 지금도 계속 늘려 가고 있음
    - UTF-8(1바이트), UTF-16(2바이트), UTF32(4바이트) : 한글자를 저장할때 몇바이트를 쓸건지 명시하는것
    - 한글은 초기에 조합형, 완성형에 대한 고민이 있었지만, 완성형으로 결정됨(아래 사이트에서 확인 가능)
      - unicode.org
        - 여기에 나와 있는 것은 기본적으로 UTF-16 인코딩되어 표기되어 있기때문에, 영문과 한글 모두 2byte로 표기됨
 
![image](https://user-images.githubusercontent.com/39178978/209461102-1413d2db-b1db-45c6-8a48-e02749055ac4.png)

![image](https://user-images.githubusercontent.com/39178978/209461105-ce2030cd-b642-4e4d-9a7c-ad7216581a1b.png)
 
![image](https://user-images.githubusercontent.com/39178978/209461958-03535740-02e4-4a8f-8a35-216bc93a8664.png)

![image](https://user-images.githubusercontent.com/39178978/209462079-55778768-5ec4-4392-a429-fc1fe8d282b8.png)
 
 <br/>
 
  - 유니코드(Unicode) 인코딩 규칙
    - UTF-8
      - 아스키 코드와 100% 호환
      - 바이트 정렬(엔디언)문제가 발생하지 않음
      - CJK(중국,일본,한국)를 제외한 거의 모든 문자에 1바이트 또는 2바이트를 사용
        - 한국어는 대부분 3바이트가 필요함 => UTF-16을 쓰면 대부분 2바이트로 표현 가능
      - UTF-8은 1바이트, 즉 8비트 이다, 유니코드상 표기가 높은 수쪽에 있는 한국어의 경우 UTF-8로 인코딩 했을시 2바이트 또는 3바이트가 필요하기 때문에, '비트 패턴을 넣어서 이 글자가 몇 바이트로 인코딩 되고 있는지'를 알려 주어야 한다. => 따라서 몇개의 비트수를 낭비하지만 4바이트까지 총 21개 비트를 표현 할 수 있다.(2,097,152개 표현)
      - 글자가 영어인지, 한글인지 등 확인후, 범위에 따라서 바이트 수가 달라지게 표현됨

<img src="https://user-images.githubusercontent.com/39178978/156084310-07986758-02a3-48a4-bab5-dbda2e15edd3.png"> 

![image](https://user-images.githubusercontent.com/39178978/209461779-2f28861c-3224-4e49-9aa9-6381cc8ee944.png)

  - 유니코드(Unicode) 인코딩 규칙(이어서)
    - UCS-2
      - 고정 2바이트 인코딩
      - UTF-16이 나오기 전에는 이것을 사용했으며, 기본 언어판영역(U+0000~U+FFFF)만 인코딩 할 수 있는 고정인코딩 방식이며, 그 것을 넘어가는 글자는 표현할 수 없다

    - UTF-16
      - 인코딩/디코딩 규칙이 복잡
      - 엔디언 문제 ex)리틀 엔디언으로 저장했는데 빅 엔디언으로 읽으면 잘못된 결과 나옴
      - 아스키와 호환 안됨
      - 메모장을 다른이름 으로 저장시 UTF-16 LE : 리틀 엔디언, UTF-16 BE : 빅 엔디언
      - UTF-16은 UCS-2와 다르게 가변길이이며. 기본 언어판영역(U+0000~U+FFFF)은 한개의 16-bit가 되고, 다른 언어판(U+10000 이상)은 두개의 16-bit로 표현되어, 모든 언어를 표현할 수 있는 인코딩이다.

![image](https://user-images.githubusercontent.com/39178978/209461833-f9b0ae99-a62c-4b15-ae69-9dc3d0e7b838.png)

![image](https://user-images.githubusercontent.com/39178978/209462086-a47b784e-f0cf-47e6-b482-b278d53a4f96.png)

  - 유니코드(Unicode) 인코딩 규칙(이어서)
    - UTF-32
      - 유니코드 code point와 1:1대응
      - 용량 낭비가 심함
      - 아스키와 호환 안됨
      - 엔디언 문제 있음

<br/>

  - URL인코딩
    - 웹통신을 할때 쓰는 인코딩값(= UTF-8을 사용)
    - 16진수 값으로 날아가게 되고, 16진수 값을 그대로 썼다는 의미로 앞에 % 를 붙이게 된다
    - EX) 감 == %EA %B0 %90 

<br/>

  - Window어플리케이션 개발시
    - MBCS(멀티바이트) : 영문은 1byte, 한글은 2byte
    - WBCS(= 일명 유니코드 방식) : 모든 문자를 2byte
    - 멀티바이트는, 문자에 따라 크기를 다르게 가지므로 프로그램을 짤때 항상 문자의 종류에 따라 문자의 크기를 고려하여 프로그램을 해야 하기 때문에 번거롭게 되지만, 유니코드방식으로 하게 되면 항상 일정하기 때문에 쉬워진다

<br/>

  - Base64인코딩
    - 6bit씩 끊어서, 특정한 ASCII문자로 처리하게 된다
    - Base64인코딩을 하면 6bit를 ASCII문자(8bit) 하나로 처리하게 되어 오히려 효율 면에서 떨어지게 된다
    - 6bit씩 자르다가 마지막에 6bit가 남아 있지않다면, "="을 사용해서 padding을(필요 없는 값) 추가해 보내게 된다.
    - 왜 할까?
      - HTML문서는 ASCII로 되어 있음. ASCII로 표현할 수 없는 바이너리 데이터가 있을 수 있음(ex. 이미지). 그것을 강제로 HTML문서 안에다가 포함 시킬때 유용하다.
        - 누군가가 HTML + 이미지를 요청할때, HTML안에 모두 포함되어 있으면 1번의 요청 만으로 다 받을 수 있지만 그렇지 않다면 HTML + 이미지를 각각 한번씩 요청해서 받아야 한다(요청을 1번 한다는 효율이 있음!)

###### [문자인코딩](#문자인코딩)
###### [Top](#top)

<br/>
<br/>

***

# 유리수표현법
  - 10진법 실수  550.337 = 500 + 50 + 0 + 0.3 + 0.03 + 0.07

<img src="https://user-images.githubusercontent.com/39178978/156096606-5d286196-a5f5-4165-9bbc-05431083b942.png"/>

<br/>

  - 2진법 실수 101.011 = 4 + 0 + 1 + 0/2 + 1/4 + 1/8

<img src="https://user-images.githubusercontent.com/39178978/156096940-4a6397b9-14a9-479d-98da-cb4414ba8a50.png"/>

<br/>

  - 실수의 10진수 -> 2진수 변환
    - 11.8125 = 1011.1101(2진수) => [8  4  2  1 . 0.5  0.25  0.125  0.0625]
    - 10진수 0.1을 2진수로 바꾸려고 하면 나누어 떨어지지 않기 때문에 정확하게 표현 되지 못한다.

<img src="https://user-images.githubusercontent.com/39178978/156138197-24e8bfb0-a508-41ac-922e-fda36f809007.png" width="250" height="500"/>

<br/>

  - 고정 소수점 수
    - 언제나 정해진 자리에 소수점이 찍혀 있다는것
    - 8비트를 예로 들면, 부호비트로 1개소, 정수부분 4개소, 소수부분 3개소로 표현 한다면 기호로 Q4.3이라고 표현 함
    - 표현할 수 있는 범위의 값은 확실히 표현 가능(오차가 없어야 하는 제품에 적합)
    - 표현 가능한 범위가 작아짐

  - 부동 소수점 수
    - 소수점 자리가 정해져 있지 않다
    - 돈 관련되서는 사용하는데 부적합함 => 하지만 다른곳에 사용하는데는 큰 문제는 없음 ex) 0.001m잘못 움직였다고 일반적으로 큰일이 나지 않음
    - 표현 가능한 범위가 넓음
    - IEEE 754표준을 따름

  - IEEE 754표준(32비트 부동 소수점)
    - 부호비트 : 1비트 / 지수비트 : 8비트 / 가수비트 : 23비트
    - 정규화 작업 : 110.110111 => (+1) * 1.10110111 * 2의2승 / -0.00123 => (-1) * 1.23 * 2의마이너스2승
    - 음수를 표현할때 부호 절대값 방식을 사용함
    - ex) 234.48 => 11101010.0111101011100001 = 1 * 1.11010100111101011100001 * 2의7승
      - 부호비트 = 0
      - 지수비트 : 10000110(7+127 = 134)
      - 가수비트 : 11010100111101011100001
    - ex) -234.48 => 11101010.0111101011100001 = (-1) * 1.11010100111101011100001 * 2의7승
      - 부호비트 = 1
      - 지수비트 : 10000110(7+127 = 134)
      - 가수비트 : 11010100111101011100001
    - ex) 3.14 => 11.0010001111010111000011 => 1 * 1.10010001111010111000011 * 2의1승
      - 부호비트 : 0
      - 지수비트 : 100000000(1+127 = 128)
      - 가수비트 : 10010001111010111000011
      - 0 100000000 10010001111010111000011 => 10진수 변한 => 지수 : 128 - 127 = 1 / 가수 : 10010001111010111000011 = 1.10010001111010111000011 => 1.10010001111010111000011 * 2의1승 = 11.0010001111010111000011 => 3.1400001049041748046875 => 값이 오차가 생김!
    - float 정밀도 : 6 ~ 9자리 / double 정밀도 : 15 ~ 18 <= 범위가 있다는 것이 이상한데 그 이유를 아래에 설명
      - float 정밀도 : 6자리 : 10진수 실수를 float(double)에 저장했다가 다시 그걸 10진수 실수로 변환한뒤, 원래 10진수 실수와 동일한 유효 숫자로 맞출 때 원래 값이 그대로 나올 수 있는 최대 유효숫자 수는 6자리이다
      - float 정밀도 : 9자리 : 서로 다른 수가 정말 다르다는 걸 알려면 최대9번째 유효숫자까지 확인해야 한다는것

~~~c#
//float 정밀도 : 6자리

static void Main(string[] args)
{
    long i = 123456000000000;
    float f = i;
    i = (long)f;
    Console.WriteLine(i);
}

출력
123455999574016 <= 6자리 그 다음에 7번째에서 반올림 하면 123456이 나오게됨. 그러므로 어떤 유효숫자 다음의 수는 그 유효숫자가 되기 위한 근접 수로 표현 하게됨
~~~

###### [유리수표현법](#유리수표현법)
###### [Top](#top)

<br/>
<br/>

***

# 불대수
  - 드 모르간의 법칙 => 전체를 뒤집으면 결과가 같음
  - if(!(age >= 20 && height >= 140)) = if(age < 20 || height < 140)
  - if (!(student.Age < 25 || student.TermNum == 2)) = if(student.Age >= 25 && student.TermNum != 2)

###### [불대수](#불대수)
###### [Top](#top)

<br/>
<br/>

***

# 빅오 표기법(시간복잡도)
  - O(1) : 반복문이 없음, 상수 => 오직 한 단계만 거침
  - O(log n) : 분할 알고리즘 ex)이진탐색 => 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬 
  - O(n) : for문 하나
  - O(n^2) : 이중 for문 => for문이 밖에 있으면 2n이됨
  - O(2^n) : 피보나치
  - O(n!) : 모든 도시를 단 한번만 방문한 뒤 다시 첫 도시로 돌아오는 경로, 완전탐색

<img src="https://user-images.githubusercontent.com/39178978/156878962-9f1d688b-9d06-40cd-ae2b-918bb9040f24.png" width="600" height="350"/>

###### [빅오 표기법(시간복잡도)](#빅오-표기법시간복잡도)
###### [Top](#top)

<br/>
<br/>

***

# 알고리즘
  - 자료구조에 쌓인 데이터를 활용해 어떤 동작들을 만들어 가는것

###### [알고리즘](#알고리즘)
###### [Top](#top)

<br/>
<br/>

***

# 자료구조
  - 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조
  나중에 더 추가하기...
 
 ###### [자료구조](#자료구조)
 ###### [Top](#top)
 
<br/>
<br/>

***

# CLI(CMD,터미널,쉘)
  - 현재는 GUI로 컴퓨터를 사용했지만 예전에는 GUI환경이 아닌 CLI(명령어로 컴퓨터를 조작하는 방식)환경에서 컴퓨터를 이용해 왔음. 요즘에는 대부분 운영체제에서 GUI로 작동 시키기 때문에 현재는 CLI를 ‘컴퓨터를 직접 제어하기 위해 사용하는 소프트웨어’ 정도로 생각해보면 된다.
  - CLI가 일부 작업을 완료하는 것이 훨씬 빠르고, GUI로 사용하는 것보다 훨씬 많은 명령을 내릴 수가 있다
  - GUI로 여러번 해야 하는 것을, 명령어 하나로 처리 할 수 있다

 ###### [CLI(CMD,터미널,쉘)](#clicmd터미널쉘)
 ###### [Top](#top)

<br/>
<br/>

***

# 컴퓨터가 사진을 다루는법(그래픽 카드의 원리, VGA)
  - 컴퓨터가 사진을 다루는법(그래픽 카드의 원리, VGA)
    - 16비트 사용시 : 하이컬러
    - 24비트 사용시 : 트루컬러
    - 32비트 사용시 : 트루컬러 + 알파 채널

픽셀 하나에 필요한 비트 수가 16,24,32개라는 의미로써, 이렇게 사진도 비트들이 모여서 정해진 컬러의 빛을 쏘아 표현하게 된다.

 ###### [컴퓨터가 사진을 다루는법(그래픽 카드의 원리, VGA)](#컴퓨터가-사진을-다루는법그래픽-카드의-원리-vga)
 ###### [Top](#top)

<br/>
<br/>

***

# 컴퓨터가 글자를 다루는법
  - 아스키 코드와 같이, 1:1로 문자와 특정한 비트를 대응해서 표현한다.
  - 다양한 인코딩 규격이 있으며, 인코딩 규칙을 참고하면 된다

 ###### [컴퓨터가 글자를 다루는법](#컴퓨터가-글자를-다루는법)
 ###### [Top](#top)

<br/>
<br/>

***

# 기타, 도움링크
- CS공부 하기 좋은 사이트 : https://gyoogle.dev/blog/computer-science/data-structure/Heap.html

###### [기타, 도움링크](#기타-도움링크)
###### [Top](#top)

<br/>
<br/>

***

# 진수
  - [진법](#진법)
  - [8진법, 16진법, 32진법](#8진법-16진법-32진법)
  - [진수변환](#진수변환)
  - [비트,바이트](#비트바이트)
  - [비트, 음수와 양수의 관계 및 수의표현, 및 최하위 비트로 짝수 홀 수 판단](#비트-음수와-양수의-관계-및-수의표현-및-최하위-비트로-짝수-홀-수-판단)
  - [비트마스킹(bit masking)](#비트마스킹bit-masking)

###### [진수](#진수)
###### [Top](#top)

<br/>
<br/>

# 진법
  - 수를 표현하는 방법
  - 2진법, 8진법, 10진법, 16진법 등
  - ex) 2진법 : 2개의 숫자를 사용하여 수를 표현하는 방법 => 표현법 0b (0,1)
  - ex) 16진법 : 16개의 숫자를 사용하여 수를 표현하는 방법 => 표현법 0x (1,2,3,4,5,6,7,8,9,A,B,C,D,E,F)

###### [진수](#진수)
###### [Top](#top)

<br/>
<br/>

# 8진법, 16진법, 32진법
  - 비트는 단위가 작아서 비트 8개 모인 바이트를 기본 단위로 사용하게 되는데, 8진법이나, 32진법 같은 경우 비트수 3개, 5개 이기 때문에 메모리 단위로 데이터를 저장하기에는 딱딱 끊어지지 않아서 적합하지는 않는다. 그에 비해서 16진법은 비트수4개로(1바이트에 16진수 자리는 2개) 잘 들어맞기 때문에 적합하다고 할 수 있다

###### [진수](#진수)
###### [Top](#top)

<br/>
<br/>

# 진수변환
  - 10진수 -> 다른진수 바꿀때, 10진수 수를 다른진법에 해당하는 수로 나누어서 나머지쪽 부터 확인하면 됨

10진수 -> 2진수
<img src="https://user-images.githubusercontent.com/39178978/155839336-a1ef1e91-29be-4e67-be07-40d3033794f8.jpg" width="250" height="350">

<br/>

10진수 -> 8진수
<img src="https://user-images.githubusercontent.com/39178978/155839339-cf8fdeaf-9b35-44f3-b043-fb04b08722ed.jpg" width="250" height="350">

<br/>

  - 2진수 -> 8진수 : 2진수를 세 자리씩 끊어서 8진수 한자리로 변환
  - 8진수 -> 2진수 : 8진수 한 자리를 2진수 세자리로 변환

<img src="https://user-images.githubusercontent.com/39178978/155839708-eb10184a-2afb-470e-9e08-e393bb5cf27d.jpg" width="250" height="350">

  - 2진수 -> 16진수 : 2진수를 네 자리씩 끊어서 16진수 한자리로 변환
  - 16진수 -> 2진수 : 16진수 한 자리를 2진수 네자리로 변환

<img src="https://user-images.githubusercontent.com/39178978/155839703-3b9e8489-f6fd-4482-a5f2-afe51fa010d1.jpg" width="250" height="350">

<br/>

  - 8진수 -> 16진수 : 2진수를 거쳐서 변환 하는것이 편함

###### [진수](#진수)
###### [Top](#top)

<br/>
<br/>

# 비트,바이트
  - 비트 : 컴퓨터의 구성요소인 트랜지스터에 전기가 흐르면 1, 흐르지 않으면 0 으로, 트랜지스터의 상태를 기록하는 최소 단위를 비트라고 한다
  - 바이트 : 비트가 8개 모인 데이터

###### [진수](#진수)
###### [Top](#top)

<br/>
<br/>

# 비트, 음수와 양수의 관계 및 수의표현, 및 최하위 비트로 짝수 홀 수 판단
  - 비트당 표현 가능한수 2가지, 즉 2의 n승가짓수로 표현 가능
  - 부호 있는 자료형은 양수에서 0을 포함함으로 범위로는 음수가 1개소 더 많이 표현 가능
    - ex) sbyte인 경우 8비트 이기 때문에 표현 가능한 수는 2의 8승으로 256가짓수. 0을 양수에 포함 시키고 절반씩 나누게 되면 음수는 128가지 양수는 0을 제외한 127가지, 즉 [-128~127]까지의 수를 표현 가능
    - ex) ㅁㅁㅁㅁㅁㅁㅁㅁ 8개의 비트가 있다면 맨 위쪽의 최상위 비트 가짓수가 나머지 표현 가능한 비트의 수많큼이 되므로, 음수는 최상위 비트가 1로 표현 된다고 볼 수 있다.
    - 자료형의 크기보다 크기가 커지거나 작아지면 '오버플로우' 또는 '언더플로우'가 발생한다
    - 최하위 비트가 0이면 짝수, 1이면 

###### [진수](#진수)
###### [Top](#top)

<br/>
<br/>

# 비트마스킹(bit masking)
  - 각각의 비트에 하나의 기능을 만든후, 그것을 키고 끄고 하는식으로 이용
  - 하나의 비트만을 켜고 싶을 경우
    - 어떤수에 |(비트 합 연산)을 하고, 켜고 싶은 비트만을 1 로 해두기 ex) 0b0000 1000
  - 하나의 비트만을 끄고 싶을 경우
    - 어떤수에 &(비트 곱 연산)을 하고, 끄고 싶은 비트만을 0 으로 해두기 ex) 0b1111 0111
  - 특정 비트 토글하기
    - 어떤수에 xor연산을 하고, 토글 하고 싶은 비트만을 1 로 해두기 ex) 0b0000 1000

###### [진수](#진수)
###### [Top](#top)

<br/>
<br/>

***

# 연산자
  - [증감 연산자](#증감-연산자)
  - [비트이동연산자](#비트이동연산자)
  - [비트연산자](#비트연산자)

###### [연산자](#연산자)
###### [Top](#top)

<br/>
<br/>

# 증감 연산자
  - 증감 연산자(++ , --)
    - 증감 연산자가 앞쪽에 있으면 증감 해주고 계산
    - 증감 연산자가 위쪽에 있으면 계산후 증감

~~~c#
int num = 0;
Console.WriteLine(++num + ++num + ++num); // 6
~~~

~~~c#
int num = 0;
Console.WriteLine(num++ + num++ + num++); // 3
~~~

###### [연산자](#연산자)
###### [Top](#top)

<br/>
<br/>

# 비트이동연산자
  - 비트이동연산자(<<[왼쪽으로이동], >>[오른쪽으로이동])

~~~c#
int num = 1; //num = 0b0001
int num2 = num << 3; //num2 = 0b1000
Console.WriteLine(num2); //num2 = 8
~~~

###### [연산자](#연산자)
###### [Top](#top)

<br/>
<br/>

# 비트연산자
  - 비트연산자(&[and], |[or], ^[xor], ~[not])
  - 연산자 우선순위 : & -> ^ -> |

~~~c#
0b0011 & 0b0010 => 0b0010
0b0011 | 0b0010 => 0b0011
0b0011 ^ 0b0010 => 0b0001
~0b0011 => 0b1100
~~~

  - xor 연산자로 두수 바꾸기

~~~c#
static void Main(string[] args)
{
    int a = 3;
    int b = 8;

    a = a ^ b;
    b = b ^ a;
    a = a ^ b;

    Console.WriteLine($"a : {a}, b : {b}");
}

출력
a : 8, b : 3
~~~

###### [연산자](#연산자)
###### [Top](#top)

<br/>
<br/>

***

# Network기초
  - [컴퓨터구조, 네트워크 계층](#컴퓨터구조-네트워크-계층)
  - [Port, IP, MAC](#port-ip-mac)
  - [LAN, WAN](#lan-wan)
  - [Host, Switch, End-point, Network](#host-switch-end-point-network)
  - [IP주소 종류](#ip주소-종류)
  - [DNS](#dns)
  - [웹 서비스 구조](#웹-서비스-구조)
  - [GET, POST](#get-post)
  - [네트워크 데이터 단위](#네트워크-데이터-단위)
  - [패킷의 생성 원리](#패킷의-생성-원리)
  - [Router의 구조, Inline, Out of path](#router의-구조-inline-out-of-path)
  - [Proxy](#proxy)
  - [TCP/IP 송수신 원리](#tcpip-송수신-원리)
  - [L2스위치](#l2스위치)
  - [TCP/IP통신시 MAC주소 변화](#tcpip통신시-mac주소-변화)
  - [L2스위치 작동원리, ARP](#l2스위치-작동원리-arp)
  - [TTL](#ttl)
  - [3 way handshake](#3-way-handshake)
  - [MTU, Packet 단편화](#mtu-packet-단편화)
  - [Unicast, Broadcast, Multicast](#unicast-broadcast-multicast)
  - [서브넷팅](#서브넷팅)
  - [공유기 작동원리](#공유기-작동원리)
  - [부하분산(Load Balancer)](#부하분산load-balancer)
  - [VPN작동원리(L3, IPSec)](#vpn작동원리l3-ipsec)
  - [네트워크 보안 종류](#네트워크-보안-종류)
  - [wireshark(패킷 분석 프로그램)](#wireshark패킷-분석-프로그램)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 컴퓨터구조, 네트워크 계층

  - 컴퓨터의 구조
    - 하드웨어
    - 소프트 웨어
      - 시스템 소프트웨어(Kernel)
      - 애플리케이션(User)

  - 네트워크의 계층적 구분
    - OSI 7 LAYER 와 DoD Four-Layer Model 의 2가지가 있다
      - OSI 7 LAYER 에서의 구분
        - 7 응용
        - 6 표현
        - 5 세션
        - 4 전송
        - 3 네트워크
        - 2 데이터링크
        - 1 물리계층
      - DoD Four-Layer Model 에서의 구분
        - 4 Application
        - 3 Transport
        - 2 Network
        - 1 Access

  - DoD Four-Layer Model 으로 설명하는 것이 조금더 간단하고, 아래 그림을 설명해 보면
    - Access 계층에 ‘네트워크 인터페이스 카드(Network Interface Card)’ 인 ‘NIC’이 있고 그 ‘NIC’인 하드웨어를 움직일 수 있는 Device Driver가 있으며, 그 위에 IP, TCP가 존재하고 맨 위에 Application인 Process가 있다.
    - 네트워크 에서, Application에서 kernel쪽으로 데이터를 보낼때 이것을 추상화하면 File의 형태로 추상화 하는데, 이것을 Socket이라고 한다
    - Socket이란? : TCP, IP Socket 이라고 했을때, TCP를 User 모드 Application Process가 접근 할 수 있도록 File형식으로 추상화한 인터페이스

![image](https://user-images.githubusercontent.com/39178978/209421150-33508b05-4493-4918-95ac-a9e1ebd443ac.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# Port, IP, MAC

  - 각각은 어떤 식별자 인가?
    - MAC주소 : 네트워크 인터페이스 카드(Network Interface Card)’ 인 ‘NIC’ 에 대한 식별자(NIC은 쉽게 LAN카드라고 할 수 있음)
      - 보통 노트북에는 유선 LAN카드와 무선 LAN카드가 있기 때문에 MAC주소가 2개 있다고 생각하면 된다
      - 맥 주소는 변경 가능하다(Virtual MAC)
    - IP주소 : Host에 대한 식별자(Host : 인터넷에 연결된 컴퓨터)
      - IP주소는 NIC하나에 N개를 바인딩 할 수 있음, 즉 컴퓨터는 IP주소가 여러개 될 수 있음
      - IPv4(32비트, 약43억개), IPv6(128비트) 로 2가지가 있다
        - NET기술 때문에 IPv4체계를 아직까지 대부분 사용하면서 인터넷을 쓰고 있다!(인터넷 하나를 쪼개는 공유기의 보급때문에!)
      - IPv4는 8비트씩 4번을 끊는 식으로 관리한다(000,000,000,000)
      - IPv4는 Network ID와 Host ID로 나뉜다.
        - Netmask : IPv4주소에서 Network ID길이가 얼마인지 나타내는 것
        - ex) IPv4주소 : 192.168.60.14이고 Netmask가 255.255.255.0일때 AND연산을 진행(위의 예제 에서는 192.168.60.0 이 Network ID가 된다, 192.168.60.14/24 이렇게 표기 하기도 한다)
    - Port번호 : 프로세스 식별자, 서비스 식별자, 인터페이스번호
      - 16비트 정보(0~65535)
      - Socket을 생성할때 붙는 번호라고 생각하면되고, 인터넷 정보가들와서 TCP수준까지 올라 왔을때 Port번호를 보고 어떤 프로세스로 갈지 결정하게 된다

![image](https://user-images.githubusercontent.com/39178978/209421715-e1f32dcb-5e9b-4843-818e-127289022ba4.png)

![image](https://user-images.githubusercontent.com/39178978/209421721-45a2eec7-c8c3-41ad-8d35-cac96a155712.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# LAN, WAN

  - LAN : MAC주소에 기초해서 작동하는 네트워크(방송주소에 닿는 수준까지)
  - WAN : IP주소에 기초해서 작동하는 네트워크

![image](https://user-images.githubusercontent.com/39178978/209421744-dd724c67-5983-4d81-9006-a07dfac3e6f5.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# Host, Switch, End-point, Network

  - Host : 컴퓨터가 인터넷에 연결되어 있으면 그 컴퓨터를 Host라고 한다
  - Switch :  네트워크 자체를 이루고 있는 컴퓨터(Router, Firewall, IPS 등)
    - Switch의 역할은 Switching이며 Router는 길을 찾기 위해(경로 선택의 근거는 ‘라우팅 테이블’이다), Firewall 과 IPS 를 보안을 위해 작업을 하게 된다
    - MAC주소를 Switching하면 L2스위치, IP를 Switching하면 L3스위치 라는 식으로 불리게 되고, L1~L7로 갈수록 비싸진다
  - End-point : 네트워크를 이용하는 이용 주체(Peer, Server, Client 등)
  - Network : Router(패킷 경로를 찾아 주는 L3 스위치의 일종으로 생각해도 좋다) + DNS의 집합체

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# IP주소 종류

  - Global IP(공인IP) : xxx.xxx.xxx.xxx 32비트
    - 오로지 하나뿐인 IP
  - Private IP(사설IP) : xxx.xxx.xxx.xxx 32비트
    - LAN이라고 일컬을 수 있다.
    - 공유기가 Global IP를 공유해 주기 때문에 사용할 수 있게 된다
    - 각각 클래스 별로 사설 IP주소가 정해져 있다
      - A : 8비트(네트워크) + 24비트(호스트) : 10..
      - B : 16비트(네트워크) + 16비트(호스트) : 172.16..
      - C : 24비트(네트워크) + 8비트(호스트) : 192.168..
  - Loopback
    - 127.0.0.1이며, 호스트 자신을 의미한다
    - Process 1번과 2번이 있을때 목적지 서버 주소를 127.0.0.1로 보내게 되면, IP에서 NIC으로 내려가지 않고, 다시 올라가게 된다

![image](https://user-images.githubusercontent.com/39178978/209421778-b0336755-8313-42cf-aef2-dc3eddf4f0dc.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# DNS

  - 분산형 DB구조를 가지며, 계층구조를 가지고 있다
  - 최 상단에 Root DNS가 13대 존재한다
  - www.naver.com
    - www : 호스트 네임
    - naver.com : 도메인 네임
  - 모든 컴퓨터는 IP주소로 통신하지만 외우기 어렵기 때문에 DNS를 도입하여 외우기 쉬운 문장으로 표현한것
  - 인터넷에서 도메인 네임을 쳤을때 일어나는 일
    - 1. PC메모리의 DNS Cache를 확인
    - 2. Hosts File을 확인(윈도우 에서)
    - 3. Root DNS에게 확인
      - 공유기는 DNS포워딩을 지원하기 때문에 응답을 대리 하기도 한다
      - 공유기가 응답하지 않을경우는, IPS가 제공하는 DNS에게 물어본다
      - Root DNS가 직접 IP주소를 알려주는 것이 아니며, 연관되어 있는 각각의 DNS목록 들을 보내주며 계층적으로 계속 내려가게 된다
        - 응답시에 계속 이런 절차를 가지면 효율이 떨어지기 때문에 응답시에는 유효기간을 같이 보내주게 된다(PC메모리의 DNS Cache)

![image](https://user-images.githubusercontent.com/39178978/209421832-e58ac85f-89c2-46f3-a02d-d8526ec2cb3a.png)

  - Root DNS에 직접 묻기
    - 1 CMD창에서 "nslookup - <Root DNS IP주소>"
    - 2 CMD창에서 찾고 있는 DNS이름 입력 "www.naver.com"
    - 3 Root DNS는 다른 목록들을 보내주게 되고, 다른 목록에게 다시 물어보는 식으로 진행 한다

![image](https://user-images.githubusercontent.com/39178978/209421860-8fed26b7-bf0f-4a78-bdff-5f07ec5d7f8e.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 웹 서비스 구조
  - 1 HTML탄생 -> 문서 뷰어 역할수행(링크 타고 문서이동)
    - 웹클라이언트(웹브라우저) <-> 인터넷 <-> 웹서버
    - 상호간 TCP/IP의 연결 위에서 HTTP통신을 하게 된다.
      - 웹브라우저가 HTTP통신을 통해서 웹서버에 HTML파일을 요청하면 웹서버는 HTML파일을 송부해줌
      - HTML파일을 받은 웹브라우저는 2가지를 수행
        - 1 - Parser가 구분분석을 해서 자료구조를 생성한다(DOM)
        - 2 - 화면에 렌더링을 하게 된다

![image](https://user-images.githubusercontent.com/39178978/209432617-0eff1553-7357-494c-9bda-186c5b344c22.png)

<br/>

  - 2 CSS의 탄생
    - 클라이언트가 서버에 요청하는 방식으로 ‘단방향’방식.
    - HTML : 자료구조, CSS : UI

  - 3 JavaScript, WAS의 탄생
    - 클라이언트, 서버의 양방향 상호작용의 등장
    - 예전에는 웹서버가 모든 송수신을 담당했지만, 웹이 발전하면서 처리하고 연산해주는 것이 하나 별도로 생겨나게 된다(WAS의 등장)
      - 클라이언트가 동적인 입력과, 정보를 보내게 되었을때, HTTP는 상태를 저장할 수 없는 프로토콜 이므로 각자가 데이터를 저장할 수 있는 저장소가 필요하게 됐다.
      - 웹 서버 -> 데이터 베이스에 상태 저장, 웹 브라우저 -> Cookie에 상태 저장.
      - 동적으로 생성된 HTML 송부가능
      - MVC모델 탄생
    - 웹 브라우저에 연산을 할 수 있는 SW을 집어 넣게 되고 그 언어인 JavaScript가 탄생
    - 웹의 3대 요소
      - 1 - 구문 분석을 해주는 Parser
      - 2 - 렌더링을 해주는 엔진
      - 3 - 연산을 해주는 스크립트 엔진

  - 4 WAS
    - WAS는 미들웨어(Middleware)의 일종.
      - 미들웨어(Middleware) : 운영 체제에서 제공하지 않는 서비스와 기능을 어플리케이션에 제공하는 소프트웨어
      - 데이터관리, 메시지, 인증 및 API 등 관리는 주로 미들웨어를 통해 처리된다
    - 일반적으로 프레임 워크로 개발이 이루어지게 되며, JAVA언어로 많이 개발된다(Spring boot)
    - JAVA코드가 아닌 스크립트 언어만으로 해결 할 수 있다.(node.js, PHP 등)

  - 5 웹 서비스의 성능
    - 1 - WAS 연산 속도
    - 2 - DB 응답 속도
      - 속도를 높이기 위해 튜닝을 한다
    - 3 - 클라이언트 -> 웹서버 응답 속도(즉, 네트워크 속도)
    - 1번 2번을 모니터링 하는 것이 APM 이다(ex : 스카우터(Scouter), 제니퍼(JENNIFER) )

  - 6 RESTful API
    - 예전의 웹은 GET, POST방법을 통해서, HTML + CSS + JavaScript + 사진 등등을 직접 받았지만, 지금은 데이터만 날아 오는식으로 발전됐다(XML, JSON)
      - 클라이언트가 데이터만 받아서 HTML을 생성(자신의 OS에 맞는 HTML생성, JavaScript(React.js, Vue.js, Angular 등))
    - 어떤 웹 시스템을 하나의 기능으로 보고, CRUD(생성,읽기,쓰기,삭제)기능을 제공하게 되고, 이때 HTTP기반으로 클라이언트가 URL을 던져서 CRUD(생성,읽기,쓰기,삭제)기능을 함수형태로 CALL하게 되는데 이것을 RESTful API라고 한다.

  - 7 보안
    - 웹 서버 앞단에 보안으로 꼭 들어가는 3가지
      - IPS
      - SSL
      - WAF

![image](https://user-images.githubusercontent.com/39178978/209432772-98891c0d-ca1d-42c8-a4ef-1c2076874846.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# GET, POST
  - 클라이언트와 서버 사이에 이루어지는 요청과 응답 데이터를 전송하는 방식

<br/>

  - GET type
    - localhost:8080/jsp-test/bmi/output.jsp?name=홍길동&birth=19910315
      - localhost = URL/IP 
      - :8080 = WAS port number  
      - /jsp-test = context root 
      - /bmi/output.jsp = web page경로 
      - ? = 웹페이지와 파라미터 구분. 
      - name = 파라미터값의name 
      - 홍길동 = 파라미터의 값.
      - & = 파라미터와 파라미터 구분
    - Select적인 성향을 가지고 있으며, 서버에서 데이터를 가져와서 보여주기만 하는 용도로 사용한다, 서버의 값이나 상태를 바꾸지 않는다(게시판 리스트 보기, 글보기 등)
    - 한번 접근하면 캐싱을 하기 때문에 두번째 접근할때 속도가 빨라진다
  - POST type
    - localhost:8080/jsp-test/bmi/output.jsp
      - localhost = URL/IP 
      - :8080 = WAS port number  
      - /jsp-test = context root 
      - /bmi/output.jsp = web page경로
    - 한글이 깨지게 된다. 한글을 인코딩해줘야 한다
    - 데이터를 가져와서 서버의 값이나 상태를 저장하거나 수정할 수 있다(글쓰기, 글 수정, DB값 수정)

<br/>

  - http의 기본 포트는 80이고, https의 기본 포트는 443이기 때문에 통신을 할때 기본 포트는 생략해도 되며, 기본 포트가 아닌 경우에는 꼭 명시 해줘야 한다

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 네트워크 데이터 단위
  - Socket수준 : Stream
  - TCP수준 : Segment
      - TCP수준에서의 최대 길이를 MSS라고함(MSS가 MTU보다 작다)
      - MSS는 특별한 이유가 없다면 TCP/IP헤더가 각각 20바이트 임으로 -40을 해서 1460이 된다.(하위 수준으로 내려갈때 각각 헤더가 붙게 됨!)
  - IP수준 : Packet
      - IP수준 에서의 최대 길이를 MTU라고 함(기본적으로 1500 바이트)
  - 하드웨어 수준 : Frame

  - User수준인 어플리케이션 process가 추상화한 File에 다가 Stream데이터를 Write하고, kernel수준으로 내려간 Stream데이터가 TCP에서 Segment화 된다. 그것이 인터넷에서 전송 가능한 형태인 Packet으로 캡슐화 후, 실제로 Packet 실어 나를때는 또 캡슐화 하여 Frame이 되어 전송 된다

![image](https://user-images.githubusercontent.com/39178978/209432848-c48ccb71-2e5c-4756-b060-3b9df931e86c.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 패킷의 생성 원리
  - Packet의 생김새
    - Header(IP l TCP)
      - Payload를 실어 나르기 위한 데이터가 들어 있다
      - Header에는 IP(L3), TCP(L4)순으로 Header가 붙어 있게 된다
    - Payload
      - 일반적으로 IP l TCP 가 각각 20바이트로 Header로 붙기 때문에 1460바이트가 된다
      - Payload를 조사하는 것을 DPI라고 한다

  - 프로세스가 소켓에 입출력을 시도 하면 메모리에 저장된 Stream이라는 데이터를 일정한 크기로 자른후, 캡슐화 하여 Packet을 만들고(IP, TCP헤더), 다시 캡슐화 하여 Frame을 만들어 내보낸다

![image](https://user-images.githubusercontent.com/39178978/209432879-5eea2a38-dd77-44f9-b65a-e1573cb1d04a.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# Router의 구조, Inline, Out of path
  - Router(Inline방식)(packet단위를 다룸)
    - 라우터에는 내부로 연결되는 NIC과 외부로 연결되는 NIC이 존재한다
    - 방화벽과 라우터는 둘다 L3스위치에 속하고 IP로 통신한다
      - 방화벽은 보안적인 이유로 Bypass or Drop을 결정
    - 내부적으로 라우터는 Bypass or Drop 인지 결정하고 어디로패킷을 보낼지 지정해줌(이과정을 lnline처리라고 함)
    - Inline구조이며 데이터가 타고 가는 과정은 아래와 같다
    - 아래와 같이 한번 저렇게 H/W -> Kernel -> User 단계를 크로스 하며 갈때 전산 비용이 상당히 발생하게 된다(처리 지연이 발생한다)

![image](https://user-images.githubusercontent.com/39178978/209432901-186e34f1-e2eb-4973-a05d-791be4b1c82a.png)

<br/>

  - 처리 수준의 3가지에 따라 처리 속도가 달라진다
    - Process수준에서 처리한 이후 전송
    - IP수준에서 처리한 이후 전송
    - H/W(NIC)수준에서 처리한 이후 전송
      - H/W단계에서 보내는 것이 가장 빠르고, ‘가속했다’라고 말한다

![image](https://user-images.githubusercontent.com/39178978/209432920-d5941ead-7dad-41a1-b241-d53486f9652f.png)

<br/>

  - Inline방식(packet단위를 다룸)
    - Bypass or Drop중에 하나를 선택 하게 되는 장비
    - Inline형태의 장비가 필터링을 하는 방화벽 역할을 한다면 ‘패킷 필터링 방화벽’이라고 말한다

![image](https://user-images.githubusercontent.com/39178978/209432944-f8bdfd76-256c-4d04-8706-f3239f2b8bee.png)

<br/>

  - Out of path(packet단위를 다룸)
    - 중간에 인터페이스 중의 하나의 선을 따서 장치를 설치하고, 포트 미러링을 시켜서, 그곳을 지나가는 것을 전부 감지한다.
    - 포트 미러링 : 네트워크 스위치의 어떤 한 포트에서 보이는 모든 네트워크 패킷 혹은 전체 VLAN의 모든 패킷들을 다른 모니터링 포트로 복제하는데 사용된다.
    - 감지(Sensor)만 하는 Read only방식이다
    - 포트미러링을 데이터를 전부 copy해서 보내주기 때문에 cpu사용량이 크게 늘게 된다(과부하)
    - 사용용도에 따라서, 장애대응센서 혹은 IDS(침임 탐지 시스템)등이 된다

![image](https://user-images.githubusercontent.com/39178978/209432955-cd6d2982-cd65-4f29-b61d-fcffa967bdbc.png)

<br/>

  - Tap스위치
    - Out of path구조는 부하가 걸리게 하기 때문에, copy만을 전문으로 떠주는 장치
    - 다양한 Out of path의 장치들에게 보내게 된다

![image](https://user-images.githubusercontent.com/39178978/209432967-0f55c843-1c2e-4458-b75b-5ad3e8669d87.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# Proxy
  - Socket Stream데이터를 다룬다!
  - 비슷한 기능을 하는 VPN은 Network수준, Proxy는 HTTP(Web)수준에서 사용한다
  - 어떤 PC1번의 Proxy를 PC2번이라고 설정한다면, PC1의 어떤 서버와 TCP/IP통신 할때
    - 1 - PC1번이 Proxy에 접속
      - PC2번에는 Proxy역할을 해주는 Process(소켓이 2개, 하나는 받고, 하나는 보내고)가 존재 한다는것
    - 2 - Proxy가 PC1번에 원래 접속하려고 했던 곳으로 요청을 보냄
    - 3 - 요청 받은 사이트가 response를 Proxy로 보냄
    - 4 - Proxy가 response를 PC1번으로 보냄

  - 4가지 기능
    - 우회
      - Proxy를 사용하면 접속 사이트는 PC1이 접속한 것이 아니라 PC2가 접속 했다고 생각할것이다
      - 하지만 PC2는 PC1의 모든 통신을 감청을 할 수 있다

![image](https://user-images.githubusercontent.com/39178978/209433140-b044ec6c-60f8-4a24-87da-010cfabf3a49.png)

<br/>

  - 분석
    - wireshark같은 프로그램은 packet을 분석하기 때문에 일반적으로 SSL같은 기술로 payload가 암호화 된다
    - 자기 자신을 분석할 때는 Proxy서버를 로컬로 해놓는 다면 첫번째 프로그램의 Socket단계에서 바로 두번째 프로그램으로 접속한후, TCP단계로 내려가게 된다
      - 암호화는 두번째 프로그램에서 하게 된다!
      - 암호화 되기 전에 볼 수 있다는것!
      - EX) Fiddler

![image](https://user-images.githubusercontent.com/39178978/209433161-32ffc654-8f45-4c20-aed0-084526ec22ee.png)

  - 감시와 보호
    - 모든 PC가 IP번호 3.3.3.100을 가진 PC를 Proxy로 설정한다면 모든PC가 어떤 사이트를 접근할 때 3.3.3.100을 통해 접근 하게 된다. 이때 악성코드가 있던 사이트를 방문 하게 되면 그것이 Proxy로 먼저 가게 된다.(Virus Wall역할)

![image](https://user-images.githubusercontent.com/39178978/209433175-66837719-0648-45c3-a7c0-de136afc7239.png)

  - Reverse
    - Server앞단에 Proxy를 둔다면, 어떤 클라이언트가 Server에 접속하려고 할때 사실은 Proxy IP로 접속하는 것이 된다. Proxy는 그런 클라이언트의 요청을 받아 실제 서버에 접속해 그것을 다시 클라이언트로 보내주게 된다
    - 해커가 해당 web을 공격할때 실제 접속은 앞단에 있는 Proxy에게 하는 것이므로, 그것을 판별해 내는 Proxy를 WAF(웹 방화벽)라고 한다
      - 이러한 Server을 위한 Proxy를 Reverse Proxy라고 한다
      - WAF(웹 방화벽)의 감시 단위 또한 Proxy 이므로 Socket Stream데이터를 감시한다

![image](https://user-images.githubusercontent.com/39178978/209433189-8dad8d01-a12c-4386-866b-f49c96bb4a6f.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# TCP/IP 송수신 원리
  - 서버쪽에서 어떤 파일을 가지고 있고, 클라이언트가 요청했을때 그 파일을 보내주는 상황을 가정
    - 프로그램에 Socket이 열려 있고, 프로그램이 Socket에 파일입출력함(Read : Receive, Write : Send)
      - 1 - 하드 디스크에 있는 File(ex : 1.4MB)
      - 2 - 하드 디스크의 디바이스 드라이버
      - 3 - Socket에 입출력전에, 파일을 입출력하기 위한 메모리를 할당함(Buffered I/O)
        - Memory(Buffered I/O)를 할당할때는 개발자가 결정(ex : 64kb)
        - 용량이 큰 파일을 한번에 불러오는 것이 아니라, 끊어서 불러온다
      - 4 - Socket에 파일을 입출력
      - 5 - TCP(L4)가기전 분해하게 되는데, Buffered I/O에서 TCP(L4)쪽 Window Size에다가 분해한것을 복사(Segment)
        - TCP(L4)쪽 Buffer에 대한 사항은 나중에 검색해보자!!(Window Size)
      - 6 - IP(L3)쪽으로 내려올때, TCP(L4)쪽 Window Size에 있는것을 다시 또 분해(Packet)
        - TCP(L4)쪽에 있는 것을 분해해서 번호를 붙인다음 그중 하나를 캡슐화함(택배 포장 한다고 생각하면 됨)
      - 7 - NIC(L2)쪽으로 내려올때(Frame)
        - IP(L3)쪽에서 내려온것을 다시 캡슐화함(그것을 배송하기 위해, 트럭에 싣는다 고 생각하기)
        - 해당 IP(L3)에 도착하기까지 택배 박스가 택배트럭을 많이 갈아 타게 됨(IP Packet앞에 ethernet Head가 붙게 되며, 한 컴퓨터로 이동시 붙었다 떨어졌다를 반복한다)
      - 8 - 요청된 IP(L3)에 도착(Packet)
        - 역캡슐화가 일어나, Frame은 사라진다(즉, 택배 기사가 택배를 놓고감)
      - 9 - TCP(L4)로 올라감
        - 역캡슐화가 일어나, TCP(L4)쪽 Window Size에 붙게됨(즉, 택배상자가 뜯어져서 내용물이 나옴)
      - 10-1 -데이터를 수신받을 컴퓨터의 TCP(L4) Window Size에 대략 Segment가 2개정도 오면, 잘 수신했다는 것으로 ACK를 보냄(이때 1번 2번 잘 수신했고 3번을 달라고 보내면,        - 자신의 Window Size도 같이 보냄)
      - 10-2 - 데이터를 보낼 컴퓨터는 1번 2번을 보낸후 ACK를 기다리게됨(Wait함)
        - 이것 때문에 속도 지연이 발생함
        - TCP가 UDP보다 느린 이유
        - 이때 ACK로 받은 Window Size에, 3번데이터가 들어갈 자리가 없다면, 보내지 않게 된다(Wait함)

  - 결론
    - 수신측에서, TCP(L4)에서 File Buffer로 퍼올리는 Read속도가 > Ne수신 속도 보다 빨라야 한다(그렇지 않으면 처리 지연 발생)
    - 무조건 네트워크 에서 장애를 찾을 것이 아니라, 프로그램이나 CPU속도, 점유율이 높을경우 이런것이 늦어져서 수신이 늦을 수가 있다.

![image](https://user-images.githubusercontent.com/39178978/209433321-58b7103a-cdb8-4e0b-8e77-cad9c1d0a4d8.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# L2스위치
  - MAC주소 : cmd창에서 -> ‘ipconfig /all’명령어 -> 물리적주소
  - L2스위치는 2종류가 있다
    - L2 Access : Endpoint와 직접 만나는 스위치
    - L2 Distribution : Access스위치와 연결되는 스위치
  - uplink : 상위 계층 스위치로 연결되는 라인
    - Link-up, Link-down과 의미가 전혀 다르니 헷갈리지 말자

![image](https://user-images.githubusercontent.com/39178978/209433490-3b740c70-3128-457e-b67f-48aa8022545d.png)

<br/>

  - 예를 들어 L2스위치로써 16개를 꼽을 수 있는 장치가 있다면 uplink로 하나 연결해야 하니 최대 15개 컴퓨터 연결이 가능하게 된다

![image](https://user-images.githubusercontent.com/39178978/209433508-9507c35f-92d8-48cc-82c1-a396174ac207.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# TCP/IP통신시 MAC주소 변화
  - 통신시, TCP - IP - NIC수준으로 이동하게 되며, IP - NIC수준 이동시 캡슐화가 된다
    - IP Packet앞에 ethernet Head가 붙게 된다
  - L2통신시에는 IP주소는 보지 않고, MAC주소만 보기때문에 L2통신에 MAC주소는 중요하다.
  - 각 라우터는 Packet 수신자의 IP와 목적지 IP를 보고, 가장 빠른 길로 갈 수 있는 다음 라우터의 MAC주소만 바꿔서 간다고 생각할 수 있다

![image](https://user-images.githubusercontent.com/39178978/209433549-6c47eb61-a8cb-400d-a46f-728d6f9f4f0f.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# L2스위치 작동원리, ARP
  - ARP : IP주소로 MAC주소를알아내는 프로토콜
  - Broadcast를 쏴서 찾고 있는 IP를 가진 컴퓨터가 응답을 Unicast로 하게 된다
  - 그러한 ARP를 조작하는 것을 ARP Spoofing이라고 한다

![image](https://user-images.githubusercontent.com/39178978/209433578-bd159143-9ac8-4f16-b6f9-d818aef04a12.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# TTL
  - TTL(Time To Live) : Hop을 하나 지나갈때마다 TTL을 하나 줄이게 된다. 0이 되면 Packet이 사라지게 된다
    - 라우터에 Looping이 발생했을때, 라우터의 cpu점유율이 뛰고 망가질 수 있기 때문에 TTL이 0이 되면 없어지게 된다.
    - TTL이 0이되었던 라우터에서 ICMP를 보내주게 된다(보안 때문에 설정해 놓지 않았다면 보내지 않는다)
  - Hop : 라우터와 라우터 사이의 간극

![image](https://user-images.githubusercontent.com/39178978/209433602-164a8df7-406a-4e88-9ad9-601d0d2a195a.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 3 way handshake
  - 주고 받는 단위 :  Segment
  - Server는 Client의 Seq번호를 받고, 응답해줌
    - MSS사이즈 및 정책을 교환한다
    - 가장 작은 MSS로 하향 평준화 하여 맞춘다
    - 정책 : 혼잡제어
      - 네트워크가 문제가 있어서 수신이 안되거나, 데이터를 받지 못하는 상황
  - 3 way handshake을 한다는것
    - Seq교환, MSS교환, 정책 교환
    - 보안이 전혀 되어 있지 않다

![image](https://user-images.githubusercontent.com/39178978/209433642-03d0d76c-a5be-4aad-98d9-706d279b2393.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# MTU, Packet 단편화
  - Packet이 단편화가 일어나면, 잘려진 뒤쪽에도 IP해더를 복사해서 붙이게 되며, Offset값을 붙여서 어느 지점에서 잘렸는지 알 수 있게 한다
  - 수신받는 측에서 보통 단편화된 것들을 조립하게 된다
  - 현재는 거의 발생하지 않지만, VPN때문에 간혹 발생하게 된다
  - 단편화가 나지 않도록 하향평준화 시키면 된다

![image](https://user-images.githubusercontent.com/39178978/209433664-5262225f-bed6-4c62-99e9-7e27ca98653f.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# Unicast, Broadcast, Multicast
  - Unicast : 내부 네트워크 망 안에서 통신 하는것(PC1 과 PC24가 통신)
  - Broadcast : Broadcast주소는 HOST주소가 2진수로 전부다 1일때를 가리킨다
    - PC1이 Broadcast 주소로 전달을 하게 되면, 내부 네트워크 안에 있는 모든 IP에 전달 되게 된다.
      - IP : XXX.XXX.XXX.255
      - MAC : FF FF FF FF FF FF
    - Broadcast를 하게 되면, 그 순간은 어느 IP에서도 신호를 쏠 수 없게 된다. 네트워크 효율을 떨어 뜨리며, 최소화를 해야 한다.

![image](https://user-images.githubusercontent.com/39178978/209433702-52260eb2-8bc0-4925-b056-d992c62937aa.png)

<br/>

  - Multicast : 한 IP에서, 특정한 여러 IP로 지정해서 보내고 싶을때
    - 어떤 등록된 IP는 신호를 받고 사용하게 되지만, 등록되지 않은 IP가 받았을 경우, 받자 마자 무시를 하게 된다
      - 즉, L2수준에서는 Broadcast처리가 되기 때문에, 효율을 떨어뜨리게 됨으로 ‘SDN’이 등장하게 됨

![image](https://user-images.githubusercontent.com/39178978/209433744-a45b1c34-2541-40eb-bd8b-ecb7501a8b50.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 서브넷팅
  - 사설IP를 더욱 나누어서 쓰기 위해서 사용함
  - 서브넷 마스크 bit수를 1증가시키면, Network ID값이 1bit증가되고 Host ID를 나타내는 bit가 1 줄어들게 된다
  - https://code-lab1.tistory.com/34

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 공유기 작동원리
  - NAT-Table을 참고해서 작동 된다
    - 1 - 최초의 Packet을 보고, 송신, 수신 에 대한 IP, Port를 적어 놓는다
    - 2 - Port번호를 변경시켜서 수신된 곳에 보낸다
      - 이때는 공유기 IP와, 공유기가 바꾼 Port번호로 가게 된다
    - 3 - 수신된 곳에서 Response를 보내서, 공유기가 수신 받는다
    - 4 - Packet을 열어서, IP, Port를확인하고, NAT-Table을 참고해서 처음 수신했던 PC로 Response보낸다
  - 공유기 안쪽의 사설IP에 있는 다른 PC 2대가, 외부에 있는 사이트에 접속했을 때, 사이트는 같은 IP인 공유기가 2번 접속 했다고 생각하게 된다
  - F/W기능을 수행한다
    - 내부에 있는 PC에서 송신할때 NAT-Table에 그것들을 보관 하고 나중에 참고해서 보내주기 때문에, 해커가 접속하게 됐을 때, NAT-Table에 존재하지 않기에 자동으로 F/W기능을 하게 된다

![image](https://user-images.githubusercontent.com/39178978/209433787-ba919305-b58d-4184-840b-ef56d5c69959.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 부하분산(Load Balancer)
  - 공유기와 같은 원리로 작동된다, 서버에 골고루 접속시킬 수 있도록 작동
  - 보통2대를 사용하게 된다
    - 1대만 쓰게 된다면, 1개가 고장나면 큰일이 나기 때문

![image](https://user-images.githubusercontent.com/39178978/209433803-0a1edd9f-1a4a-439d-9c15-c63b08cf117d.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# VPN작동원리(L3, IPSec)
  - 내부망 안에 있는 Server는 내부에서만 접근이 가능한데, 외부에서 접근하기 위해 VPN을 사용하여 ‘터널링’한다.
  - 라우터나, 보안장치가 전부 VPN을 지원해야 한다(SG = SecureGate를 지원해야 한다)
  - VPN프로그램을 설치 해야 한다
  - 내부망 IP주소를 외부로 하나 할당하게 된다
  - 순서
    - 1 - VPN 프로그램을 깔면, Virtual NIC Driver가 생김
    - 2 - 그곳에 내부망 IP를 할당한다
    - 3 - Virtual 로 만들어진 IP를 탄후, 본래의 IP를 타고 가게 된다
      - IP, TCP 헤더가 2개씩 붙게 된다
      - 헤더가 하나더 붙기 때문에 MTU 1500을 초과하게 되어 단편화가 발생되니, Payload를 기본적으로 1460보다 더 작게 만들어 헤더가 하나더 붙었을때 초과 되지 않게 만든다
    - 4 - 공유기가 그 IP를 받게 되고, 그것을 디캡슐화 시킨다

![image](https://user-images.githubusercontent.com/39178978/209433861-7cd9c8ee-d239-4185-a296-03a020ae46a0.png)

<br/>

![image](https://user-images.githubusercontent.com/39178978/209433865-3919c937-5db1-4d58-9f22-d5d5c92a1ca7.png)

<br/>

![image](https://user-images.githubusercontent.com/39178978/209433873-d3215dfa-4e57-4c0a-a48a-071dfc2aa89a.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 네트워크 보안 종류
   - 1 - L1~L3 : NAC(Network Access Control) + Probe + IP관리 시스템
      - IP주소(Packet), MAC주소(Frame) 을 봄
      - 네트워크에 아무나 접근 못하게 하는것
        - 1 - L2 Port(Interface)를 다운시켜서 통신을 못하게함
        - 2 - HTTP 통신을 리다이렉트(Redirect)시킨다
        - 3 - DHCP통제(주소를 자동으로 할당 받지 못하게 만들어서 인터넷 못하게함)
        - 4 - ARP Spoofing
          - 네트워크의 장애원인중의 하나게 될 수 있으니 유의하기
   - 2 - L1~L2(무선에서만) : WIPS
      - MAC주소(Frame) 을 봄
      - 몰래 무선 네트워크를 쓰지 못하도록 차단

![image](https://user-images.githubusercontent.com/39178978/209434051-1a383ac2-0db2-47fd-8e27-f0393f6a82ea.png)

<br/>

  - 3 - L3~L4 : FW(Packet filter), Screening Router
    - Port주소(Segment), IP주소(Packet) 을 봄
    - F/W의 동작 방식 : Stateful Inspection
      - TCP에서 연결을 할때, 연결을 전이하는 과정중에서 순서가 정상적인지, 정상적이지 않은지 확인한다.
  - 4 - L5~ : WAF(웹 어플리케이션 방화벽 -> Proxy형태로 되어 있음)

  - 5 - L3~L4 : VPN(IPSec)
    - 망 수준에서의 보안을 제공함 -> Gage to Gage, Gage to End Point
      - 터널링을 통해서 망 접속을 제공해줌
  - 6 - L5~ : SSL VPN(Proxy형태로 되어 있음)

  - 7 - 망분리, 망연계

  - 3번, 4번을 합쳐서 Hybrid FW이라고함
  - 3번, 4번, 5을 합쳐서 UTM(Unified Threat Management, 통합 위협 관리) 라고 한다
    - 하나에 기능이 다 들어가 있기 때문에 성능이 떨어 질 수 밖에 없으면, 기본적으로 중,소 기업에서 사용하게 된다

  - 1~7번까지는 네트워크 보안 인프라에 해당함
    - 수동적인 성향이 있음
    - 보안 ‘정책’이 중요함
      - 설치, 설정

![image](https://user-images.githubusercontent.com/39178978/209434145-42647182-e038-4c4d-b47a-154e1de91685.png)

<br/>

  - 수동적인 보안의 한계로, 능동적인 보안 솔루션이 등장
    - ‘Rule’이 중요함

  - 1 - L3~ : IDS, IPS (네트워크 침입 탐지 시스템)
    - IDS, IPS 하는 일은 같지만 설치 구조가 다름(DPI를 함)
    - NIDS : Out of path구조
    - IPS  : Inline구조

  - 2 - Sandbox
    - 악성코드를 집어 넣어서, 어떤 반응을 일으키는지 확인한다

  - 3 - MPS(8번, 9번을 합친 솔루션)

  - 8번, 9번, 10번 같은 솔루션은 클라우드와 연계되어 ‘평판 시스템’을 갖는다

  - 4 - 많은 데이터로 인해, 통합으로 관리해야할 필요가 생김
    - 엔터프라이즈 서비스 관리(ESM)가 생김

  - 5 - 수많은 로그가 쌓임에 따라 그것을 분석하고 대처할 SIME(보안 정보 및 이벤트 관리)도 생기게됨
    - 분석을 AI(인공지능)으로 진행하는 경우가 많아짐

![image](https://user-images.githubusercontent.com/39178978/209434191-098a4286-e83b-4ced-879d-8780a973788d.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# wireshark(패킷 분석 프로그램)
  - Outbound : 데이터가 나가는것
  - Inbound : 데이터가 들어오는것
  - Filter는 Bypass(, Drop을 시킬 수 있으며, Sensor(항상 Bypass)는 그러한 것은 없고 감시(수집)만 한다
 
  - 인터넷에서 데이터가 들어올때, kernel단계인 IP의 단계 전에, 필터 및 센서 프로그램을 설치 할 수 있어서, Inbound , Outbound  된 패킷을 확인 할 수 있다.

  - wireshark
    - 설치하면 Sensor가 설치가 된다(Npcap)

![image](https://user-images.githubusercontent.com/39178978/209434291-a00a78ca-1240-4934-bc2e-d60d0e15ea1b.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

***

# 운영체제
  - [32비트와 64비트](#32비트와-64비트)
  - [기억 장치의 종류](#기억-장치의-종류)
  - [HDD의 논리적 구조와 SSD](#hdd의-논리적-구조와-ssd)
  - [API, Kernel, System Call, Interrupt](#api-kernel-system-call-interrupt)
  - [DMA(Direct Memory Access)](#dmadirect-memory-access)
  - [CPU와GPU](#cpu와gpu)
  - [Virtual Memory](#virtual-memory)
  - [Process와 Thread](#process와-thread)
  - [Process간 통신 IPC](#process간-통신-ipc)
  - [메모리관리](#메모리관리)

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# 32비트와 64비트
  - CPU가 처리하는 데이터의 최소 단위인 레지스터의 크기가 몇 바이트 인지 나타내는것
  - 데이터를 처리할때 CPU에서 처리하게 되는데, 매번 데이터를 가져오면 시간이 걸리니 저장하게 된다
  - 레지스터의 용량이 클 수록 메모리에서 더 많은 데이터를 가져와 저장하기 때문에 속도가 빨라진다
  - 32비트 = 2의 32승 = 4,294,967,296개의 숫자를 표현 가능하며, 4,294,967,296개의 메모리 주소를 저장할 수 있다(메모리 주소는 1바이트 단위 이므로 4,294,967,296바이트 메모리 주소를 저장 가능)(4,294,967,296바이트 = 4GB)

  8bit = 1Byte

  1024Byte = 1MB

  1024MB = 1KB

  1025KB = 1GB

  - 32비트 레지스터는 램에서 한번에 표현할 수 있는 메모리가 4GB가 된다(하지만 실제 레지스터는 작동중에, 일부가 메모리 주소 외에 다른 임시 값을 저장하는데 사용되기 때문에 실제 한계는 더 적어진다)
  - 64비트 레지스터는 32비트 레지스터보다 엄청나게 더 많은 메모리 주소를 저장 가능하지만, 현재는 64비트 전체를 다 쓰지는 않는 다고 한다.

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# 기억 장치의 종류

![image](https://user-images.githubusercontent.com/39178978/214212250-33440444-d5f1-4cf2-8c14-ea3581ca4a36.png)

  - 출처 : https://www.youtube.com/watch?v=LMwVUzJQSdU&list=PLXvgR_grOs1BQCziQ_MpM877BdBxwbMzA&index=8 

<br/>

  - Cache memory : CPU에서 연산을 하기 위해서 데이터들을 Register까지 불러와야 하는데, Register와 RAM간의 속도 차이 때문에 중간에 있는 Cache memory가 그 간극을 메꿔주게 된다.

  - 기억공간의 관리
    - 레지스터 : 개별 기억공간마다 고유 이름을 붙인다
    - 주 기억장치(RAM) : 일련번호를 붙인다
    - 보조기억장치 : 트랙과 섹터 번호를 붙여 관리한다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# HDD의 논리적 구조와 SSD

![image](https://user-images.githubusercontent.com/39178978/214212383-6363c427-92e5-4c0b-bc83-8c934572a939.png)

  - 포맷 : HDD는 데이터를 트랙과 섹터로 나누어 관리하고 있는데, 그러한 트랙과 섹터를 집어 넣는 작업을 포맷이라고 하며, 그렇기 때문에 저장되어진 정보는 전부 지워지게 된다
  - 조각모음 : HDD에 데이터가 저장될때, 연속적으로 저장되어지지 않았을때, 그러한 정보들을 연속적으로 배치하기 위한 작업(연속적으로 되어 있지 않다면 데이터를 사용하는 데 있어서 시간이 더 걸린다)
  - 파일복구 : 파일을 완전히 지웠다고 해도, HDD상에서는, 덮어 쓸 수 있는 상태의 위치가 될뿐, 아직 그곳에 데이터를 덮어 쓰지 않았다면 그것을 찾아가서 파일을 복구 하는것
  - HDD와 SSD의 차이
    - 하드디스크는 내부에 있는 디스크가 돌면서 원시적으로 읽어내기 때문에, 물리적인 속도의 한계가 있지만 SSD는 플래시 메모리를 이용하여 논리적인 구조로 이루어져 있기 때문에 속도가 굉장히 빠르다
    - SSD가 충격에 훨씬 안전하다
    - SSD가 훨씬 가볍다
    - SSD는 배드블록이 발생한다(수명이 존재 하며, 하나의 블록에 쓰고, 지웠다를 반복하면 그 블록을 쓸 수 없게 된다)

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# API, Kernel, System Call, Interrupt
  - 컴퓨터는 3가지의 구조로 나눌 수 있다
    - 피지컬
      - H/W(하드웨어 영역)
    - 로지컬(= Virtual)
      - Kernel(운영체제 영역)
      - User(유저 영역)
  - 운영체제는 커널 영역에서 유저 레벨을 도와주고, 하드웨어 영역을 관리한다
  - 메모리나, 장치에 접근하기 위해서는 User모드가 아닌 Kernel모드가 되었을때 접근이 가능하며, Kernel모드로 모드변경을 하기 위해서는 OS의 System Call을 호출하여 변경해야 한다
  - Interrupt
    - 컴퓨터는 다른 주변기기와 통신(입출력)을 할때 Interrupt가 발생한다
      - 컴퓨터 기기들은 저마다의 고유한  Interrupt를 가지고 있어서 컴퓨터가 처리해주어야 할 일이 자신에게 발생했을때 운영체제에게 IRQ(Interrupt Request)를 보내어 컴퓨터를 사용하게 된다. 
      - blocking IO
        - Interrupt가 발생하면 프로세스가 잠시 멈췄다가, Interrupt가 끝나면 다시 진행한다
      - non-blocking IO
        - Interrupt가 발생해도 프로세스가 멈추지 않는다.
    - I/O과정은 기본적으로 이렇게 되기 때문에, 커널모드에 함수가 실행되는 것과,  인터럽트 발생 때문에 속도가 잘 나오지 않는다.
      - 1. 유저모드에서 함수 실행
      - 2. 커널모드에서 함수 실행
      - 3. RAM 메모리에 올라감
      - 4. 비디오 하드웨어 에게 전송(인터럽트)
      - 5. 모니터에게 전송(인터럽트)
    - 주변기기를 고성능을 사면, 비동기가 되기 때문에 속도가 빨라진다
    - DirectX : 유저 레벨에서 커널 쪽 단계를 스킵하고, 유저 레벨에서 비디오 드라이버에 바로 액세스할 수 있도록 한 기술. 이를 통해 고성능 게임을 구동하는 것

<br/>

![image](https://user-images.githubusercontent.com/39178978/214212779-5289a666-8670-46e4-bb7c-6c8708db52ea.png)

<br/>

  - System Call / Library Call 
    - System Call은 결국, 어디선가가, 하드웨어와 메모리에 접근하기 위해서 커널 함수를 실행한다고 생각하면 되지 않을까?
    - stdio.h와 같은 헤더 안에 System Call과 Library Call이 있으며, System Call은 OS의 Kernel에 서비스를 요청할 때에 호출하는 함수를 말한다.
    - Library Call도 결국은 System Call을 wrapping한 것이기 때문에, 결국 System Call을 호출하게 된다.
    - System Call을 너무많이 호출하면 시스템 성능에 영향을 주기 때문에, Library Call은 System Call을 적게 호출하면서, 개발을 쉽게 할 수 있도록 기능을 효과적으로 제공해준다
  - System Call 호출 과정
    - ex) stdio.h 헤더 안에 있는 printf를 사용했을시, 내부적으로 System Call을 출력할 수 있는 부분이 있으며, 그로 인해 어떤 System Call을 출력할지 컴파일러가 number을 세팅하게 됨 -> printf는 내부적으로 write을 사용하게 되고 이것은 sys_write System Call을 사용함 -> write가 call number 7번이다 라고 컴파일러가 결정하는것
    - 커널과 컴파일러와 서로 합의된 규칙하에 적용이 된다. 즉, 사용할 커널 함수 number는 컴파일러를 쓰는 회사가 결정하는 것이며, 그 컴파일러를 쓰는 회사와 커널과의 호환이 되어야 한다. 따라서 OS가 다르면 System Call 번호에 해당하는 함수들이 다르기 때문에 컴파일러는 OS별로 다르게 해석해주어야 한다.
  - API
    - stdio.h
      - C언어에서 사용하는 표준 입출력 API함수
      - 내부적으로 OS의 System Call을 이용하여 Kernel의 도움을 받아서 장치를 사용하게 된다(ex. printf는 내부적으로 System Call을 호출하여 terminal에 출력한다)
    - Win32API
      - 윈도우 운영체제에서 사용하는 C언어 기반의 API(C++에서도 사용 가능). 윈도우에서 실행되는 모든 종류의 어플리케이션은 내부적으로 WinAPI함수를 호출 하는 형태가 된다
      - windows.h인클루드 하여 사용
        - 다양한 함수와, 모든 데이터 타입, 윈도우 API의 함수들을 사용하기 위한 정의 들이 들어 있다(C 및 C++헤더 파일)
        - win32프로그램에는 인클루드가 되어 있음
        - mfc에는 내부적으로 다른 방법으로 인클루드가 되어 있음
      - 윈도우 운영체제를 설치 할때, 안에 내장되어 있는 함수들이라고 보면 되고, 그 함수들이 있기에, 장치 독립적으로 같은 함수를 호출함으로써 같은 기능을 쓸 수 있게 된다.
      - WinAPI가 없던 때에는, 장치를 사용할때, 각각의 장치에 대한 제어 코드를 하나하나 만지면서, 장치마다 설명서를 보고 해야 했지만, 지금은 제어 코드를 디바이스 드라이버가 가져가게 되었고, 윈도우가 제공해 주는 api함수를 사용함으로써 쉽게 장치 기능을 쓸 수 있게 됐다.
      - 정적 라이브러리 형태가 아닌 DLL(동적 라이브러리)형태로 제공되기 때문에, 윈도우 버전이 올라가면서, 윈도우 DLL이 개선되면, 프로그램 기능도 개선되기도 하지만, 호환성에 문제가 생기기도 한다
      - 윈도우에서 System Call 라이브러리는 ntdll.dll이고, Win32API도 내부적으로 ntdll.dll함수를 호출한다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# DMA(Direct Memory Access)
  - CPU와 Device장치의 통신
    - 1. CPU에서 RAM메모리의 일정 부분을 할당에 데이터 복사
    - 2. RAM내부에서 RAM내부로 데이터 복사
    - 3. RAM에서 Device로 데이터를 보낼때 Device RAM으로 데이터 복사
    - Process 가 데이터를 송신할 때
      - 1. File (Socket) 에 send (write)
      - 2. 소켓에 딸려있는 I/O Buffer에 차곡차곡 복사됨
      - 3. 커널 영역의 TCP/IP 레이어에 내려오면서 Segmentation 발생
      - 4. 커널의 버퍼들에 데이터가 복사됨
      - 5. 커널의 드라이버를 통해 NIC에 전달
        - 5-1 만약 NIC에도 RAM이 있다면 이곳에 한번더 들어가 복사되어 이동된다
      - 6. 외부로 이동
      - 그런데 프로세스 영역의 메모리와, 소켓의 메모리와, 커널의 메모리와는 모두 RAM 의 어딘가 이기 때문에 비효율적이다.
    - 이러한 과정이 굉장히 비효율적이기 때문에 DMA가 등장
  - DMA : CPU 에서 일정 유저 RAM영역을 OS가 Lock을 걸고  다이렉트로 Device RAM 영역에 데이터를 복사시키거나, 데이터를 Device RAM 으로 부터 받는다
    - 윈도우의 IOCP가 이러한 원리를 활용한 것이다
  - 가상환경(VM) : 기존 유저 영역을 유저/커널 영역으로 간주하고, 커널 영역을 H/W 로 간주하는 Guest OS 를 만드는 것
    - 두 VM이 데이터를 주고받을 때 (실제론 커널 영역에 있는) NIC 두 개를 통해서 양쪽 유저 영역이 데이터를 주고 받는게 아니라, "했다 치고" 실제론 메모리 영역에 데이터를 copy 해버린다. 이렇게 해서 성능을 끌어올릴 수 있다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# CPU와GPU
  - CPU의 코어는 그렇게 많지 않지만, 복잡한 고차원적인 연산이 가능하다
  - GPU의 코어는 몇천개 단위로 많고, 단순한 반복작업을 하는데에 최적화되어 있다
    - 그래픽의 벡터 연산 : 3D그래픽은 많은 폴리곤으로 이루어져 있으며, 폴리곤이 세밀할수록 표면을 보다 매끄럽게 표현할 수 있으며, 폴리곤이 세밀할수록 연산해야 되는 좌표가 많아진다 그렇기 때문에 그래픽 작업은 기본적으로 단순한 ‘좌표 계산’이라고 표현된다
    - 딥러닝, 머신러닝, 빅데이터 : 수천만 개의 학습 데이터를 이용해 연산을 수없이 반복하여 데이터로부터 특징을 추출, 즉 매우 반복적인 알고리즘 계산

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# Virtual Memory
  - 1차 메모리(RAM), 2차 메모리(HDD의 Swap영역)를 합쳐서 하나의 연속된 메모리로 추상화 한것
    - OS는 Virtual Memory를 Process에게 할당한다
    - User어플리케이션은 그냥 RAM을 쓴다고 하지만 그것은 가상 메모리가 될것이고, 그것은 1차,2차 메모리를 합쳐서 연속된 메모리를 추상화한것을 사용하게 된다
  - 32bit기준 으로 설명하는 Virtual Memory
    - 한 Process의 Virtual Memory안에서 User, kernel에서 사용하는 메모리로 나누어서 쓰게 된다. User에서 앞부분은 OS가 차지 하게 되기 때문에 그 영역은 사용하지 못하게 된다
  - 관리
    - User모드에서 Process의 Virtual Memory를 관리하는 단위는 Page가 된다
    - H/W에서 물리 Memory를 관리하는 단위는 Segment가 된다
    - 매핑 테이블을 통해 각 Process가 사용하고 있는 Page나 Segment의 위치를 매핑 하고 있다.
      - 보통, 가상 주의의 단위인 Page와 물리 주소의 단위인 Segment의 길이를 똑같이 맞추고, 테이블을 통해서 매핑 하여 관리하게 된다
      - Process가 오작동 해서, 종료가 됐을 때 매핑 테이블을 확인해서 그 메모리를 사용하지 않고 있다고만해서 메모리를 깔끔하게 다 수거할 수 있다.
      - 관리적인 의미로 아주 뛰어나게 된다.
      - OS가 접근 권한(rwx)을 확인 할때 테이블을 확인하고, 그것이 읽기만 되는지 쓰기만 되는지, 실행만 되는지 확인해서 작업을 하게 된다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# Process와 Thread
  - Process에 속한 모든 Thread는 Process의 Virtual Memory로 메모리 공간이 제약 된다

  - PCB(Process Control Block), TCB(Thread Control Block)
    - PCB
      - OS의 스케줄러가 스케줄링 해줌
      - OS의 스케줄러에 의해 Context Switching되는 프로세스의 정보 단위
      - CPU의 Core몇개로 몇천개가 되는 Process를 돌리는데, 그것을 시분할 사용하고 있지만, 너무 빠르게 하고 있기 때문에 사람의 눈에는 동시 실행 되는 것처럼 보인다
      - 어떤 Process가 타임 아웃이 되었을때 그 상태를 PCB에 저장해 두었다가 디스패치가 되면 이어서 작업하게 된다
    - TCB
      - 프로세스에 있는 Thread라이브러리에 의해 스케줄링 됨
      - Thread라이브러리에의해 Context Switching되는 Thread의 정보 단위
  - Thread 는 Queue구조에서 무언가를 퍼와서 작업하게 된다!!

개발 툴 추천 : MS사의 프로세스 탐색기

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# Process간 통신 IPC
  - Process별로 할당된 Virtual Memory는 OS가 보장해 주고 있으며, 서로간에 메모리를 침범할 수 없다. 따라서, IPC방법을 통해서, 어떤 Process에 공유 메모리를 할당해서 그것을 어떤 Process도 접근할 수 있도록 한다
  - Process가 사용하는 자원
    - RAM(=고정길이) + File(2차 메모리)(=Stream, 길이 제한 없음)

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# 메모리관리
  - 많은 프로세스가 RAM을 사용하려고 하지만, RAM은 제한적 이기 때문에, CPU가 판단하여 연산이 많이 필요 없는 Process를 Page단위로 하여 2차 메모리로 보내거나 하는 식으로 관리하게 된다
    - Swap In : HDD -> RAM
    - Swap Out : RAM -> HDD

###### [운영체제](#운영체제)
###### [Top](#top)
