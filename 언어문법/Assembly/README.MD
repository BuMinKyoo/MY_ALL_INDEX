<br/>

###### Top

- [컴퓨터 구조](#컴퓨터-구조)
  - [ALU(산술 논리 장치)](#alu산술-논리-장치)
  - [폰 노이만 구조](#폰-노이만-구조)
  - [CPU 명령어 사이클(instruction cycle)](#cpu-명령어-사이클instruction-cycle)
  - [명령어 집합(instruction set)](#명령어-집합instruction-set)
  - [6502 Assembly](#6502-assembly)
  - [명령어 집합 구조(ISA)](#명령어-집합-구조isa)
  - [일반적인 ISA의 명령어 분류](#일반적인-isa의-명령어-분류)
- [기계어 프로그래밍](#기계어-프로그래밍)
  - [6502CPU](#6502cpu)
  - [폰노이만 구조와 프로그램 실행](#폰노이만-구조와-프로그램-실행)
  - [임베디드 시스템과 프로그램 실행](#임베디드-시스템과-프로그램-실행)
  - [65C02의 핀 구성](#65C02의-핀-구성)
  - [조립하기](#조립하기)
  - [ROM](#rom)
  - [프로그램 작성하기](#프로그램-작성하기)
  - [타이밍 다이어그램](#타이밍-다이어그램)
  - [ROM과 RAM의 분리](#rom과-ram의-분리)
- [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
  - [기계어 대신 어셈블리 언어를 사용하는 이유](#기계어-대신-어셈블리-언어를-사용하는-이유)
  - [고수준 대신에 어셈블리 언어를 사용하는 이유](#고수준-대신에-어셈블리-언어를-사용하는-이유)
  - [어셈블리어](#어셈블리어)
  - [dasm](#dasm)
  - [어셈블러와 최적화](#어셈블러와-최적화)
  - [6502명령어의 구성](#6502명령어의-구성)
  - [A주소지정 모드(2사이클)와 6502의 파이프라인](#A주소지정-모드2사이클와-6502의-파이프라인)
  - [A모드 명령어 사이클(상세)](#a모드-명령어-사이클상세)
  - [#모드, 즉시(immedidate)모드(2사이클)](#모드-즉시immedidate모드2사이클)
  - [a모드 : 절대주소(4사이클)](#a모드--절대주소4사이클)
  - [6502의 메모리 페이지](#6502의-메모리-페이지)
  - [zp모드 : 제로 페이지 모드](#zp모드--제로-페이지-모드)
  - [주소지정 모드 종류](#주소지정-모드-종류)
  - [연산자](#연산자)
  - [변수와 상수](#변수와-상수)
  - [스택](#스택)
  - [상수 - 매직넘버, 상수형 변수](#상수---매직넘버-상수형-변수)
  - [데이터 블록](#데이터-블록)
  - [라벨](#라벨)
  - [레지스터(6502)](#레지스터6502)
  - [묵시적 명령어 몇개 소개](#묵시적-명령어-몇개-소개)
  - [프로그램 종료](#프로그램-종료)
- [6502어셈블리 니모닉 정리](#6502어셈블리-니모닉-정리)
- [6502어셈블리 플래그 정리](#6502어셈블리-플래그-정리)
- [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
  - [adc : 받아올림을 이용한 덧셈(C, V플래그)](#adc-받아올림을-이용한-덧셈c-v플래그)
  - [sbc : 받아내림을 이용한 뺄셈](#sbc--받아내림을-이용한-뺄셈)
  - [증감 연산](#증감-연산)
  - [색인 주소지정 모드](#색인-주소지정-모드)
  - [페이지 크로싱](#페이지-크로싱)
  - [비트 이동/회전 연산](#비트-이동회전-연산)
  - [논리 연산, NOT연산구현,6502에 없는 연산들..](#논리-연산-not연산구현6502에-없는-연산들)
  - [CPU에 데이터 형은 없다 해석은 남의 몫](#cpu에-데이터-형은-없다-해석은-남의-몫)
  - [단항 바이트 연산자](#단항-바이트-연산자)
- [조건문](#조건문)
  - [cmp, jmp, beq, bne, bcc, bcs](#cmp-jmp-beq-bne-bcc-bcs)
  - [bmi, bpl, bvc, bvs](#bmi-bpl-bvc-bvs)
  - [조건문 작성](#조건문-작성)
  - [상대 주소지정 모드](#상대-주소지정-모드)
  - [기타if문 관련](#기타if문-관련)
- [반복문](#반복문)
- [배열](#배열)
  - [일반 예제](#일반-예제)
  - [실행 중에 코드 변경하기](#실행-중에-코드-변경하기)
  - [다차원 배열](#다차원-배열)
- [지시문](#지시문)
- [6502함수](#6502함수)
  - [간접 참조(indirection)](#간접-참조indirection)
  - [지역라벨](#지역라벨)
  - [함수 사용시, 인자 전달 방법](#함수-사용시-인자-전달-방법)
  - [함수에 매개변수가 여럿 있는 경우는?](#함수에-매개변수가-여럿-있는-경우는)
  - [스택 원상 복구 방법](#스택-원상-복구-방법)
  - [함수의 반환값](#함수의-반환값)
  - [정리 : 근래 고수준 언어의 함수 호출 방법](#정리--근래-고수준-언어의-함수-호출-방법)
  - [함수 호출에 드는 비용](#함수-호출에-드는-비용)
  - [바이트크기, 유지보수성, 성능](#바이트크기-유지보수성-성능)
  - [매크로 함수](#매크로-함수)
  - [6502의 간접 참조 주소지정 모드](#6502의-간접-참조-주소지정-모드)
  - [배열의 배열](#배열의-배열)
  - [함수 오버로딩, 기본값 인자, 함수 포인터](#함수-오버로딩-기본값-인자-함수-포인터)
- [매크로](#매크로)
  - [매크로예시](#매크로예시)
  - [.IF, .ELSE, .ENDIF](#if-else-endif)
  - [.IFCONST, .IFNCONST](#ifconst-ifnconst)
  - [.REPEAT](#repeat)
  - [.INCLUDE](#include)
  - [null 포인터](#null-포인터)
- [6502주변기기 연결](#6502주변기기-연결)
- [X86-16 _ intel 8088](#x8616--intel-8088)
  - [x86-16개발환경](#x8616개발환경)
  - [MS-DOS의 부팅 순서](#msdos의-부팅-순서)
  - [여러 프로그램 실행의 문제](#여러-프로그램-실행의-문제)
  - [정리 : 프로그래머 관점에서 운영체제란?](#정리--프로그래머-관점에서-운영체제란)
  - [컴파일 환경 세팅 하기](#컴파일-환경-세팅-하기)
  - [Hello, x86! 출력하기](#hello-x86-출력하기)
  - [변수 및 초기화](#변수-및-초기화)
  - [8088의 레지스터](#8088의-레지스터)
  - [피연산자 종류](#피연산자-종류)
- [x86-16 니모닉 소개](#x8616-니모닉-소개)
  - [데이터 전송 니모닉](#데이터-전송-니모닉)
  - [데이터 크기 변환 니모닉](#데이터-크기-변환-니모닉)
  - [포인터 로드 니모닉](#포인터-로드-니모닉)
  - [스택 사용 니모닉](#스택-사용-니모닉)
  - [포트 입출력 니모닉](#포트-입출력-니모닉)
  - [덧셈 니모닉](#덧셈-니모닉)
  - [뺄셈 니모닉](#뺄셈-니모닉)
  - [곱셈 니모닉](#곱셈-니모닉)
  - [나눗셈 니모닉](#나눗셈-니모닉)
  - [논리 연산 니모닉](#논리-연산-니모닉)
  - [비트 이동/회전 니모닉](#비트-이동회전-니모닉)
  - [제어 니모닉](#제어-니모닉)
  - [반복문 니모닉](#반복문-니모닉)
  - [문자열 니모닉](#문자열-니모닉)
  - [기타 니모닉](#기타-니모닉)
- [콘솔 입 출력](#콘솔-입-출력)
  - [외부장치 입출력](#외부장치-입출력)
  - [인터럽트](#인터럽트)
  - [콘솔 입력](#콘솔-입력)
- [x86-16함수](#x8616함수)
  - [x86-16의 함수 호출](#x8616의-함수-호출)
  - [cdecl 호출 규약](#cdecl-호출-규약)
  - [near/far함수 호출](#nearfar함수-호출)
  - [함수 호출 종류](#함수-호출-종류)
- [구조체, 레코드](#구조체-레코드)
  - [구조체](#구조체)
  - [레코드](#레코드)
- [메모리 세그먼테이션](#메모리-세그먼테이션)
- [FPU 프로그래밍](#fpu-프로그래밍)
  - [8088과 부동 소수점](#8088과-부동-소수점)
  - [일반적인 8087 사용법](#일반적인-8087-사용법)
  - [8087의 레지스터](#8087의-레지스터)
  - [8087의 데이터형](#8087의-데이터형)
  - [8087 니모닉](#8087-니모닉)
  - [8087 명령어](#8087-명령어)
  - [8087 데이터 전송](#8087-데이터-전송)
  - [8087 조건문](#8087-조건문)
  - [x87 코프로세서의 발전](#x87-코프로세서의-발전)
- [x-86-32](#x8632)
  - [IA-32 CPU](#ia32-cpu)
  - [IA-32의 레지스터](#ia32의-레지스터)
- [인라인 어셈블리](#인라인-어셈블리)
  - [인라인 어셈블리 사용 예시](#인라인-어셈블리-사용-예시)
  - [다양한호출규약](#다양한호출규약)
  - [정적 라이브러리, 동적 라이브러리](#정적-라이브러리-동적-라이브러리)
- [SIMD프로그래밍](#simd프로그래밍)
- [x86-64](#x8664)
- [어셈블리어 개인 정리](#어셈블리어-개인-정리)

<br/>
<br/>

***

# 컴퓨터 구조
  - 현대 CPU의 컴퓨터는 추상화를 함으로써 점차 만들어 졌다.
    - Transistors를 모아서 Logic Gates를 만들고, 그것을 보아서 가산기, 곱셈기를 만드는 것처럼, 제일 작은 단위를 모아 추상화를 하여 다른 장치를 만들어내고 있으며, Programming Languages또한 정말 많은 추상화를 통해서 만들어진 하나의 장치인 셈이다
    - Transistors는 가장 작은 단위인 셈이고, 그것을 몇개 모아서 Logic Gates를만든다
    - Logic Gates는 AND, OR, NOT과 같은 것을 의미하게 된다
    - Logic Gates는 아래와 같다
    - AND인지 OR인지, NOT인지 Transistors를 여럿 이용해서 만들고, A를 누를때 불이 들어올지, B를 눌렀을때 불이 들어올지, 둘다 눌렀을때 불이 들어올지는 게이트의 연산에 따라 달라지게 된다
    - Transistors -> Logic Gates -> 가산기, 곱셈기 -> ALU순으로 추상화 했다 할 수 있음

![20231004_084831](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/600b9f56-edf6-423e-916d-a5def3e4f398)

![20231004_084845](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/11a0b0be-145b-43e6-b55a-d4ce7ed23e79)

  - [ALU(산술 논리 장치)](#alu산술-논리-장치)
  - [폰 노이만 구조](#폰-노이만-구조)
  - [CPU 명령어 사이클(instruction cycle)](#cpu-명령어-사이클instruction-cycle)
  - [명령어 집합(instruction set)](#명령어-집합instruction-set)
  - [6502 Assembly](#6502-assembly)
  - [명령어 집합 구조(ISA)](#명령어-집합-구조isa)
  - [일반적인 ISA의 명령어 분류](#일반적인-isa의-명령어-분류)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# ALU(산술 논리 장치)
  - 이진수 정수의 산술 연산과 비트 연산을 담당하는 장치
  - 수많은 논리 게이트로 구성되어 있음
    - Integer Operand가 A,B로 들어갈때 더 이상 1비트가 아닌, 여러 비트의 조합인 이진수를 넣을 수 있음(더 이상 Transistors같은 아주 작은 단위를 보지 않게 됨) 수많은 Transistors의 조합으로 만들어져 있기 때문에
  - ALU의 입출력 값은 레지스터를 이용
  - ALU에 들어가는 입력값의 비트에 따라서 CPU가 몇 비트인지 이야기 할 수 있다
  - 두 이진수를 넣으면 연산 결과가 나옴
  - 실행할 연산 : opcode
    - 멀티플렉서의 선택 신호로 사용됨
  - 즉, 세 입력 신호가 필요
    - 피연산자 * 2
    - 연산 선택
  - opcode코드를 이용해서 곱셉인지 덧셈인지 등등 명령어를 준다고 할 수있고 이에 따라서, A 와 B에 있는 수많은 Logic Gates가 선택적 작동하게 된다
    - CPU안에 있는 제어장치(control unit)이, 언제 어떤 입력 신호를 넣어줄지 알게 제어해 준다(A 와 B에 어떤것 넣어 줄지, opcode에 어떤걸 넣어 줄지…)

![20231004_085126](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/1e193eac-a979-4bc9-942a-2eff254627b3)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 폰 노이만 구조
  - 모든 현대 컴퓨터는 지금도 폰 노이만 구조를 따르고 있다
  - 폰 노이만 구조의 세 구성 요소
    - 메모리 : 데이터와 명령어를 저장
    - CPU : 명령어를 decode및 실행
    - 입/출력 장치
  - 중앙 처리 장치
    - 처리장치
      - 산술/논리 장치 : ALU
      - 프로세서 레지스터
    - 제어장치(control unit) : 어떤 명령어를 이해하고 실행하게 해준다
      - 명령 레지스터(IR, Instruction Register)
      - 프로그램 카운터(PC, Program Counter) : 다음에 실행할 명령어의 위치 주소값을 가지고 있는곳


![20231004_085609](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f08f5bee-2310-4912-b4fe-239cd30d7ef3)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# CPU 명령어 사이클(instruction cycle)
  - CPU가 메모리에 저장된 기계어 하나를 실행할 때 거치는 과정들
    - 1. fetch :  명령어를 가져옴
    - 2. decode : (명령코드) opcode와 (피연산자)operand로 디코딩
      - Control Unit이 해줌
    - 3. execute : 산술/논리/분기 연산 등을 실행
      - ALU가 해줌
    - 4. write back : 연산 결과를 저장

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 명령어 집합(instruction set)
  - 어떤 기계가 지원하는 명령어들
  - 각 명령어는 명령 코드(opcode)와 피연산자(operand)로 구성
    - 메모리에는 이진수로 적혀 있음
  - 제어 장치는 메모리에 저장돼 있는 이진수를 순서대로 디코딩
    - opcode로부터 실행할 연산을 알아냄(=opcode와 비트 패턴의 매핑 관계)
    - 그 연산에 사용할 피연산자도 알아냄
    - 그 연산을 실행할 수 있는 장치에 필요한 입력값을 모두 전달

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 6502 Assembly
  - High nibble + Low nibble을 하면 하나의 16진수가 되고, 어떤 명령어를 실행할지 찾을 수 있다.
    - ex) 0110 1001(0x69) = ADC#
  - https://en.wikibooks.org/wiki/6502_Assembly 

![20231004_120327](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/42a15e3e-a7d5-470c-b440-b3d05a8c81f4)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 명령어 집합 구조(ISA)
  - 어떤 특정한 하드웨어의 규약!!!(다른 하드웨어는 다르게 만들어 질 수 있음!!)
  - 명령어 집합
  - 여러 CPU가 동일한 ISA를 지원할 수 있음
    - CPU마다 다른 이진 명령어를 만들지 않아도 됨
    - AMD와 intel CPU가 호환되는 이유
  - ISA가 정의하는 것들의 예
    - 기계어의 동작
    - 지원하는 데이터형
    - 레지스터
    - 메모리 모델 등
  - 어떠한 어셈블리어로 코딩을 한다는 것은, 어떤 모델에 맞는 ISA라는 명령어 집합을 정해서, 코딩을 한다는 것과 같다
    - 따라서, 애플사의 m1 cpu와 intel사의 isa의 집합이 다르다는것!!
  - Assembly 보다 추상화된 고수준의 코딩 언어를 컴파일러가 해석해, ISA수준까지 변환을 해준다

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 일반적인 ISA의 명령어 분류
  - 산술 연산(대부분)
  - 논리 연산
  - 메모리 관련(읽기, 저장, 이동 등)
  - 흐름 제어(분기 등)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

***

# 기계어 프로그래밍
  - [6502CPU](#6502cpu)
  - [폰노이만 구조와 프로그램 실행](#폰노이만-구조와-프로그램-실행)
  - [임베디드 시스템과 프로그램 실행](#임베디드-시스템과-프로그램-실행)
  - [65C02의 핀 구성](#65C02의-핀-구성)
  - [조립하기](#조립하기)
  - [ROM](#rom)
  - [프로그램 작성하기](#프로그램-작성하기)
  - [타이밍 다이어그램](#타이밍-다이어그램)
  - [ROM과 RAM의 분리](#rom과-ram의-분리)

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 6502CPU
  - 6502CPU
    - MOS 6502 프로세서
      - 1975년에 출시된 NMOS 기반 8비트 마이크로프로세서
      - 기존 8비트 CPU에 비해 단순한 설계로, 속도가 빠르고 가격이 저렴
      - 개인 컴퓨터의 부흥을 가져옴
      - cpu에서 하드웨어를 직접 제어
        - 운영체제 : 없음
        - BIOS : 없음
        - 부트로더 : 없음
    - WDC 65C02와 임베디드 시스템
      - 1981년 Western Design Center사에서 개발
      - MOS 6502와 후방 호환
        - NMOS 대신 CMOS를 사용
        - 전력 소비를 10~20배 줄임
      - 임베디드 시스템에서 매우 많이 쓰임
      - 데이터 너비 : 8비트
        - 한번에 8비트 단위로 데이터를 읽어 올 수 있다는 의미
      - 레지스터 수 : 6개
      - 명령어 수 : 56개

![20231004_172643](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/cabf8fec-cebd-4895-836e-0943899c7194)


![20231004_172655](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/c2819188-ae20-409c-a43d-863716495f39)


###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 폰노이만 구조와 프로그램 실행
  - 프로그램은 외부장치에 저장되어 있음
  - 따라서 cpu에게 프로그램이 저장된 위치를 알려줘야 한다
  - 데스크톱 컴퓨터에서는 보통 운영체제가 이런일을 해준다
    - 1. 운영체제로 컴퓨터가 부팅
    - 2. 사용자가 원하는 프로그램을 선택
    - 3. OS가 실행 권한을 그 프로그램에게 넘겨줌
  - 니모닉을 통해, 바이트를 하나하나 읽고 옵코드를 확인하고, fetch하고 실행하는 과정을 가진다

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 임베디드 시스템과 프로그램 실행
  - 보통 전원을 켜면 곧바로 프로그램 실행
  - 6502에서 흔히 사용하는 방법
    - 1. cpu리셋될 때 특정 메모리 주소에 저장된 값을 읽어옴
    - 2. 그 값이 가리키는 주소로 점프
    - 3. 그 주소에 저장된 명령어가 실행됨
    - 전원을 켜면, 운영체제를 실행하는것이 아니라, 내가 만든 프로그램을 곧바로 실행한다는것이 다르다.

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 65C02의 핀 구성
  - 각 핀들의 의미는 해당하는 CPU의 ‘datasheet’를 통해 아래와 같이 확인할 수 있다
    - 데이터핀 : 8비트(26번~33번)
    - 주소핀 : 16비트(9번~20번, 22번~25번)
    - VDD : 전원 전압의 +극 : 전원을 연결하는 곳
    - VSS : 접지(ground)

![20231004_173057](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/fff6459d-850d-467b-ae90-b1c486f8a7e4)

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 조립하기
  - 1. 브레드보드 준비(빵판)
    - 전도체를 꽂을 수 있는 구멍이 있음
    - 전기가 통하는 거라면 뭐든 꼽기 가능
    - 동일한 전류가 흐르는 영역이 존재
      - 터미널 띠(5개의 공간중 하나만 꼽아도 전기가 흐른다)

![20231004_173213](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/b5aa5deb-1b23-4ac9-b95e-6fdff8aa3751)

  - 각각 줄들의 값을 같게 하고 싶다면, 연결해 주면 된다

![20231004_173222](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/0ea79245-c0c9-4891-a6a4-21ef02798349)

![20231004_173233](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/8c60b7ab-d34b-4c52-a9a0-8ee30e27f295)

  - 버스띠
    - 전원을 연결해 주기 위해 존재

![20231004_173241](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/75b90b87-a818-44da-8e52-e32269ab8f30)

![20231004_173248](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/ebb2d282-b6a1-40ba-bec4-bec3a0f0451e)

  - 2. cpu설치 및 vdd, vss연결하기(전원연결)

![20231004_173255](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/822766fe-6f7e-40cd-b6a6-96938047c00d)

  - 3. 클럭 및 기타 선 연결하기
  - 4.기타 high핀을 연결
  - 5. cpu리셋 스위치 추가하기
  - 6. 클럭속도 늦추기
  - 7. 스파이더 연결하기
  - 기타 등등의 과정이 밑에 더 있음
  - 영상을 참고하면서 기억나지 않을때 다시 따라 해보기

![20231004_173302](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/7ab07d5e-989f-4549-8209-b93dbcc7a5a3)

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# ROM
  - 원칙상 한 번 쓰면 다시 수정 못하는 메모리
  - 요즘은 여러 번 쓸 수 있는 ROM을 주로 사용
    - EPROM, EEPROM
    - 그래도 실행 중에는 쓸 수 없게 하는 게 보통
    - 별도 하드웨어를 통해서만 쓸 수 있게 함

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 프로그램 작성하기
  - 6502CPU의 리셋백터는 0xFFFC, 0xFFFD이므로, 이곳에 프로그램 시작 주소를 적어야 한다

#test.c
~~~c
#include <stdio.h>
#include <string.h>
#include <assert.h>

#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable: 4996)
#define SIZE (0x8000)

int main()
{
	const char* FILENAME = "program.bin";

	FILE* outfile;
	char bin_out[SIZE] = { 0 };
	size_t program_size;

	const char program[] = {
		0x18,  // CLC
		0xA9, 0x0A, // LDA #$0A
		0x69, 0x06,  // ADC #$06
		0x8D, 0x00, 0x22  // STA $2200
	};

	program_size = sizeof(program) / sizeof(char);

	assert(program_size < 0x7FFC);

	memcpy(bin_out, program, program_size);

	bin_out[0x7FFC] = 0x00;
	bin_out[0x7FFD] = 0x80;

	outfile = fopen(FILENAME, "wb");

	if (outfile == NULL)
	{
		fprintf(stderr, "cannot open outfile");

		return -1;
	}

	fwrite(bin_out, sizeof(char), SIZE, outfile);

	fclose(outfile);

	return 0;
}
~~~

![20231004_173708](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f20edbe7-8278-4f41-96b9-4e007d4e0d7c)

  - FFFC와 FFFD는 리셋 백터 이기 때문에 여기서 8000주소로 점프하게 된다

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 타이밍 다이어그램
  - CPU가 RAM보다 속도가 빠르기 때문에, 서로간의 1사이클 동안에 어떤 EmptyButton시간에 어떻게 작동 되는지나와 있으며, 각자의 유효한 시간안에 정확하게 데이터를 교환하기 위함

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# ROM과 RAM의 분리
  - 코드와 데이터를 별도의 메모리에 담는 것 좋은 생각
  - 실행 중에 코드가 저장된 메모리를 덮어쓸 수 있으면 위험
    - 내가 작성한 코드의 동작을 남이 변경할 수 있음
    - 버퍼 오버 프로를 이용한 해킹이 그러한것
  - 따라서 아예 하드웨어 수준에서 방지하는게 최선책
    - 코드가 들어가 있는 메모리는 쓰기 금지
  - 하지만 최근 PC에는 ROM이 따로 없음
    - RAM에 모든 걸 집어넣되 다른 방법으로 막으려고 함
    - 예 : C언어의 코드 세그먼트와 데이터 세그먼트의 분리

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

***

# 6502 어셈블리 기초 문법
  - [기계어 대신 어셈블리 언어를 사용하는 이유](#기계어-대신-어셈블리-언어를-사용하는-이유)
  - [고수준 대신에 어셈블리 언어를 사용하는 이유](#고수준-대신에-어셈블리-언어를-사용하는-이유)
  - [어셈블리어](#어셈블리어)
  - [dasm](#dasm)
  - [어셈블러와 최적화](#어셈블러와-최적화)
  - [6502명령어의 구성](#6502명령어의-구성)
  - [A주소지정 모드(2사이클)와 6502의 파이프라인](#A주소지정-모드2사이클와-6502의-파이프라인)
  - [A모드 명령어 사이클(상세)](#a모드-명령어-사이클상세)
  - [#모드, 즉시(immedidate)모드(2사이클)](#모드-즉시immedidate모드2사이클)
  - [a모드 : 절대주소(4사이클)](#a모드--절대주소4사이클)
  - [6502의 메모리 페이지](#6502의-메모리-페이지)
  - [zp모드 : 제로 페이지 모드](#zp모드--제로-페이지-모드)
  - [주소지정 모드 종류](#주소지정-모드-종류)
  - [연산자](#연산자)
  - [변수와 상수](#변수와-상수)
  - [스택](#스택)
  - [상수 - 매직넘버, 상수형 변수](#상수---매직넘버-상수형-변수)
  - [데이터 블록](#데이터-블록)
  - [라벨](#라벨)
  - [레지스터(6502)](#레지스터6502)
  - [묵시적 명령어 몇개 소개](#묵시적-명령어-몇개-소개)
  - [프로그램 종료](#프로그램-종료)

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 기계어 대신 어셈블리 언어를 사용하는 이유
  - 기계어의 모든 장점을 가지고 있음
  - opcode를 읽기 편함
  - 바이트로 표현된 opcode보다 적은 opcode만 암기하면 됨
  	- 인자에 따라 주소지정 모드가 결정되기 때문
  - 프로그래머의 실수를 막을 수 있는 기능들이 있음
  	- “변수명”
  	- 라벨
  	- 매크로
  	- 등 등

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 고수준 대신에 어셈블리 언어를 사용하는 이유
  - 일반적으로 없음
  - 하지만 예외적인 상황들이 있음
  	- 일부 코드를 어셈블리어로 작성해 컴파일러보다 최적화를 더 잘하고 싶음
  	- 컴파일러가 지원 안 하는 하드웨어 기능을 사용하고 싶음
  	- 코드가 오작동하는 이유가 컴파일러 버그 때문이란 걸 확인하고 싶음
  	- 컴파일러 버그를 우회하고 싶음
  	- 고수준으로 작성한 언어가 실제 어떻게 동작하는지 확인하고 싶음
  	- 커스텀 하드웨어에서 간단한 제어 프로그램을 작성하고 싶음

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 어셈블리어
  - 언매니지드
  - 저수준
  - 컴파일 언어(정확히 말하면, 컴파일 언어라고 할 수는 없음
  	- 고수준의 언어를 어셈블하는 과정을 컴파일이라고 할 수 있음
  - 강타입, 약타입언어로 나뉠수 없음
  - 명령형 프로그래밍
  - 어셈블러
  	- 어셈블리어를 기계어 형태의 오브젝트 코드로 해석해 주는 컴퓨터 언어 번역 프로그램
  	- dasm, vasm 등
  - 따라서 고수준언어를 저수준 언어인 어셈블리어를 만들기 위해 컴파일을 하고 그 어셈블리어를 어셈블하여 기계어를 만든다

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# dasm
  - 1. dasm설치하기 https://dasm-assembler.github.io/

![20231005_084916](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/0fe1bd0d-4c6d-4dea-8ec3-a4187d9ffed0)

  - 2. 압축풀기
  - 3. exe가 있는 곳의 폴더 위치를 확인하고 환경 변수에 등록하기

![20231005_084928](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/2fd0e19e-95da-48f2-97ab-f91633ab37f7)

![20231005_084940](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/df6f7a20-ca0c-4797-9026-0f455bdfec68)

![20231005_084953](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f7c82f2a-f530-4791-be0c-168de1fe6db6)

  - 4. add.asm파일 만들고, cmd를 그곳에서 명령 실행하기
  - 5. 명령어

#add.asm
~~~c
dasm add.asm -f3 -oadd.bin
// dasm을 실행하고, add.asm은 내가 만든 파일, -f3은 컴파일 옵션, -o는 어떤 파일을 아웃풋으로 낼껀지, add.bin파일을 아웃풋으로 내겠다는뜻
~~~

<br/>

#add.asm
~~~c
// 코드를 쓸때 TAB을 해준다
// 다양한 ISA를 어셈블 할 수 있기 때문에 맨 위에 어떤 ISA를 사용하는 CPU 프로세서를 명시해준다(ex. .PROCESSOR 6502)
	.PROCESSOR 6502 
// ROM시작 주소를 언급해준다(ex. .ORG $8000)
	.ORG $8000 

	clc
	lda #$04
	adc #$06
	sta $2200

// 리셋 벡터를 적어 준다(ex. ORG $FFFC)
// ORG $FFFC 아래에 있는 것들이 FFFC에서부터 시작 된다는 것을 알려줌
// 6502 CPU는 리셋 벡터가 FFFC, FFFD로 시작한다(CPU가 강제하는 상황이기 때문에 무조건)
// FFFC : 1111 1111 1111 1100
// FFFD : 1111 1111 1111 1101
	.ORG $FFFC,0 

// WORD는 2바이트를 의미
// 리틀 엔디안 이기 때문에 실제 메모리에는 0080으로 들어가게 된다
	.WORD $8000
	.WORD $0000
~~~

  - 6.성공!!

![20231005_090233](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/a21c5921-c92b-4515-a24d-90720f4f1dfb)

  - 7. 주의점
  	- 실행할때 powerShell에서 하면 명령어 작동이 되지 않았음..참고! 

#a.asm
~~~c
	.PROCESSOR 6502
	.ORG $1000

	clc
	lda $C000
	adc $C001
	adc $C002
	adc $C003
	sta $1000

	.ORG $2000, 0
	.BYTE $00, $01, $02, $03
	.BYTE "Hello World"
	.BYTE  0 ; 널 문자
	.WORD $1000, $1001

	.ORG $FFFC,0
	.WORD $8000
	.WORD $0000
~~~

  - 바로 위의 코드를 다시 설명해 보면, ROM시작 주소가 1000이기 때문에
  - ORG $2000, 0은 1000부터 기록이 되고
  - ORG $FFFC, 0은 EFFFC,0부터 기록이 된다

#a.asm
~~~c
	.PROCESSOR 6502
	.ORG $8000

	clc
	lda $C000   -> 여기는 0부터 기록이 됨 여기부터 실행되고 C0000에 있는 것을 가져와서 실행하게 됨
	adc $C001
	adc $C002
	adc $C003
	sta $1000

	.ORG $C000, 0   -> 4000부터 기록이 됨
	.BYTE $00, $01, $02, $03
	.BYTE "Hello World"
	.BYTE  0 ; 널 문자
	.WORD $1000, $1001

	.ORG $FFFC,0
	.WORD $8000
	.WORD $0000
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 어셈블러와 최적화
  - 컴파일러는 보통 최적화를 해줌
  	- 고수준 언어와 최종 하드웨어 ISA의 차이가 큼
  	- 따라서 컴파일러가 최종 하드웨어에 적합한 어셈블리 코드를 만들어 줌
  	- 좋은 컴파일러를 돈 내고라도 쓰는 이유
  - 어셈블러는 최적화를 거의 안 해 줌
  	- 있어도 그냥 명령어 하나에 대한 최적화 정도
  	- 여러 줄을 합쳐서 최적화를 해주진 않음
  	- 좋은 어셈블러는 프로그래머에게 유용한 기능들을 지원
  		- 지시문, 매크로 등
  		- 최종 바이너리는 달라지지 않음

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 6502명령어의 구성

![20231005_091121](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/082269d2-9144-493b-86c1-8a46b8e60a82)

  - 어셈블리어 구문
  	- 명령어
  	- 지시문
  	- 매크로
  - 어셈블리어 명령어 구조
  	- 명령어 = 니모닉 + 피연산자
  	- 니모닉(언제나 1개)
  		- 기계어에서 언제나 1바이트를 차지한다
  	- 피연산자(0~2개)
  		- 기계어에서 0~2바이트
  		- 피연산자 앞에 $ 이면 주소이고, #이면 상수이다, 주소일 경우에는 주소가 16비트인 경우가 있어서 하나만으로 2바이트를 차지한다
  			- 즉, 8비트 또는 16비트 피연산자 하나가 바이트 1~2를 차지한다
  			- 나머지 피연산자는 opcode로 들어감(피연산자는 2바이트 인데, 하나가 2바이트를 차지 하니, 나머지 하나는 이렇게 된다고함..!)
  			- 심지어 opcode하나로 모든 피연산자를 표현하는 경우도 있음

#test.asm
~~~c
// lda 로 니모닉이 전부 같은데 , A9, A5, AD와 같이 opcode가 다르게 나오게 된다
// 구문에 있는 니모닉과 피연산자에 따라 opcode가 결정됨

// char a = 0x0A
// a레지스터에 0A라는 상수를 넣어라
lda #$0A  // 상수로 사용해라        ; A9 0A

// char* p = (char*)0x0A
// a = *p
// 0A라는 주소로 가서 거기에 있는 데이터를 a레지스터에 넣어라
lda $0A  //  8진수 짜리 주소           ; A5 0A

// char* p = (char*)0xCB0A
// a = *p;
// 0A라는 주소로 가서 거기에 있는 데이터를 a레지스터에 넣어라(위에 것과 같다, 단지 2바이트 주소일뿐!)
lda $CB0A // 16진수 짜리 주소    ; AD 0A CB
~~~

  - 니모닉 + 주소지정 모드(addressing mode) = opcode
  - 주소지정 모드
  	- CPU설계에서 ISA의 한 측면
  	- 명령어가 피연산자를 찾는 방법을 정의
  	- 6502의 주소지정 모드는 총 13개
  	- 어셈블리 코드의 피연산자에 따라 주소지정 모드를 알 수 있음
  	- 주소지정 모드에 따라 opcode 바이트를 알 수 있음
  	- 아래에는 4개만 소개하도록 함
  	  - A모드 : 누산기
  	  - #모드 : 즉시
  	  - a모드 : 절대주소
  	  - zp모드 : 제로 페이지 주소


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# A주소지정 모드(2사이클)와 6502의 파이프라인
  - 피연산자로 A레지스터를 사용한다는 암묵적 동의
  	- 코드에서 피연산자를 별도로 표기하지 않음
  - 가장 효율적인 주소지정 모드
  	- 바이트 : 1바이트
  	- 실행 사이클 : 가장 적음
  - 명령어 사이클
  	- 중요한 것은, 사이클을 진행하면서, 순차적으로 명령어를 한개씩 처리하는것이 아니라, 각 단계에 한개씩 넣어서 처리 한다고 생각해야 하며, 각 단계에 동시에 처리할 수 있는 연산은 cpu마다 차이가 있게된다
  	- 6502같은 경우는, 동시에 2가지 연산을 처리하게 된다
  		- 이것을 CPU파이프라인이라고 한다
  			- CPU의 명령어 처리 속도를 향상하는 하드웨어 설계
  			- 단일 코어가 둘 이상의 명령어를 동시에 실행할 수 있게 해 줌(명령어 수준 병렬성)

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# A모드 명령어 사이클(상세)

#a.asm
~~~c
lda #$FF  ; A9 FF
asl       ; 0A
lsr       ; 4A  lsr : 논리적 우측 비트 이동
ror       ; 6A  ror : 우측 비트 회전
rol       ; 2A  rol : 좌측 비트 회전
~~~

  - 아래 부분에서는 lda #$FF  ; A9 FF 은 A모드가 아니기때문에 건너 뛰고 아래 부터 설명하도록 한다

![20231005_091653](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/62b20047-3bc1-4a0b-880f-13405c664af9)

  - 1.0A인 asl을 읽어옴(Fetch)
  - 2.0A가 어떤 모드인지 확인(Decode), 4A를 읽어옴(Fetch)
  - 3.0A가 asl인지 다른것인지 확인 할 수 있게 되고 실행(Execute), 0A였다면 asl이고 추가로 피연산자를 받아 오지 않는 것을 알기 때문에 현재 Fetch된 것을 버린다(4A),  하지만 방금 버렸던 것을 다시 Fetch해오면서 Decode를 하기 위한 준비를 한다.(4A)
  	- 이후에는 Fetch된 것을 Decode하게 되며, 다음것을 Fetch해온다. 그렇다면 처음에는 3사이클로 Execute를 하는게 맞지만, 그 다음부터는 2사이클 만에 Execute를 하게 된다

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# #모드, 즉시(immedidate)모드(2사이클)

#a.asm
~~~c
lda #$0A
adc #$06
sbc #$01
and #$F0
~~~

  - 1. lda 를 읽어옴(Fetch)
  - 2. lda가 어떤 모드인지 확인(Decode), 0A를 읽어옴(Fetch)
  - 3. 현재 Fetch에 있는 0A가 사용해야할 피연사자인것을 확인하고 실행(Execute), 다음 것인 adc를 읽어옴(Fetch)
  	- 이후에는 Fetch된 것을 Decode하게 되며, 다음것을 Fetch해온다. 그렇다면 처음에는 3사이클로 Execute를 하는게 맞지만, 그 다음부터는 2사이클 만에 Execute를 하게 된다

  - 니모닉 바로 옆에 적힌 숫자를 값으로 그대로 사용
  	- 데이터 레지스터가 8비트니 당연히 8비트
  	- 따라서 명령어는 총 2바이트(니모닉 + 8비트 숫자)
  - C언어에서 매직 넘버 상수를 사용하는 것과 비슷
  - CPU최적화가 있었다면 다른 곳에서 읽어오는 것보다 빠르다
  	- 메모리캐시 및 파이프라인
  - 즉시 모드는 상수를 이용함으로써 빠르다
  	- 즉시모드
  		- 1. 연산자 읽음
  		- 1. 2. 피연산자 읽음
  		- 1. 3. 연산에 사용함
  	- 절대 주소 모드
  		- 1. 1. 연산자 읽음
  		- 1. 2. 피연산자(주소)를 읽음
  		- 1. 3. 그 주소에서 다른 값을 읽어 옴
  		- 1. 4. 그 값을 연산에 사용

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# a모드 : 절대주소(4사이클)

#a.asm
~~~c
lda $825B
adc $CB0A ; 6D
sta $2000 ; 
~~~

  - 1. lda 를 읽어옴(Fetch)
  - 2. lda가 어떤 모드인지 확인(Decode), 0A를 읽어옴(Fetch)
  - 3. 피연산자가 2바이트 이니, CB도 읽어옴
  - 4. 해당 주소로 가서 data를 얻음

  - 피연산자는 전체 메모리 범위에서 특정된 한 주소
  	- 전체 메모리 범위 : [0x0000, 0xFFFF]
  - 그 주소에 저장되어 있는 값을 가져와 사용
  	- C에서의 포인터
  	- Java/C# 등에서의 인스턴스
  - 포인터 연산의 단점
  	- 주소를 한 번 거치면 연산이 확 느려짐
  		- ADC는2 -> 4싸이클
  		- 여러 번 거치면 그에 비례해 느려짐
  	- 따라서 포인터 연산이 적을수록 성능에 유리
  	- 하지만 변수를 어딘가에 저장해야 함
  		- 최고의 장소는 CPU레지스터
  		- 6502에서 ALU에 적합한 레지스터는 하나밖에 없음

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 6502의 메모리 페이지
  - 1바이트로 표현 가능한 주소 범위는 [0x00, 0xFF]
  - 이 범위를 페이지(page)라고 부름
  - 6502에는 256장이 존재
  - 첫 번째 페이지를 제로 페이지라고 부름

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# zp모드 : 제로 페이지 모드

#a.asm
~~~c
lda $5B
adc $0A
sta $00
~~~

  - 6502 CPU에서 레지스터가 부족하기 때문에 2바이트 피연산자를 읽어오기 위해서 1사이클 더 많은 작업이 필요하기 때문에 이것을 페이지화 해서, 2바이트 주소를 가진 피연산자를 한번의 작업으로 읽어오기 위해서 나오게 되었다.
  - 절대 모드와의 차이점
  	- 니모닉 옆 피연산자가 1바이트 주소(0x00~0xFF)
  	- 실제 메모리 상의 주소 범위는 [0x0000, 0x00FF] 임
  	- 주소 fetch에 1사이클만 사용
  - 그 외 동작은 절대 모드와 동일
  - 6502의 메모리 페이지 레이아웃
  	- 6502에서 강제하는 메모리 페이지는 딱 두 장
  		- page 0 :  제로 페이지 주소지정 모드에 사용
  		- page 1 : 프로세서 스택 메모리
  	- page 2 ~ 255는 설계자 마음대로 사용가능
  		- ROM공간
  		- RAM공간
  		- 화면에 보여줄 픽셀 배열
  		- 디스크 I/O버퍼 등

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 주소지정 모드 종류
  - A : 누산기, A레지스터
  - # : 즉시
  - a : 절대 주소
  - zp : 제로 페이지 주소
  - i : 묵시적
  - r : 상대주소
  - (a) : 절대 간접 주소
  - a, x : 절대 주소 + x
  - a, y : 절대 주소 + y
  - zp, x : 제로 페이지 주소 + x
  - zp, y : 제로 페이지 주소 + y
  - (zp, x) : 색인 후 간접 참조
  - (zp), y : 간접 참조 후 색인

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 연산자
  - 아주 간단한 덧셈조차도 adc와 같은 니모닉을 사용하기 때문에 연산자는 존재하지 않음
  - 니모닉을 함수라고 생각하여도 됨
  - 하지만 어셈블리를 기계어로 바꿔주는 어셈블러는 연산자를 지원하기도 함
  	- 실행중에 동작하는 연산자가 아님
  	- 어셈블 과정 중에 평가해서 최종 결과만 코드로 삽입
  	- 프로그래머를 위해 어셈블러가 지원하는 기능
  		- 주로 가독성을 위해
  		- 일반적으로 산술/논리 연산자를 모두 지원
  - 어셈블리어는 연산자 우선순위가 없음(위에서 한줄씩 읽기 때문에!)
  	- 하지만 어셈블러가 지원하는 연산자에는 존재할 수도 있기 때문에, 우선순위를 직접 지정해 주는 게 좋음

#a.asm
~~~c
// 어떤 어셈블러는 연산자를 지원하기 때문에, 이런 경우 우선순위를 직접 지정해 주는것이 좋음

lda #1+2*3  ; A9 07
lda #1+2*3  ; A9 09

// 우선순위 직접 지정
lda #1+(2*3)  ; A9 07
lda #(1+2)*3  ; A9 09
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 변수와 상수
  - 실행중 데이터는 기본적으로 RAM에 저장 한다
  	- 즉, 변수도 RAM에 저장되고, 따라서 모든 데이터에는 메모리 주소가 있다
  	- 데이터 읽기(load) : 특정 주소로 가서 데이터를 읽어옴
  	- 데이터 쓰기(store) : 특정 주소로 가서 데이터를 덮어씀
  - 기본적으로는 RAM에 저장을 하지만, 100%는 아니며, CPU 레지스터에 데이터를 저장해 쓰는 상황들도 있다
  - 아래의 간단한 덧셈 예 처럼, 어셈블리어는 변수를 지정한다는 것이 lda를 통해 값을 집어 넣고 사용한다는 것과 같다
  - 긴 코드에서 많은 변수를 사용한다면, 주소가 충분치 않을 수 있기 때문에 사용하지 않는 주소를 재사용한다
  	- 고수준 언어의 좋은 컴파일러는 이런 일을 알아서 해준다
  	- 어셈블리어의 변수는 C나 C++에서 사용하는 전역변수가 비슷한 느낌이다

#a.asm
~~~c
// 간단한 덧셈 예 - a 모드

; 3+ 12
clc  ; 받아올림 초기화
lda #3
adc #&0C
sta $1000

; 2 + 1
lda #2
adc #1
sta $1001
; (3+12)-(2+1)

sec ; 받아내림 초기화
lda $1000
sbc $1001
sta $1002
~~~

  - zp모드를 사용하면, 데이터를 접근할때 2바이트 주소인것에 사이클을 1회씩 아낄수가 있다

#a.asm
~~~c
// 간단한 덧셈 예 - zp 모드

; 3+ 12
clc  ; 받아올림 초기화
lda #3
adc #&0C
sta $00

; 2 + 1
lda #2
adc #1
sta $01
; (3+12)-(2+1)

sec ; 받아내림 초기화
lda $00
sbc $01
sta $02
~~~

  - a모드 : 바이트 : 25 / 사이클 32
  - zp모드 : 바이트 : 20 / 사이클 27

  - 긴코드에서 많은 변수를 사용한다면
  	- 언제나 새로운 주소를 사용
  		- 제로 페이지 안에 다 못 넣을 수 있음
  		- 절대 주소는 충분할 수도 아닐 수도
  	- 이제는 사용하지 않는 주소를 재사용
  		- 고수준 언어의 좋은 컴파일러는 이런 일을 알아서 해줌
  	- 어떤 방식이든 간에 단점
  		- 사용 중인 메모리 주소를 프로그래머가 기억해야 함
  		- 누구든 그 메모리 주소를 덮어쓸 수 있음

  - 고수준 언어에서 메모리 주소를 직접 기억 안 해도 되는 이유
    - 변수가 있기 때문(컴파일러가 주소에 별칭을 달아서 해줌)
  - 어셈블리어에서는 변수명 대신에, 별칭을 달아 줄 수 있음


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 스택
  - 누구나 어떤 주소에 값을 덮어 쓸 수 있는 이유는 전역 변수이기 때문
    - 어셈블리어에서는 흔한 일
    - 출력 장치도 그대로 메모리 주소에 매핑되어 있음
  - 스택(0x0100 ~ 0x01FF)을 사용할 수도 있음
    - 실행 중에 메모리 주소가 결정됨
  - 스택 관련 6502 니모닉
    - pha : A레지스터 값을 스택에 push
    - pla  : 스택에서 A레지스터로 pop
    - php : 프로세서 상태를 스택에 push
    - plp : 스택에서 프로세서 상태를 pop
    - tsx : 스택 포인터를 X 레지스터로 전송
    - txs : X레지스터 값을 스택 포인터로 전송

#a.asm
~~~c
// 스택을 사용한 예시

; 3+ 12
clc  ; 받아올림 초기화
lda #3
adc #&0C
pha

; 2 + 1
lda #2
adc #1
tsx ; 스택 위치 저장
pha
; (3+12)-(2+1)

sec ; 받아내림 초기화
pla
pla
sbc $0100, x
sta $02
~~~

  - 스택사용 : 바이트 : 20 / 사이클 35
  - 6502 CPU에서는 레지스터가 한개밖에 없기 때문에 복잡해지는 경향이 있다.
  - 따라서 6502 CPU에서는 스택이 아닌, 메모리 주소를 따로 주고, 별칭을 주는 방법을 더 선호 한다
  - 스택의 진정한 효능은 함수 호출시

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 상수 - 매직넘버, 상수형 변수
  - 상수 - 매직넘버
    - 명령어 코드의 일부가 됨
    - 어셈블러는 보통 여러 상수 표기법을 지원한다
      - 10진수 :
      - 16진수 : $
      - 2진수 : %
      - ASCII : ‘
    - 16진수를 사용하는 게 가독성에 좋음

#a.asm
~~~c
ex) lda #10  ; 0A
ex) lda #$10  ; 10
ex) lda #%10  ; 02
ex) lda #'A  ; 41
ex) adc 1000  ; 03EB
ex) adc $1000  ; 1000
ex) adc %1000  ; 08
~~~

  - 상수형 변수
  	- 매직넘버는 의미가 분명치 않으니, 상수형 변수를 쓰는것이 좋음
  	- 보통 어셈블러도 상수형 변수를 지원

#a.asm
~~~c
THICK = 2  ; 상수형 변수

lda $2200  ; AD 00 22
adc #THICK  ; 69 02
sta $2200  ; 8D 00 22

THICK = 2
width = $2200  ; 포인터 변수

lda $2200  ; AD 00 22
adc #THICK  ; 69 02
sta width  ; 8D 00 22
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 데이터 블록
  - 명령어와 함께 상수를 사용하지 않고, 그냥 메모리 안에 데이터만 저장하고 싶을때는 어셈블러의 데이터 지시문들을 사용한다
  	- .BYTE :  1바이트
  	- .WORD : 2바이트

#a.asm
~~~c
	.PROCESSOR 6502
	.ORG $8000

	clc
	lda $8000
	adc $8001
	adc $8002
	adc $8003
	sta $1000

	.ORG $C000, 0
	.BYTE $00, $01, $02, $03
	.BYTE "Hello World"
	.BYTE  0 ; 널 문자
	.WORD $1000, $1001

	.ORG $FFFC,0
	.WORD $8000 <- 프로그램은 여기 주소로 이동해서 시작한다
	.WORD $0000
~~~

![20231005_122600](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/38ea1442-0116-4841-8a7a-7f5534012448)

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 라벨
  - 위치한 곳의 바이트 주소를 가리키는 별칭
  - 코드에서 주소 대신 라벨을 사용 가능
  	- C의 goto,  label : 명령어의 실체
  - 어셈블 중에 실제 주소로 변환 됨
  	- 최종 이진 파일에서 공간을 차지하지 않음
  	- 참고 : sum도 마찬가지
  - 코드 변경의 여파가 줄어듦
  	- 좋은 습관이 중요한 이유

#a.asm
~~~c
sum=$1000

    clc  <- clc이후부터 nums주소를 읽을때 아래에 있는 nums label주소로 이동한다
    lda nums
    adc nums+1
    adc nums+2
    adc nums+3
    sta sum

    .ORG $C000, 0
nums : 
    .BYTE $00, $01, $02, $03
hello :
    .BYTE "Hello World"
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 레지스터(6502)
  - CPU속에 위치한 초저용량 메모리
    - 어떤 부품보다 빠르게 접근 가능
    - 레지스터 개수는 아주 제한적이다
  - 궁극의 최적화 장소
    - 캐시 메모리의 영향조차 받지 않음
    - 어셈블리어로만 직접 접근 가능
  - 외부에서 값을 직접 볼 수 없음
    - 어셈블리어로도 직접 접근할 수 없는 레지스터도 있음
  - 레지스터
    - 메인 레지스터(A레지스터 1개존재)
      - 특히 ALU의 입출력으로 쓸 수 있는지가 중요
      - 그 당시 타 CPU에 비해도 현저히 적음
      - 그걸 만회하려 만든 꼼수가 제로 페이지
    - 색인 레지스터(X,Y2개)
      - ALU의 거의 대부분 연산에 사용 불가 ㅠ
      - 배열 색인처럼 사용(주 용도)
        - ldx
        - ldy
        - stx
        - sty
        - inx
        - iny
        - dex
        - dey
      - 비교 값으로 사용
        - cpx
        - cpy
      - 8비트 데이터 임시 저장
        - tax
        - tay
        - txa
        - tya
      - 스택 내 데이터에 접근
        - txs
        - tsx
      - 프로세서 상태 레지스터
      - 프로그램 카운터
    - 색인 레지스터(S 1개)
      - 스택 메모리를 사용하는 곳이며, 스택이 쌓일때, 스택의 다음 빈 공간을 가리키는 스택 포인터!
      - [0x00, 0xFF]의 주소를 가리키는 포인터
        - 실제로는 페이지 1속의 주소 : [0x0100, 0x01FF]
      - 직접 push/pop 연산을 하며 증감
        - pha, php, pla, plp
      - 함수 호출 및 인터럽트의 일부로 자동 증감이 되기도 함
        - jsr, brk, rts, rti
      - S레지스터의 초기값
        - S의 초기값을 강제하지 않음
        - 스택 오버플로 상태 플래그에 따라 분기하지 않으면 어떤 값도 상관 없음
          - 링 버퍼 처럼 작동하기 때문에 스택 사용량이 256바이트만 안 넘으면 됨
        - ROM처음에서 이렇게 초기화해 주는 것이 바람직
        - ex)   ldx #$FF
        -         txs
    - 프로세서 상태 레지스터 - P
      - 7개의 비트 플래그
        - N : negative
        - V : overflow
        - Z : zero
        - C : carry
        - B : break
        - D : decimal
        - I : interrupt disable
      - 프로세서의 현 상태를 나타냄
        - 바로 직전에 실행한 명령어의 결과
        - 직접 켜거나 끌 수 있는 비트도 있음
    - 프로그램 카운터 - pc
      - 유일한 16비트 레지스터
      - 현재 fetch 중인 명령어의 주소
        - 부팅 시 리셋 벡터에 저장된 값이 pc로 설정
      - 명령어가 실행됨에 따라 자동으로1 씩 증가
        - 직접 pc값을 읽어 오거나 덮어쓸 수 없음
        - 기타 함수 호출 및 인터럽트 등의 연산을 통해 변경 가능
          - 함수 호출시, 반한 후 실행해야 할 코드의 주소를 스택에 push, push
          - 함수 반환 후, 스택을 pull, pull하여 PC에 설정

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 묵시적 명령어 몇개 소개
  - nop
    - 의미 : 연산 없음
      - 아무런 연산도 하지 않음
    - 용도
      - 프로그램 실행에 딜레이를 넣고 싶을때
      - 코드 메모리에 빈 공간을 reserve 하고 싶을 때
      - 디버깅 중 짜증 나는 코드를 지워버릴 때
      - 프로그램의 끝을 표기할 때
      - 모드 : i / opcode : EA / 바이트 : 1 / 사이클 : 2

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 프로그램 종료
  - 임베디드 시스템의 기본 동작은 무한 루프
    - 전원이 끊길 때까지 같은 동작을 반복
  - 한 번 실행 후 아무것도 안하게 하고 싶다면?
    - 자기 스스로에게 점프하며 무한 루프

#a.asm
~~~c
// 자기 스스로에게 점프하며 무한 루프

out=$4000

    ldx #$FF
    txs
start:
    lda #'H
    sta out
    lda #'i
    sta out
end:
    jmp end
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

***

# 6502어셈블리 니모닉 정리
  - lda 피연산자 : A레지스터에 피연잔사 값넣기
  - clc : 받아올림 초기화(C = 0)
  - sec : 받아내림 초기화(C = 1)
  - adc 피연산자 : 받아올림을 이용한 덧셈
  - sbc 피연산자 : 받아내림을 이용한 뺄셈
  - sta  피연산자 : A레지스터에 있는 값을 피연산자 주소에 넣기
  - pha : A레지스터 값을 스택에 push
  - pla  : 스택에서 A레지스터로 pop
  - php : 프로세서 상태를 스택에 push
  - plp : 스택에서 프로세서 상태를 pop
  - tsx : 스택 포인터를 X 레지스터로 전송
  - txs : X레지스터 값을 스택 포인터로 전송
  - tax : A레지스터 값을 X레지스터로 전송
  - tay : A레지스터 값을 Y레지스터로 전송
  - txa : X레지스터 값을 A레지스터로 전송
  - tya : Y레지스터 값을 A레지스터로 전송
  - inc : 메모리의 값을 1 증가
  - inx : x레지스터를 1 증가
  - iny : y레지스터를 1 증가
  - dec : 메모리의 값을 1 감소
  - dex : x레지스터를 1 감소
  - dey : y레지스터를 1 감소
  - lsr : 논리적 우측 비트 이동
  - rti : 인터럽트에서 복귀
  - asl : 산술적 좌측 비트 이동
  - rol : 비트들을 1 비트만큼 왼쪽으로 이동
  - ror ; 비트들을 1 비트만큼 오른쪽으로 이동
  - and : A레지스터와 논리곱
  - ora : A레지스터와 논리합
  - eor : A레지스터와 배타적 논리함
  - cmp : A레지스터와 비교
  - jmp : 특정 주소로 점프
  - beq : Z == 1 일때 특정 주소로 점프 A == M
  - bne : Z == 0 일때 특정 주소로 점프 A != M
  - bcc : C == 0 일때 특정 주소로 점프 A < M
  - bcs : C == 1 일때 특정 주소로 점프 A >= M
  - bmi : N == 1 일때 특정 주소로 점프
  - bpl : N == 0 일때 특정 주소로 점프
  - bvc : V == 0 일때 특정 주소로 점프
  - bvs : V == 1 일때 특정 주소로 점프
  - cpx : x레지스터와 비교(그다음은 cmp와 같음)
  - cpy : y레지스터와 비교(그다음은 cmp와 같음)
  - bit : A레지스터 값을 바꾸지 않는 and연산
  - jsr : 함수를 호출할 때 사용(서브루틴으로 점프)
  - rts : 함수에서 돌아올 때 사용(서브루틴에서 회귀)

###### [6502어셈블리 니모닉 정리](#6502어셈블리-니모닉-정리)
###### [Top](#top)

<br/>
<br/>

***

# 6502어셈블리 플래그 정리
  - C(bit 0) : 받아올림 플래그
    - bit 7에서 받아올림이 생기면 C플래그도 켜짐
  - Z(bit 1) : 제로 플래그
    - 8비트가 모두 0이면 켜짐
    - 모든 데이터 이동 및 계산 연산에 적용됨
  - V(bit 6) : 오버플로 플래그
    - A와 M의 bit7이 같았는데 결과의 bit7이 다르면 V 켜짐
  - N(bit 7) : 음수 플래그
    - bit 7이 1이면 켜짐
    - 모든 데이터 이동 및 데이터 산술 연산에 적용
    - 주 용도는 음수 판단
      - 실제 음수란 뜻이 아니다
      - 프로그래머가 0~255수를 더한다면 양수가 된다
      - -128~127을 원한다면 음수가 된다
        - N플래그에 따라 프로그래머가 결정해야 할 일

###### [6502어셈블리 플래그 정리](#6502어셈블리-플래그-정리)
###### [Top](#top)

<br/>
<br/>

***

# 6502 어셈블리 산술 논리 연산
  - [adc : 받아올림을 이용한 덧셈(C, V플래그)](#adc-받아올림을-이용한-덧셈c-v플래그)
  - [sbc : 받아내림을 이용한 뺄셈](#sbc--받아내림을-이용한-뺄셈)
  - [증감 연산](#증감-연산)
  - [색인 주소지정 모드](#색인-주소지정-모드)
  - [페이지 크로싱](#페이지-크로싱)
  - [비트 이동/회전 연산](#비트-이동회전-연산)
  - [논리 연산, NOT연산구현,6502에 없는 연산들..](#논리-연산-not연산구현6502에-없는-연산들)
  - [CPU에 데이터 형은 없다 해석은 남의 몫](#cpu에-데이터-형은-없다-해석은-남의-몫)
  - [단항 바이트 연산자](#단항-바이트-연산자)

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# adc : 받아올림을 이용한 덧셈(C, V플래그)
  - 두 8비트 정수 간 덧셈을 수행
    - A레지스터
    - 피연산자(메모리)
    - ALU가 A레지스터 와 피연산자(메모리)에 접근할 수 있지만 CPU레지스터에 있는 A레지스터에는 직접 접근할 수 있어 굉장히 빠르지만 그보다 피연산자(메모리)는 접근이 느릴 수 밖에 없다
  - 결과 : A레지스터에 다시 대입
    - bit 7에서 받아올림이 생기면 C플래그도 켜짐
    - A와 M의 bit7이 같았는데 결과의 bit7이 다르면 V도 켜짐
  - 정수 오버 플로
    - 산술 연산의 결과가 주어진 비트로 표현 가능한 범위를 벗어나는 경우, 제대로 표현하려면 비트가 더 필요함, 현재 6502 CPU의 A레지스터는 1바이트(=8비트)이므로 255까지의 수를 표현 가능하다.(=255 초과되는 수는 비트가 한개 더 필요하니, 정수 오버플로가 난다)
  - 정수 오버 플로 처리 방법
    - 하나의 레지스터에 표현 가능하면 그냥 무시하기(오버플로)
      - 현대 고수준 언어에서 일반적인 덧셈 방법
      - 결과가 범위를 넘지 않는다고 가정하고 코드 작성
      - 8비트 기계에서는 너무 제한적인 방법..ㅠ
    - 다음 바이트 계산에 추가 하기(2배 정밀도 덧셈)
      - 1. bit7의 받아올림 결과를 C에 저장(c는 상태 레지스터!)
      - 2. bit 0을 더할 때 C도 같이 더함
  - 받아올림(carry)플래그 - C (bit 0 )
    - 수학 및 비트 회전 연산에 사용하는 받아올림/받아내림 플래그
      - 프로세서 상태 레지스터의 C 비트
    - 특정 ALU 연산 결과에 따라 이 비트가 켜지거나 꺼짐
      - 모든 명령어가 이 비트를 바꾸는 게 아님
  - adc와 clc
    - 두 수를 더하기 전에 받아올림 플래그 ( C )를 지워줘야 함
      - ALU는 우리가 수를 더하는 중인지 새로 덧셈을 시작하는지 모름
    - adc는 언제나 C값을 같이 더함
    - ALU는 adc 연산 결과에 따라 C비트를 변경
      - 오버플로가 있었을 경우 : C = 1
      - 오버플로가 없었을 경우 : C = 0
    - 따라서 첫 바이트를 더하기 전에만 clc를 호출해 0이 더해지게 함
      - 다음 바이트부터는 앞 바이트의 받아올림 결과를 같이 더해야 함
  - 하지만 오버 플로우는 unsigned일때도 있지만, signed일때도 일어난다. 어셈블리어 수준에서 본다면 같은 비트 패턴 이지만 unsigned일때와 signed일때 값이 달라지기 때문에 이것은 프로그래머의 판단으로 맡기게 된다, 고수준 에서는 이것을 하나의 변수로 지정해서, 컴파일러가 대신 해주게 된다
    - C비트인 carry플래그가 켜진다고 해서 무조건 오버 플로우가 생겼다고 할 수 없다(=unsinged일때만 가능한것이고, singed일경우에는 최상위 비트가 음수이면 무조건 1이기 때문에, 음수 + 음수는 무조건 carry가 생기기 때문)
  - signed덧셈의 가능한 조합
    - 양수 + 음수
      - 계산 후 양수일때 : C : 1 / V : 0
      - 계산 후 음수일때 : C : 0 / V : 0
    - 양수 + 양수
      - 계산 후 오버플로일때 : C : 0 / V : 1
      - 계산 후 정상일때 : C : 0 / V : 0
    - 음수 + 음수
      - 계산 후 오버플로일때 : C : 1 / V : 1
      - 계산 후 정상일때 : C : 1 / V : 0
  - carry플래그도 있지만 오버플로우 플래그(V - bit 6)도 존재한다
    - 특정 ALU연산 결과에 따라 이 비트가 켜지거나 꺼짐
    - signed연산을 할 때 특히 유용
    - unsigned는 캐리 플래그로 충분
    - 7비트로 표현 못하는 연산 결과가 있음을 나타내야 하는 플래그이다

#a.asm
~~~c
// 2배 정밀도 덧셈 예

NUM0=%01101000
NUM1=%10011010
out1=$2000
outh=out1+1

    ldx #$FF
    txs

    clc         ; c = 0
    lda #NUM0
    adc #NUM1   ; c = 1
    sta out1
    lda #0
    adc #0      ; c == 0      <- adc는 언제나 C값을 같이 더함, 여기서는 더한후에 캐리가 된것이 없기 때문에 c 가 0이 된다
    sta outh
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# sbc : 받아내림을 이용한 뺄셈
  - 두 8비트 정수 간 뺄셈을 수행
    - A레지스터
    - 피연산자 (메모리)
  - 결과 : A레지스터에 다시 대입
    - V플래그 : signed 오버플로가 발생하면 켜짐
      -  결과가 [-128, 127] 범위를 넘어서면 켜짐
    - C플래그
      -  C == 1 : 결과가 0이상, 받아내림이 없었음
        -  bit7 끼리 더해서 받아 올림이 생기면 C는 1이된다
      -  C == 0 : 결과가 음수, 받아내림이 있었음
        -  bit7 끼리 더해서 받아 올림이 없다면 C는 0이된다
      -  따라서 새로운 수의 뺄셈을 하기 전에 sec를 호출해야 함
        -  C를 1로 셋팅 해줌

#a.asm
~~~c
out=$2000
    ldx #$FF
    txs

    sec   ;  c = 1
    lda #$0A   ; 00001010
    sbc #$02   ; 11111110  ; c = 1
    sta out

1. C를 1로 시작
2. 내부적으로 sbc의 피연산자의 비트를 반전 시키고(반전시킨 비트 = 11111110)
3. A에 더함
4. 결과 = 1 00001000 (받아 내림이 없었음)
~~~

<br/>

#a.asm
~~~c
out=$2000
    ldx #$FF
    txs

    sec   ;  c = 1
    lda #$0A   ; 00001010
    sbc #$0C   ; 11110100  ; c = 0
    sta out

1. C를 1로 시작
2. 내부적으로 sbc의 피연산자의 비트를 반전 시키고(반전시킨 비트 = 11110100)
3. A에 더함
4. 결과 = 0 11111110 (받아 내림이 있었음)
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 증감 연산
  - 값을 1만큼 증가 혹은 감소하는 연산
  - 잦은 연산이라 별도의 명령어를 제공
    - C언어에서 ++ , - - 를 하는것과 같은것
    - num = num + 1 보다 빠름
    - 일반적으로는 lda(3사이클) + adc(2사이클) + sta(3사이클) = 총8사이클이 지만, inc니모닉을 사용하면 5사이클만으로 증감 연산을 할 수 있다
  - inc : 메모리의 값을 1 증가
  - inx : X레지스터를 1 증가
  - iny : Y레지스터를 1 증가
  - dec : 메모리의 값을 1 감소
  - dex : X레지스터를 1 감소
  - dey : Y레지스터를 1 감소

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 색인 주소지정 모드
  - X 또는 Y 레지스터의 값을 배열 색인처럼 사용
    - 피연산자 주소는 고정
    - inx를 통해 X를 증가시켜 줌

#a.asm
~~~c
// 절대 주소지정 모드

sum=$1000
    ldx #$FF
    txs

    clc
    lda nums
    adc nums+1
    adc nums+2
    adc nums+3
    sta sum

    .ORG $C000, 0
nums:
    .BYTE $00, $01, $02, $03
~~~

<br/>

#a.asm
~~~c
// 색인 주소 지정 모드
sum=$1000
    ldx #$FF
    txs

    clc
    lda nums
    ldx #1 <- X레지스터를 1로 세팅
    adc nums, X
    inx   <- 이것을 통해서 x를 1씩 증가시키면서 다음 다음 저장된 값을 가져 온다
    adc nums, X
    inx
    adc nums, X
    sta sum

    .ORG $C000, 0
nums :
    .BYTE $00, $01, $02, $03
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 페이지 크로싱
  - 주소 연산 결과가 다음 페이지를 가리키는 현상
    - 하위 주소의 덧셈에서 받아올림이 생김
    - 그 받아올림을 상위 주소에 더해야 함
    - 한마디로, 0페이지에서 1페이지로 넘어가게 되면, 주소를 하위주소만 가져오는 것이 아니라 상위주소도 가져 와야 하는 상황이 생기기 때문에 1사이클이 증가하게 된다
  - 최종 주소를 찾으려면 1 사이클이 추가로 필요
    - 명령어 바이트 크기는 동일
    - 속도가 중요하다면 페이지 경계에 데이터가 걸치지 않도록 조심할 것
  - adc nums, x
  - 위와 같은것이 a, x, a, y a모드
  - zp, x가 여전히 4 사이클인 이유
    - a, x 모드에서 BAh fetch는 공짜
      - BAl + X를 계산하는 동안 BAh를 fetch
    - zp, x 모드에서 BAh를 fetch 안 해 얻는 이득이 없음
      - BAl + X 계산은 피할 수 없음
      - 이 주소를 알기 전까지는 데이터 읽기/쓰기가 불가

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 비트 이동/회전 연산
  - 데이터의 비트들을 왼쪽 혹은 오른쪽으로 이동
    - 6502는 한 번에 1씩 이동
    - 밀려나간 비트는 C플래그로 들어감
  - 이동과 회전의 차이는 새로 들어오는 비트
    - 이동 : 언제나 0
    - 회전 : C플래그의 값
  - 일반적으로 매우 빠른 연산 중 하나
    - 특히 레지스터에서 작동할 때
  - asl
    - 비트들을 1 비트만큼 왼쪽으로 이동
    - 새로채워지는 비트는 0
    - A레지스터 또는 메모리에서 동작
    - A모드 : 2사이클
    - 영향받는 플래그 : N, Z, C
    - C플래그
      - 밀려나간 비트를 저장
      - 그 값을 사용하진 않음
  - lsr
    - 비트들을 1비트만큼 오른쪽으로 이동
    - A레지스터 또는 메모리에서 동작
    - 한번이라도 사용하면 그 값은 N플래그를 언제나 0으로 만듬(최상위 비트를 0으로 만들기 때문에)
  - rol
    - 비트들을 1 비트만큼 왼쪽으로 이동
    - 새로 채워지는 비트는 C에 들어있던 값으로 채움
    - 밀려나간 비트는 C에 저장
  - ror
    - rol과 같고, 이동을 오른쪽으로 할 뿐
  - 비트 이동
    - 빠른 2의 배수 곱셈/나눗셈
    - CRC체크섬 계산
    - 엔디언 변환
    - 빠른 해시값 계산
    - 비트 플래그 (비트 마스킹)
    - 등
  - 비트 회전
    - 2배 정밀도 덧셈 최적화
    - 비트 패턴 뒤집기
    - 워드보다 큰 데이터를 비트 이동할 때
    - 등

#a.asm
~~~c
// 비트이동, 비트회전

    .PROCESSOR 6502
    .ORG $8000

VAL=%01011000
r=$80
    ldx #$FF
    txs

    lda #VAL
    rol      ; 왼쪽에 하나를 빼서 C레지스터에 저장
    ror r    ; 다른 메모리에 C레지스터에 있는 값을 빼서 오른쪽으로 밀면서 저장
    rol
    ror r
    rol
    ror r
    rol
    ror r

    rol
    ror r
    rol
    ror r
    rol
    ror r
    rol
    ror r

    .ORG $FFFC, 0
    .WORD $8000
    .WORD $0000
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 논리 연산, NOT연산구현,6502에 없는 연산들..
  - 3개의 논리 연산 명령어를 제공
    - and(=and)
      - A레지스터와 논리곱
    - ora(=or)
      - A레지스터와 논리합
    - eor(=xor)
      - A레지스터와 배타적 논리함
    - A와 M사이의 논리 연산
      - 각 비트 별로 연산
      - 결과를 A레지스터에 저장
    - 영향 받는 플래그 : N, Z

#a.asm
~~~c
// 비트마스킹

VAL=%01011000
MASK0=%01000000
MASK2=%00100000
	ldx #$FF
	txs

	lda #VAL
	and #MASK0  ; Z == 0

; Z값에 따라 분기

	lda #VAL
	and #MASK1  ; Z == 1

; Z값에 따라 분기
~~~

<br/>

#a.asm
~~~c
// 대문자 -> 소문자로 바꾸기

ch=$80
MASK=%00100000
    ldx #$FF
    txs

    lda ch
    ora #MASK
    sta ch

// 바이트 : 9
// 사이클 : 12
~~~

<br/>

#a.asm
~~~c
// NOT연산 구현

VAL=%01011000
	ldx #$FF
	txs

	lda #VAL
	eor #%11111111
~~~

<br/>

#a.asm
~~~c
// eor를 사용한 두 수 교환
num0=$80
num1=$81
	ldx #$Ff
	txs

	lda num0
	eor num1
	sta num0

	eor num1
	sta num1

	eor num0
	sta num0
~~~

  - NOT연산 구현
    - eor #%11111111 연산을 하면 not게이트가 된다

  - 6502에 없는 연산들
    - 곱셈, 나눗셈 등…
    - 이런것들은 대부분 기본적인 것으로부터 만들수 있음

#a.asm
~~~c
// 2의 배수를 곱하는 경우 : asl(비트들을 1 비트만큼 왼쪽으로 이동)
// shift연산을 사용하면 된다
num=$20
	ldx #$FF
	txs

	lda num
      asl
      asl
      asl
      asl
      sta num
~~~

<br/>

#a.asm
~~~c
// 다른 양의 정수를 곱하는 경우 : adc
// 곱하는 수만큼 더해주면 된다
num=$20
	ldx #$FF
	txs

	clc

	lda num
	adc num
	adc num
	sta num
~~~

<br/>

#a.asm
~~~c
// 2의 배수로 나누는 경우 : lsr
// shift비트 사용
lda num
lsr
lsr
sta num
~~~

<br/>

#a.asm
~~~c
// 다른 양의 정수로 나누는 경우 : sbc
// 0보다 클때까지만 빼면서 수를 1씩 올리면 그 올린수가 값이 된다
ldx #0

sec
lda num
sbc #DENOM  ; $03


; while (A >= 0)
; {
inx
sbc #DENOM
; }

stx num
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# CPU에 데이터 형은 없다 해석은 남의 몫
  - 데이터 형
    - CPU의 핀을 보면 많은 걸 알 수 있음
    - 6502의 데이터 너비는 8비트
      - 하드웨어가 이해하는 최대 데이터 크기는 1바이트
      - 최소 데이터 크기는 1비트
    - 엄밀히 말하면 데이터형은 없음
      - 해석은 프로그래머나 고수준 언어 컴파일러의 몫
    - 하지만 byte 데이터 형이 있다고 말 할 수도 있음
      - 데이터 레지스터와 데이터 핀이 한번에 8비트씩 처리
      - ALU도 8비트씩 연산 가능
      - byte : 6502가 유일하게 아는 자료형(ALU의 워크 크기)
  - 메모리에서의 문자
    - 그냥 8비트 정수값
    - 아스키코드 : 그 정수와 문자와의 관계를 정의
      - 01000001(65) : A
      - 01100001(97) : a
    - 그걸 보고 해석하는 건 다른 사람의 몫
      - 예 : 입력장치, 화면, 프로그래머 등
  - 컴퓨터의 기본 입출력
    - 임베디드 : 여러 하드웨어의 스펙에 따라 잘 코딩
    - 하지만 기본 입출력은 여러 기계에 매우 공통적인 작업
      - PC에 BIOS가 등장하며 이런 일을 대신 처리해 줌
      - 이제는 운영체제(OS)의 역할
  - 6502에서 실수형, 형 변환
    - 실수형
      - ALU는 정수 처리를 기초로 함
      - 6502를 비롯한 오래된 CPU의 ALU는 정수만 지원
      - 실수 연산 및 자료형은 직접 만들어 써야 함
        - 6502의 BCD(Binary Coded Decimal)모드 지원
        - 고정 소수점과 부동 소수점(IEEE 754) 모두 구현 가능
        - 일반적으로 고정 소수점을 사용했음
      - 실수 처리를 위해 별도의 회로를 탑재할 수도 있음
    - 형 변환
      - 일반적인 프로그래밍 언어에서의 형 변환
        - 정수 <> 정수
        - 정수 <> 실수_6502에서 없음
        - 개체 레퍼런스 <> 개체 레퍼런스_6502에서 없음
          - 개체는 어떤 개체의 시작주소가 담겨 있을 뿐
          - 고수준에서 개체 형변환을 할때 그 주소는 바뀌지 않고, 어떤 개체의 시작주소로 가서 해석할지 바뀌는 것이다.
        - 비트패턴은 없다고 생각하면 되고, 프로그래머가 비트 패턴을 해석하기 나름
      - 고수준에서의 정수형 변환
        - 묵시적으로 바뀌는 경우는, 대입해도 정보를 잃지 않을때 허용하게 되며, 앞부분에 0 비트를 넣어주는 것일 뿐이다(작은 비트 -> 큰 비트로 갈때)
          - byte -> short
          - short -> int
          - ing -> long
        - 명시적으로 바꾸는 경우는, 정보를 잃을 수 있어서 프로그래머가 직접 명령을 해야 할때이다. 상위 바이트를 해석하지 않고, 허용된 하위 바이트만 해석하게 된다
          - 1. 저장 공간이 줄어들 때
            - short -> byte
            - int -> short
            - long -> byte
          - 2. singed <> unsigned
            - 비트 패턴 안 변함
            - 해석만 다르게 함
      - 정리 : 고수준 언어의 정수형 변환
        - 비트 패턴은 변하지 않음
        - 그 비트 패턴을 다르게 해석할 뿐
        - 비트 패턴을 잘못 해석하는 일을 막는 건 프로그래머의 몫
        - 즉, 정수형을 변환한다는 것보다 정수형을 어떻게 해석한다는 표현이 더 옳다
        - 어셈블리어 에서는 그 해석또한 프로그래머가 알아서 해야 함

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 단항 바이트 연산자
  - < 연산자 : 하위 바이트 반환
    - <$1234 = $34
  - > 연산자 : 상위 바이트 반환
    - >$1234 = $12
  - 어셈블러의 기능

#a.asm
~~~c
VAL=$1234
num=$80
	ldx #$FF
	txs

	lda num
	adc #<VAL  ; $34
	adc #>VAL  ; $12
	sta num
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

***

# 조건문
  - [cmp, jmp, beq, bne, bcc, bcs](#cmp-jmp-beq-bne-bcc-bcs)
  - [bmi, bpl, bvc, bvs](#bmi-bpl-bvc-bvs)
  - [조건문 작성](#조건문-작성)
  - [상대 주소지정 모드](#상대-주소지정-모드)
  - [기타if문 관련](#기타if문-관련)

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

# cmp, jmp, beq, bne, bcc, bcs
  - 어셈블리어는 참/거짓을 판단할때, 하나만 비교하는 것이 아니라 모든 조건을 다 비교한다
    - a와 b를 다 비교
      - if (a < b)
      - if (a > b)
      - if (a == b)
      - if (a != b)
    - 비교 결과 중 하나에 따라 점프
    - 비교할때 쓰는 명령어 “cmp”
  - cmp
    - A와 M을 비교
      - A-M을 수행
    - 결과
      - N,Z,C플래그가 변경됨
        - 이 플래그에 따라서 어떤 비교가 되었는지 확인 할 수 있음
      - A값은 바뀌지 않음
    - 가장중요한것!!!!
      - cmp는 비트 패턴만 보기 때문에, unsigned만을 비교 할 수 있다!!! -5와 5를 비교하면, 비트 패턴으로는 -5가 더 크기 때문에..! 비교할 수가 없음
    - 따라서 아래와 같이 N,Z,C플래그의 변경됨을 통해서, 값이 어떻게 비교 됐는지 확인 할 수 있고 그것을 니모닉으로 만들어 놓았음

#a.asm
~~~c
A == M / N = 0 / Z = 1 / C = 1
A < M / N = ? / Z = 0 / C = 0
A > M / N = ? / Z = 0 / C = 1

1. Z == 1 / beq / A == M
2. Z == 0 / bne / A != M
3. C == 0 / bcc / A < M
4. Z == 0 && C == 1 / A > M
5. C == 1 / bcs / A >= M
~~~

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

# bmi, bpl, bvc, bvs
  - 일반 조건이 아닌, 산술연산 후에 점프하는 경우
    - bmi : N == 1 일때 특정 주소로 점프
    - bpl : N == 0 일때 특정 주소로 점프
    - bvc : V == 0 일때 특정 주소로 점프
    - bvs : V == 1 일때 특정 주소로 점프

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

# 조건문 작성

#a.asm
~~~c
if(NUM == 5)
{
   *ret = 'E';
}
else if(NUM < 5)
{
   *ret = 'L';
}
else
{
   *ret = 'G';
}

위의 조건문을 어셈블리어로 작성

ret=&80

0x8000 lda #Num
0x8002 cmp #$05

0x8004 bne $800B
0x8006 lda #'E   ; $45
0x8008 jmp $8014

0x800B bcs $8012   // cmp를 이미 앞에서 했기 때문에 한번더 필요 없음
0x800D lda #'L   ; $4C
0x800F jmp $8014

0x8012 ida #'G  ; $47

0x8014 sta ret
~~~

  - cmp는 비트 패턴만 보기 때문에, unsigned만을 비교 할 수 있다!!! -5와 5를 비교하면, 비트 패턴으로는 -5가 더 크기 때문에..! 비교할 수가 없음(실제로 -5 - 5를 하면 C가 1로 세팅이 되기 때문)
    - signed비교 방법
      - 1. A와 M의 부호 비트(비트7)를 뒤집는다
        - eor #$80
      - 2. cmp 연산을 한다
      - 3. 원래 공식에 따라 분기한다
    - 비교할때의 생각
      - 양수 양수라면 큰 값의 양수가 비트패턴이 크기 때문에 이상이 없음
      - 음수 음수 라면, 큰 값의 음수가 비트패턴이 크기 때문에 이상이 없음(-1이 -2보다 큰값이다)
      - 문제는 양수와 음수를 비교할때인데, 이때는 음수가 비트패턴이 무조건 크다. 따라서 bit7의 비트 패턴을 서로 바꿔주고 분기하면 된다
    - 최신 ISA에는 signed/unsinged분기용 니모닉이 별도로 존재

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

# 상대 주소지정 모드
  - 지정된 오프셋만큼 점프
  - 기준 : 현재 명령어
  - 오프셋 : 8비트
    - 따라서 앞뒤로 127바이트 정도만 점프 가능
    - 42~127명령어 범위
    - 분기의 대상인 코드가 이 보다 멀리 있기 어려움
  - 분기할때는 8비트 정도로만 점프할 수 있으며
    - 어셈블 중에 피연산자가 오프셋으로 바뀐다
    - 아래와 같은 경우 현재 FA의 위치는 8009가 되고,
    - FF부터 FA는 6바이트 이기 때문에 6바이트 전인 8003으로 점프한다
    - 점프할 크기를 FF부터 빼면 확인 할 수 있다

#a.asm
~~~c
//예1 : 근처로 분기 할 경우
0x8003 lda num  ; A5 20
0x8005 cmp #1   ; C9 01
0x8007 bne $8003  ; D0 FA
~~~

<br/>

#a.asm
~~~c
//예2 : 멀리로 분기 할 경우
// 컴파일 오류가 난다
0x8003 lda num 
0x8005 cmp #1  
0x8007 bne $FFFF
~~~

  - 일반적으로 분기를 쓸때는 라벨을 사용하게 된다, 유지보수 측면과, 보기가 훨씬 편하다

#a.asm
~~~c
num=$20

read:
	lda num
	cmp #1
	bne read <- 라벨을 사용하면 어셈블러가 알아서 이동시켜줌
~~~

  - 점프를 하는 것은 비용이 꽤나 드는 일 임으로, 데이터 분포를 알면, 최대한 점프를 적게 하는 방향을 생각할 수 있으며, 그것이 더 빠른 방법이 된다

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

# 기타if문 관련
  - switch/case문 없음
  - 조건 연산(삼항 연산자) 없음
  - 비교 연산 : 이미 봤음
  - 논리 연산 : and / ora / ero이후 N, Z플래그에 따라 분기
  - bit 니모닉(A & M)
    - A레지스터 값을 바꾸지 않는 and연산
    - Z플래그에 결과가 저장됨
      - Z == 1 : and결과의 모든 비트가 0
    - M의 bit7과 bit6을 N, V플래그에 대입
    - 이후 다양한 분기 명령어를 사용 가능

#a.asm
~~~c
// 문자열 패딩하기
//  X에 저장된 문자열의 길이가 8이 되도록 뒤에 . 을 출력하기로 가정
out=$4000  ; 여기에 출력하면 LCD가 화면에 출력한다고 가정
column=$4001

    txa    ; 6이라고 가정
    and #%00000011 ; 뒤에 2바이트는 0~3을 가리키기 때문에 여기가 00이여야 4의 배수가 된다

    beq pad0

    ldx #'.

    cmp #3
    beq pad1

    cmp #2
    beq pad2

pad2:
    sta out
    iny
    sty column

pad1:
    stx out
    iny
    sty column

pad0:
	...
~~~

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

***

# 반복문
  - 반복문 니모닉 및 opcode가 없음
  - 반복문은 기계어보다 상위의 개념
    - 기계의 연산이 아님
    - 기계의 다른 연산 여럿을 조합해 만든 개념
    - 반복문 = if + 점프
  - for문은 while문의 특화된 예
    - 1. int 변수의 값을 초기화
    - 2. 그 값이 특정 조건을 벗어나면 반복문 종료
    - 3. 반복문 블록 속 마지막 줄에서 그 변수 값을 증감
    - 색인 레지스터 X,Y를 유용하게 사용할 수 있음 
  - while vs do…while
    - 연속/종료 조건의 위치만 다름
      - while : 반복문 블록 실행 전에 검사
      - do…while : 반복문 블록 한 번 실행 후에 검사
    - 반드시 1번은 실행하냐 마냐의 차이
  - for, while, do…while : 사람이 편하게 문맥적으로 사용하는 것의 차이일뿐 기계어 수준에서는 모두 같다

#a.asm
~~~c
// 1부터 20까지 합하기
MAX=20
index=$10
out=$11

    clc

    lda #0  ;  sum = 0
    ldx #1  ;  index = 1

loop:
    cpx #MAX+1
    beq exit

    stx index
    adc index
    inx
    jmp loop

exit:
    sta out

// 바이트 : 22
// 사이클 : 318
~~~

  - 더 빠른 1부터 20까지 합하기
    - 위에 방법은 X색인을 증가 시키는것
    - inx을 사용했었음
    - 더 빠른 방법은 거꾸로 하는것
    - 20부터 시작해서 1까지 감소
    - dex를 사용

#a.asm
~~~c
// 더 빠른 1부터 20까지 합하기

MAX=20
index=$10
out=$11

    clc

    lda #0  ;  sum = 0
    ldx #MAX  ;  index

loop:
    beq exit

    stx index
    adc index
    dex        ; 여기서 x레지스터의 값을 0으로 만들때 Z플래그가 1로 켜짐
    jmp loop

exit:
    sta out

// 바이트 : 20
// 사이클 : 276
~~~

###### [반복문](#반복문)
###### [Top](#top)

<br/>
<br/>

***

# 배열
  - [일반 예제](#일반-예제)
  - [실행 중에 코드 변경하기](#실행-중에-코드-변경하기)
  - [다차원 배열](#다차원-배열)

###### [배열](#배열)
###### [Top](#top)

<br/>
<br/>

# 일반 예제
  - 자료구조 = 여러 요소들을 저장
  - 각 요소의 식별자는 색인
  - 색인을 사용해 요소의 위치를 쉽게 찾을 수 있음
    - 그것도 실행 중에
    - 간단한 산술 연산을 통해
  - 그럴 수 있도록 요소들을 메모리에 차례대로 저장

#a.asm
~~~c
// 배열의 합 구하기

LEN=4
sum=$1000

    clc

    lda #0
    ldx #LEN-1

loop:
    bmi exit

    adc nums, x
    dex          ; x를 감소시키다가 - 가 되면 N플래그가 켜진다
    jmp loop

exit:
    sta sum

    .ORG $C000,0
nums:
    .BYTE $00,$01,$02,$03
~~~

<br/>

#a.asm
~~~c
// 최대값 찾기


LEN=enums-nums
max=$90

    lda nums
    ldx #LEN-1

loop:
    beq exit
    cmp nums, x
    bcs continue
    lda nums, x

continue:
    dex
    jmp loop

exit:
    sta max

    .ORG #C000, 0
nums:
    .BYTE $03, $32, $A0, $C7
enums:
~~~

<br/>

#a.asm
~~~c
// 문자 위치 찾기
LEN=estr-str
CHAR=”l”

    lda #CHAR
    ldx #$00  ; X = 결과

loop:
    cpx #LEN
    beq notfound

    cmp str, x
    beq exit

    inx
    jmp loop

notfound:
    ldx #$FF

exit:

    .ORG $C000, 0
str:
    .BYTE “Hello World”
estr:

~~~

  - 더 빠른 문자 위치 찾기
    - NULL문자로 문자열의 끝을 표현
      - 보통 C문자열이라 부르는 그것
    - 비교 연산이 하나로 줄어듦
    - 보통 LEN을 사용해서 반복문을 처음부터 끝까지 돌리는 것보다 더 빠름

#a.asm
~~~c
// 더 빠른 문자 위치 찾기


CHAR=”l”

    ldx #$00  ; X = 결과

loop:
    lda str, x
    beq notfound  ; 문자열의 마지막에 0이 있기 때문에 끝까지 간다면 A레지스터에는 0이 들어가게 된다

    cmp #CHAR
    beq exit

    inx
    jmp loop

notfound:
    ldx #$FF

exit:

    .ORG $C000, 0
str:
    .BYTE “Hello World”
    .BYTE 0  ; 널 문자

~~~

<br/>

#a.asm
~~~c
// 문자열 길이 구하기

    ldx #$FF

loop:
    inx

    lda str,x
    bne loop

    .ORF $C000,0
str:
    .BYTE "Hello World"
    .BYTE 0  ; 널문자
~~~

<br/>

#a.asm
~~~c
// 소문자로 바꾸기

    ldx #$00

loop:
    lda str,x
    beq exit

    ora #$20
    sta str,x

    inx
    jmp loop

exit:

    .ORF $C000,0
str:
    .BYTE "Hello World"
    .BYTE 0  ; 널문자
~~~

<br/>

#a.asm
~~~c
// 문자열 복사하기

dst=$1000

    ldx #$FF

loop:
    inx
    lda str,x
    sta dst,x
    bne loop

    .ORG $C000,0
str:
    .BYTE "Hello World"
    .BYTE 0  ; 널 문자
~~~

###### [배열](#배열)
###### [Top](#top)

<br/>
<br/>

# 실행 중에 코드 변경하기
  - ROM이 아닌 RAM에 코드를 넣는 경우
    - 외부 저장장치(예:CD, USB 메모리)에 프로그램이 들어 있음
    - 실행하기 전에 RAM으로 프로그램을 복사
    - RAM에 있는 프로그램을 실행

#a.asm
~~~c
// 문자열 복사하기(RAM속 코드)
// 실행 중 코드 변경
    LEN=11
    src=$70
    dst=$90

loop:
    lda src

store:
    sta dst

    inc loop+1   ; src의 값을 1 증가시킨다 ex)71...72..73...74
    inc store+1  ; dst의 값을 1 증가시킨다 ex)91...92..93..94

    lda store+1
    cmp #dst+LEN ; 여기는 컴파일 이후에 바뀌지 않는 상수 이기 때문에 처음의 주소인 dst=$90으로 수치를 보게 된다
    bne loop
~~~

  - 위의 코드는 요즘에는 금기시하는 코드이긴 하다(메모리를 바꾸기 때문에)
  - 하지만 테크닉적으로 유용한 상황이 있음
    - 정수 배열 합치기
      - 오름차순으로 정렬된 정수 배열 4개가 있음
      - 이 배열들을 하나로 합치고 싶음
      - 새 배열도 오름차순으로 정렬되어 있어야함
      - [2,4,6,7,9], [3,6], [0,2,10,15], [5,8,9,11,13,14] -> [0,2,2,3,4,5,6,7,8,9,9,10,11,13,14,15]
        - 필요한 색인은 최대 5개(각 배열의 첫번째 주소)
          - 각 배열 색인 4개
          - 최정 배열 색인 1개
        - 6502에서는 2개의 색인 레지스터를 돌려가며 사용해야 함
          - 변수A에 색인 값을 저장
          - 변수B의 값을 색인 레지스터로 읽어 옴
          - 색인 주소지정 모드를 사용해서 배열 요소에 접근
          - 색인이 바뀌었다면 다시 변수에 저장

###### [배열](#배열)
###### [Top](#top)

<br/>
<br/>

# 다차원 배열
  - 각 차원의 길이가 일정한 배열
  - 메모리에서 1차원 배열과 다른 점이 없음
    - 여전히 연속된 메모리에 저장
    - N차 배열은 N-1차 배열을 여러 개 순서대로 나열한 것
  - 색인으로부터 요소의 위치를 찾는 계산만 달라질 뿐
    - base주소 + offset으로 접근
    - 고수준 언어의 배열 접근 연산자가 이 offset을 대신 계산해 줄 뿐!
  - 2차원 배열의 요소 위치
    - [x,y]의 주소 = 시작 주소 + 1D 배열크기 * y + x
  - 3차원 배열의 요소 위치
    - [x,y,z]의 주소 = 시작 주소 + 2D배열크기 * z + 2D 배열 접근법

###### [배열](#배열)
###### [Top](#top)

<br/>
<br/>

***

# 지시문
  - 어셈블러의 기능
  - 어셈블 중에 어셈블러가 뭘 해야 하는지 알려줌(전처리 단계)
    - 어셈블러라는 프로그램이 해주는것
  - 종류
    - 코드 위치 정보 : .ORG
    - 데이터 embed : .BYTE, .WORD
    - 제어 : .PROCESSOR, .SUBROUTINE
    - 파일 인클루드
    - 매크로도 지시문의 일부

###### [지시문](#지시문)
###### [Top](#top)

<br/>
<br/>

***

# 6502함수
  - 어셈블리 프로그래밍의 전통적인 조언
    - 기본적으로 함수를 작성하지 말것
      - 함수 호출과 반환에 드는 오버헤드가 꽤 됨
      - 그 대신 코드 복붙을 선호할 것
      - 소형 제어 프로그램은 구조가 크게 복잡하지 않음
    - 정 코드 중복을 막고 싶다면 함수 대신 매크로를 사용
    - 아주 예외적인 경우만 함수를 작성할 것
  - 함수를 호출할때, 함수 시작 주소로 이동후에, 어떻게 다시 호출했던 주소로 돌아오는가?
    - jmp 니모닉은 절대주소 지정으로써 어셈블 할때 이미 확정되기 때문에 안된다. 해결은 실행 도중에 알아야 하는 상황이 발생한다
      - 간접 참조를 사용한다

<br/>

  - [간접 참조(indirection)](#간접-참조indirection)
  - [지역라벨](#지역라벨)
  - [함수 사용시, 인자 전달 방법](#함수-사용시-인자-전달-방법)
  - [함수에 매개변수가 여럿 있는 경우는?](#함수에-매개변수가-여럿-있는-경우는)
  - [스택 원상 복구 방법](#스택-원상-복구-방법)
  - [함수의 반환값](#함수의-반환값)
  - [정리 : 근래 고수준 언어의 함수 호출 방법](#정리--근래-고수준-언어의-함수-호출-방법)
  - [함수 호출에 드는 비용](#함수-호출에-드는-비용)
  - [바이트크기, 유지보수성, 성능](#바이트크기-유지보수성-성능)
  - [매크로 함수](#매크로-함수)
  - [6502의 간접 참조 주소지정 모드](#6502의-간접-참조-주소지정-모드)
  - [배열의 배열](#배열의-배열)
  - [함수 오버로딩, 기본값 인자, 함수 포인터](#함수-오버로딩-기본값-인자-함수-포인터)

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 간접 참조(indirection)
  - 피연산자로 제시된 주소에서 읽은 주소, 그곳에 가서 값을 읽어오는 행위
  - 역참조 라고도 함
  - 고수준 언어에서의 포인터
    - C/C++의 포인터
    - Java, C#에서의 개체 레퍼런스
    - 개체 지향 언어에서의 다형적 함수 호출
    - 등
  - 절대 간접 주소지정모드는 “jmp” 니모닉만 지원한다..!
    - jmp retaddr = retaddr주소로 점프해라
    - jmp (retaddr) = retaddr값에 있는 주소로 가서 거기에 그 주소로 점프해라

#a.asm
~~~c
retaddr=$80
out=$4000
column=$4001

    ldy #0

    ...

    ldx #<op2
    stx retaddr
    ldx #>op2
    stx retaddr+1
    jmp print

op2:

    ...

    ldx #<op3
    stx retaddr
    ldx #>op3
    stx retarder+1
    jmp print

op3:

    ...

    ldx #<end
    stx retaddr
    ldx #>end
    stx retarder+1
    jmp print

end:
    jmp end

print:
    lda #'.
    sta out

    iny
    sty column

    jmp (retaddr)    <- 이렇게 간접 참조로 해야 한다..!!!
~~~

  - jmp(retaddr)로 회귀하는 것의 문제
    - 1. 함수 속에서 다른 함수를 호출할 수 없음
      - 어떤 함수 안에서 다른 함수를 또 호출할때, 돌아올 주소에 그 다음 돌아올 함수위치가 저장 되어 버림
    - 2. 재귀함수가 동작하지 않음
  - 해법
    - 1. 함수마다 돌아올 retaddr을 따로 만들어준다 -> 하지만 재귀함수는 해결 할 수 없다
    - 2. 스택을 사용하여 회귀주소들을 저장 한다
      - pha : A 레지스터 값을 스택에 push
      - pla : 스택에서 A 레지스터로 pop
      - 모든 문제를 해결 할 수 있음

#a.asm
~~~c
// 스택을 사용하여 회귀주소들을 저장해 사용하는 예시1(인자가 있는 함수 안의 함수 사용시)

retaddr=$80

func0:
      ...
      lda #<ret0
      pha
      lda #>ret0
      pha
      jmp func1
ret0:
      ...
      pla
      sta retaddr+1
      pla
      sta retaddr
      jmp (retaddr)
func1:
      ...
      lda #<ret1
      pha
      lda #>ret1
      pha
      jmp func2
ret1:
      pla
      sta retaddr+1
      pla
      sta retaddr
      jmp (retaddr)
func2:
      ...
      pla
      sta retaddr+1
      pla
      sta retaddr
      jmp (retaddr)
~~~

<br/>

#a.asm
~~~c
// 스택을 사용하여 회귀주소들을 저장해 사용하는 예시2(재귀함수)

retaddr=$80

      lda #<end
      pha
      lda #>end
      pha
      jmp func
end:
      jmp end
func:
; 재귀 탈출 조건
      cpy #$0A
      beq efunc

      iny

      ...

      lda #<ret
      pha
      lda #>ret
      pha
      jmp func
ret:
      ...
efunc:
      pla
      sta retaddr+1
      pla
      sta retaddr
      jmp (retaddr)
~~~

  - 하지만 위의 방식을 사용하지않는다, 함수는 매우 일반적으로 사용되는 기능이니, 함수에 관련된 니모닉이 따로 제공 된다
  - 위쪽에 소개한 스택을 사용한 방식과 똑같이 돌지만, 하드웨어 적으로 좀더 사이클을 감소시켜서 만든 것이라고 생각하면 된다
    - jsr : 함수를 호출할 때 사용(서브 루틴으로 점프)
      - 1. jsr 명령어의 마지막 바이트 주소를 push
      - 2. 함수 위치로 점프
    - rts : 함수에서 돌아올 때 사용(서브루틴에서 회귀)
      - 1. 스택에 저장된 주소를 pop하여 PC로 불러옴
      - 2. PC를 1 증가

#a.asm
~~~c
// jsr, rts예

out=$4000
column=$4001

     ldy #0

     ...

     jsr print

     ...

     jsr print

     ...

     jsr print
end:
     jmp end

print:
     lda #'.
     sta out

     iny
     sty column

     rts
~~~

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 지역라벨
  - 라벨 앞에 . 이 들어가게 되면 “지역 라벨”이 된다. 전역 라벨은 현재 어셈블리 어디에도 하나밖에 없지만, “지역 라벨”은 여러개 존재 할 수 있으며, 그것은 .SUBROUTINE을 맨위에 씀으로써 구분된다
    - EX) .SUBROUTINE안에 .ret으로 가는 jmp니모닉 있다고 했을경우, 다른 곳에 있는 .ret라벨로 이동하는 것이 아니라, 현재 위치에 같은 곳에 있는 .SUBROUTINE안에 있는 .ret라벨로 이동하게 된다는 뜻 

#a.asm
~~~c
mul:
    .SUBROUTINE
    lda #0
    ldx p01

    clc

.loop:
    beq .ret

    adc p00
    dex
    jmp .loop
.ret:
    rts
~~~

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 함수 사용시, 인자 전달 방법
  - 회귀주소를 전달해 줄 때 사용한 방법과 비슷
    - 1. 각 서브루틴에서 사용하는 레지스터들을 Page 0에 정의
    - 2. 스택을 중간 저장소로 사용
      - 스택 메모리를 사용한다는 의미 :
        - 프로그램 작성 시에 특정할 수 없는 주소가 있음
          - 소형 제어 프로그램에서는 흔하지 않은 경우
        - 하지만 메모리에 접근하는 순서는 알고 있을때
          - 그 순서대로 스택 메모리에 전달할 데이터를 넣으면 됨
          - 함수에서는 역순으로 데이터를 꺼내 씀

#a.asm
~~~c
// 스택을 사용하여 인자 전달하기
PG1=$0100

    lda #4  ; a레지스터에 4를 push
    pha ; a레지스터에 있는것을 스택에 push(0x01FF)
    jsr func ; 함수 주소를 스택에 push, push(0x01FE, 0x01FD)
    pla ; 0x01FF에 있던 스택을 정리해 준다
func:
    tsx ; 현재 스택포인터를 X에 push(0x01FC)

    lda PG1+3, x <- 이렇게 함으로써 맨 처음 스택에 넣었던 0x04데이터를 가져온다 ;  0x0100 + 0x03 + 0xFC = 0x01FF
    clc
    lsr
    adc #1

    rts ; 0x01FE, 0x01FD 주소인 함수 주소를 받아서 되돌아 간다
~~~

  - pha : A레지스터 값을 스택에 push 할 때 사용
    - 1. A레지스터 값을 스택으로 push
    - 2. 스택 포인터 1 감소
  - pla : 스택에서 A레지스터로 pop 할 때 사용
    - 1. 스택에서 A레지스터로 pop
    - 2. 스택 포인터 1증가

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 함수에 매개변수가 여럿 있는 경우는?
  - 호출자(caller)가 인자를 차례대로 스택에 넣어줌
  - 함수에서는 그 인자를 반대순서로 접근해서 사용
  - 호출자와 함수 사이에 순서에 대한 합의가 있어야 함
  - 함수가 인자들을 언제나 확실히 찾을 수 있어야 함
    - 일반적으로는 인자를 스택에 push할때 오른쪽에서 왼쪽으로 인자를 넣고, 그렇다면 함수 내에서 스택에 빼 쓸때는, 왼쪽에서 오른쪽으로 사용하는게 일반적이다
    - 함수 호출후, pla를 통해서 스택을 정리 하는데 있어서, 함수 내에서 정리 할 수도 있고, 함수 호출자가 정리 할 수 도 있는것 처럼 이것 또한 함수 호출 규약을 정해야 한다

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 스택 원상 복구 방법

#a.asm
~~~c
// 인자가 늘어날 수록 pla를 많이 써야 하기 때문에 사이클 및 바이트가 늘어난다
    lda #3
    pha
    lda #2
    pha
    lda #1
    jsr func ; func(1,2,3)
    pla
    pla
    pla

end:
    jmp end
// 바이트 : 3
// 사이클 : 12
~~~

<br/>

#a.asm
~~~c
// 인자가 늘어나도 바이트 및 사이클이 늘어나지 않는다
    lda #3
    pha
    lda #2
    pha
    lda #1
    jsr func ; func(1,2,3)
    tsx
    txa
    adc
    tax
    txs

end:
    jmp end
// 바이트 : 6
// 사이클 : 10
~~~

<br/>

#a.asm
~~~c
// 인자가 늘어나면 inx가 많아지기 때문에 바이트 및 사이클이 늘어난다
    lda #3
    pha
    lda #2
    pha
    lda #1
    jsr func ; func(1,2,3)
    tsx
    inx
    inx
    inx
    txs

end:
    jmp end
// 바이트 : 5
// 사이클 : 10
~~~

  - 모든 인자를 스택으로 전달하면 좋은 점
    - 함수 호출자가 함수 내부 구현에 대해 알 필요가 없음
    - 재귀 함수를 포함한 연쇄적인 함수 호출도 자유로움
    - 각 함수 속에서 페이지 0을 자유로이 사용할 수 없음
      - 지역 변수
      - 단 다른 함수 호출 전에 그 페이지 0의 내용을 잘 보관해 놔야 함
  - 함수안에서 다른 함수를 호출하는 경우
    - 현재 사용 중인 지역 변수를 스택에 보존후, 회귀하고 돌아와 스택에 보존된 지역 변수를 다시 가져와 연산한다

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 함수의 반환값
  - 전달과정
    - 1. 함수 내부 : rts 전에 반환값을 저장
    - 2. 호출자 : 그 값을 꺼내 사용
  - 호출자가 그 반환값을 언제나 확실히 찾을 수 있어야 함
    - 그 위치가 정해져 있어야 함
    - 당연히 여러 가지 방법이 있음(이렇게 많은 방법들이 있기 때문에, 호출 규약 같은 것들을 만들어서 통일 시키려고 함)
      - 페이지 0을 통해 -> 어셈블리 언어의 방향
        - 페이지 0의 서로 다른 주소값 사용시
          - 수동 관리
          - 각 함수별 다른 페이지 0영역 사용
          - 재귀 함수 지원 불가
          - 고성능
        - 페이지0의 항상 같은 주소값으로 리턴값을 받아 올시
          - 재귀 함수 지원 불가
          - 고성능
          - 두개의 함수 리턴값이 필요할경우 하나는 다른 곳에 저장해야함
      - 스택을 통해 -> 현대의 고수준 언어의 범용적 방향
        - 자동 관리
        - 별다른 영역 관리 필요 없음
        - 재귀 함수 지원
        - 범용적
      - A,X,Y 레지스터를 통해(페이지 0을 이용하는 방법과 다르지 않다고 생각하면 된다)

#a.asm
~~~c
// 페이지 0의 서로 다른 주소값 사용시
// 함수마다 다른 페이지 0주소를 사용한다는것

add: ; (0x01, 0x02) - > 0x00 | <A, P>
; ===========================
    clc

    lda $01
    adc $02
    sta $00 ; $00주소에 리턴값 반환

    rts
; ===========================



sub: ; (0x11, 0x12) - > 0x10 | <A, P>
; ===========================
    sec

    lda $11
    sbc $12
    sta $10 ; $10주소에 리턴값 반환

    rts
; ===========================


    lda #2
    sta $01
    lda #4
    sta $02
    jsr add

    lda $00
    sta $11
    lda #3
    sta $12
    jsr sub

    lda $10

    ...

end:
    jmp end
~~~

<br/>

#a.asm
~~~c
// 페이지0의 항상 같은 주소값으로 리턴값을 받아 올시

add: ; (0x01, 0x02) - > ret | <A, P>
; ===========================
    clc

    lda $01
    adc $02
    sta ret ; ret주소에 리턴값 반환

    rts
; ===========================



sub: ; (0x11, 0x12) - > ret | <A, P>
; ===========================
    sec

    lda $11
    sbc $12
    sta ret ; ret주소에 리턴값 반환

    rts
; ===========================

ret=$00

    lda #2
    sta $01
    lda #4
    sta $02
    jsr add

    lda ret
    sta $11
    lda #3
    sta $12
    jsr sub

    lda ret

    ...

end:
    jmp end
~~~

<br/>

#a.asm
~~~c
// 스택을 통한 반환값 전달


add: ; (s[0], s[1]) - > s[2] | <A, X, P>
; ===========================
    tsx

    clc
    lda PG1+3, x  ; 첫번째 인자
    adc PG1+4, x  ; 두번째 인자
    sta PG1+5, x  ; 반환값 저장

    rts
; ===========================



sub: ; (s[0], s[1]) - > s[2] | <A, X, P>
; ===========================
    tsx

    sec
    lda PG1+3, x
    abc PG1+4, x
    sta PG1+5, x

    rts
; ===========================


PG1=$0100

    pha ; 반환값 자리 ; A레지스터에 뭐가 있던 반환값 공간을 얻기 위해 스택을 확보한다
    lda #4
    pha
    lda #2
    pha
    jsr add
    pla
    pla
; 위와 같이 pla로 스택을 2개 빼면 맨 아래에 반환값이 존재하게 된다

    pla ; 반환값
    tay

    pha ; 반환값 자리
    lda #3
    pha
    tya

    pha
    jsr sub
    pla
    pla

    pla ; 반환값

    ...

end:
    jmp end
~~~

<br/>

#a.asm
~~~c
// 레지스터를 통한 반환값 전달
// 아래는 Y레지스터를 사용한 예

add: ; (0x01, 0x02) - > Y | <A, P>
; ===========================
    clc

    lda $01
    adc $02
    tay  ; 반환값을 y레지스터에 저장

    rts
; ===========================



sub: ; (0x11, 0x12) - > Y | <A, P>
; ===========================
    sec

    lda $11
    sbc $12
    tay  ; 반환값을 y레지스터에 저장

    rts
; ===========================

    lda #2
    sta $01
    lda #4
    sta $02
    jsr add

    sty $11
    lda #3
    sta $12
    jsr sub

    tya ; Y레지스터에 있는 반환겂을 A에 옮기고 다음 함수 리턴값을 받을 준비를 함

    ...

end:
    jmp end
~~~

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 정리 : 근래 고수준 언어의 함수 호출 방법
  - 스택 메모리를 사용하여 함수와 호출자 사이의 데이터를 주고받음
  - 지역 변수도 스택 메모리를 사용
  - x86__fastcall 호출 규약은 8바이트까지 레지스터에 인자를 전달

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 함수 호출에 드는 비용
  - 1. 인자 전달
  - 2. 함수 호출(jsr)
  - 3. 인자 접근 및 연산
  - 4. 반환 값 전달
  - 5. 함수 반환(rts)
  - 결론 : 함수 호출에는 사이클 비용이 많이 든다!!
  - 하지만, 같은 함수를 여러번 호출할 수 있는 경우에는, 속도는 느리지만, 바이트 비용을 아낄 수가 있다
  - 6502 같은 환경에서도 예외적으로 함수가 허용되는 경우
    - 함수 코드가 꽤 길고 그 함수를 자주 호출하는 경우
      - 코드 바이트를 줄일 수 있음
      - 코드 변경이 용이

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 바이트크기, 유지보수성, 성능
  - 이렇게 3가지를 고려해서 코드를 짜야 한다
  - 이렇게 3가지를 전부 가져갈 수 있게 해주는 기능이 매크로 함수가 된다

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 매크로 함수
  - 어셈블러의 기능
  - 기본적으로 텍스트 복붙 기능
  - 특정 부분을 매개변수화 해줄 수 있음
    - 따라서 보기에는 함수처럼 작동
    - 실제로는 일부를 약간 변형하여 복붙하는 코드
  - C의 매크로 함수
    - #define 을 통해 사용하는 부분을 매크로 함수라고 한다
    - 전처리기를 거치면서 복붙해주게 된다

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 6502의 간접 참조 주소지정 모드
  - 1. (a) : 절대 간접 참조 모드 -> jmp니모닉만 사용 가능
  - 2. (zp), y : 간접 참조 후 색인 (indirect indexed)
    - zp주소로 가서, 그 주소를 읽어온 후, y만큼 증가시킨 것을 실제로 얻어 온다
    - 0페이지에서 읽어 온다는 것을 기억 하자! ex) 80주소라면 0080에서 읽어오게 된다는것
    - adc, sbc, lda, sta, and, ora, eor, cmp가 지원
  - 3. (zp,x) : 색인 후 간접 참조 (indexed indirect)
    - zp주소로 가기 전에, x를 더한 zp주소를 가서 읽어 온다
    - 0페이지에서 읽어 온다는 것을 기억 하자! ex) 80주소라면 0080에서 읽어오게 된다는것
    - adc, sbc, lda, sta, and, ora, eor, cmp가 지원
  - 간접 주소지정 모드는 느리다(= (zp,x), (zp),x)
    - a모드 보다 최대 50% 더 걸림
    - zp모드보다 최대 100% 더 걸림
    - 따라서 정말 필요한 경우만 쓰기
      - 이거 아니면 동작 안 할때
      - 속도 손해를 보더라도 바이트를 줄여야 할 때
      - 코딩양을 왕창 줄일 수 있을 때(함수 재활용)

#a.asm
~~~c
// (zp),y
ldy #2
lda ($80), y
// 85라는 값을 가져옴

// (zp, x)
ldx #2
lda ($80, x)
// A5라는 값을 가져옴

0x0080 00 80 08 80
0x8000 A5 70 85 90
0x8008 A5 06 C9 9B
~~~

<br/>

#a.asm
~~~c
// 문자열 복사 함수(zp), y

pdst=$00
psrc=$02

strcpy:  ;(pdst,psrc)  <A, P, (pdst)>
;========================================
; summary: (psrc)에서 (pdst)로 문자열 복사
;
; arguments: pdst
;	         psrc
;
; modifies:    (pdst)
;
;========================================

strcpy:
    .SUBROUTINE
    ldy #$FF

.loop:
    iny
    lda (psrc), y
    sta (pdst), y
    bne .loop

    rts
;========================================
~~~

<br/>

#a.asm
~~~c
// 문자열 복사 함수(스택 사용)

str=$1000
copy=$1010
PG1=$0100


    …

    lda #<str
    pha
    lda #>str
    pha
    lda #<copy
    pha
    lda #>copy
    pha
    jsr strcpy

    …

end:
    jmp end

strcpy:  ;(pdst,psrc)  <A, P, (pdst)>
;========================================
; summary: (psrc)에서 (pdst)로 문자열 복사
;
; arguments: pdst
;	         psrc
;
; modifies:    (pdst)
;
;========================================

    .SUBROUTINE
vsrc=$00
vdst=vsrc+2
vretaddr=vdst+2
POPCNT=vretaddr+2-vsrc
    ldx #POPCNT-1
.poploop   ; 여기서 스택에 들어가 있는 6개의 주소를 0페이지에 차례대로 저장함
    pla
    sta vsrc, x
    dex
    bpl .poploop
    ldy #$FF

.loop:
    iny
    lda (vsrc), y
    sta (vdst), y
    bne .loop


    ; 스택 복구 ; 함수가 끝나기 전에 함수 종료후 돌아갈 주소는 스택에 있어야하기 때문에
    lda vretaddr
    pha
    lda vretaddr+1
    pha

    rts
;========================================
~~~

<br/>

#a.asm
~~~c
// swap() 함수

swap: ;(p0, p1) <A, X, Y, P, (p0), (p1)>
;===============================
; (p0)와 (p1)의 값 교환
;===============================

    ldy #0

    lda (p0), y
    tax
    lda (p1), y
    sta (p0), y

    txa
    sta (p1), y

    rts
;===============================
~~~

###### [6502함수](#6502함수)
###### [Top](#top)

<br/>
<br/>

# 배열의 배열
  - 다른 배열의 포인터들을 저장하는 배열
    - 배열 : 메모리 덩어리의 시작 주소를 가리키는 포인터
    - 배열의 배열 : 각배열의 첫째 주소를 가리키는 포인터를 저장한 배열

#a.asm
~~~c
// 스택에 문자열 복사하기

PG1=$0100
len=estr-str
vstr=$00

    .ORG $C000, 0
str:
    .BYTE "abc"
    .BYTE 0 ; 널 문자
estr:

; 스택에 문자열 저장
    ldx #estr-str-1
    pushloop:
    lda str, x
    pha
    dex
    bpl pushloop

; 현재 스택 포인터 저장
    tsx
    stx vstr
    ldx vstr
upcloop:
    lda PG1+1, x
    beq exit

    and #%11011111  ; A레지스터에 있는 것을 대문자로 바꿔줌
    sta PG1+1, x
    inx
    jmp upcloop
exit:
; 스택 복구
    lda vstr
    clc
    adc #estr-str
    tax
    txs
~~~

###### [함수](#함수)
###### [Top](#top)

<br/>
<br/>

# 함수 오버로딩, 기본값 인자, 함수 포인터
  - 함수 오버로딩
    - 6502에는 없음
    - 그냥 주소가 다른 함수들로 만들어야 함
      - 시작 주소 라벨도 다름
    - 고수준 언어는 컴파일러가 알아서 다른 함수로 만들어 줌
  - 기본값 인자
    - 6502에는 없음
    - 두 가지 방법
      - 1. 호출자에서 기본값 인자를 직접 전달하는 코드를 작성
      - 2. 함수를 2개 만듦
        - 함수 내부에 기본값이 하드코딩 된 함수
        - 인자를 2개 받는 함수
      - C#은 1번 방법을 씀
  - 함수 포인터
    - 6502에서는 결국 jmp(a)
    - 고수준 언어의 컴파일러가 매개 변수 목록과 반환형이 같은지 확인

###### [함수](#함수)
###### [Top](#top)

<br/>
<br/>

***

# 매크로
  - [매크로예시](#매크로예시)
  - [.IF, .ELSE, .ENDIF](#if-else-endif)
  - [.IFCONST, .IFNCONST](#ifconst-ifnconst)
  - [.REPEAT](#repeat)
  - [.INCLUDE](#include)
  - [null 포인터](#null-포인터)

###### [매크로](#매크로)
###### [Top](#top)

<br/>
<br/>

# 매크로예시
  - 지시문 중 하나(=어셈블러의 기능)
  - 어셈블 과정에서 직접 함수 코드를 복붙 해줌
    - 사실 함수 외에 아무 코드나 복붙 가능
    - C의 매크로와 작동법은 동일
  - 어셈블리어에는 inline함수가 없음
  - 매크로를 쓰면 속도가 빨라진다..!
    - 간접 주소 지정으로 써야 했던 것들을 그렇게 쓰지 않고 사용 할 수 있게 때문에

#a.asm
~~~c
// 매크로 예1
// .MACRO와 .ENDM처럼 매크로를 사용하는 문법은 어셈블러에 따라 다르니 참고하여야함

str=$1000
copy=$1010

    .MACRO phaddr
    lda #<{1}
    pha
    lda #>{1}
    pha
    .ENDM

    phaddr str
    phaddr copy
    jsr strcpy

end:
    jmp end
~~~

  - 현재 아래에 있는 코드를 어셈블 하게 되면, .notfound와 .loop라는 라벨이 각각 2개 나오기 때문에 jmp를 할때 .SUBROUTINE이 없기때문에 어디로 뛰어야 할지 모를 수 있다.
    - 하지만 매크로 함수는 전부 각각 .SUBROUTINE이 있는 것처럼 지역으로 되어 있기 때문에 신경 쓰지 않아도 된다(어셈블러가 알아서 해주는것)

#a.asm
~~~c
// 매크로 예2
// Indexof()

    idxof str, ‘e
    ; printx 호출
    …

    idxof str, ‘l
    ; printx 호출
    …

end:
    jmp end

    .ORG $C000, 0
str:
    .BYTE “Hello World”
    .BYTE 0 ; 널문자

; 문자열에서 문자가 첫 번째로 등장하는 위치를 반환
    .MACRO idxof ; (str, char) - > X | <A, P>
    ldx #$00 ; X = 결과
.loop:
    lda {1}, x
    beq .notfound

    cmp #{2}
    beq .exit

    inx
    jmp .loop
.notfound:
    ldx #$FF
.exit:
    .ENDM
~~~

<br/>

#a.asm
~~~c
// 매크로 예3
// printX()

out=$4000
column=$4001
vstr=$10

    idxof str, 'e
    printx

    idxof str, 'l
    printx

end:
    jmp end

    .ORG $C000, 0
str:
    .BYTE "Hello World"
    .BYTE 0  ; 널 문자

; X를 LCD로 출력
    .MACRO printx ; () <A, X, Y,, P, vsrt~vstr+10>
; 1. 정수 X를 아스키 문자열(vstr)로 변환
; 2. LCD 커서의 열 위치를 Y에 저장
    ...

    ldx

.loop:
    inx
    iny
    lda
    sta
    sty
    bne
    .ENDM


; 문자열에서 문자가 첫 번째로 등장하는 위치를 반환
    .MACRO idxof ; (str, char) - > X | <A, P>
    ldx #$00 ; X = 결과
.loop:
    lda {1}, x
    beq .notfound

    cmp #{2}
    beq .exit

    inx
    jmp .loop
.notfound:
    ldx #$FF
.exit:
    .ENDM
~~~

<br/>

#a.asm
~~~c
// 매크로 예4
// swap()

num0=$3000
num1=$3001

    swap num0, num1

    ...

end:
    jmp end

; n0와 n1의 값 교환
    .MACRO swap  ;(n0, n1) <A, P, X, n0, n1>
    lda {1}
    tax
    lda {2}
    sta {1}

    txa
    sta {2}
    .ENDM
~~~

###### [매크로](#매크로)
###### [Top](#top)

<br/>
<br/>

# .IF, .ELSE, .ENDIF
  - 소스 파일의 일부를 조건부로 최종 코드에 넣어 줌

#a.asm
~~~c
.IF <표현식>
	; TRUE일 때 들어가는 코드
.ELSE
	; FALSE일 때 들어가는 코드
.ENDIF
~~~

  - 아래와 같이  해당되지 않는 오퍼레이션이 들어오게 되면,  ERROR: ADD OPERATOR! 이 복사되어 붙여지게 되는데, 그렇게 되면 컴파일 에러가 발생하게 된다. 이것은 마치 고수준에서 asser를 사용하는 것과 같다

#a.asm
~~~c
// .IF, .ELSE, .ENDIF 예시

v0=$00
v1=$01
out=$4000
column=$4001
vstr=$10

; 사용자에게 두 수를 입력받아
; v0와 v1에 저장

    calc v0, '+, v1

    printa

    calc v0, '-, v1

    printa

    calc v0, '*, v1

    printa

end:
    jmp end

; A를 LCD로 출력
.MACRO printa ; () <A, X, Y, P, vstr~vstr+10>
; 1. 정수 A를 아스키 문자열(vstr)로 변환
; 2. LCD 커서의 열 위치를 Y에 저장
...

    ldx #$FF

.loop:
    inx
    iny
    lda vstr, x
    sta out
    sty column
    bne .loop
.ENDM


; A = a op b
    .MACRO calc ; (a, op, b) - > A | <X, P>
    .IF {2} = '+
        clc
        lda {1}
        adc {3}
    .ELSE
        .IF {2}='-
            sec
            lda {1}
            sbc {3}
        .ELSE
            .IF {2}='*
	        ; A = a x b
	        ...
            .ELSE
	        ERROR: ADD OPERATOR!
            .ENDIF
        .ENDIF
    .ENDIF
.ENDM
~~~

###### [매크로](#매크로)
###### [Top](#top)

<br/>
<br/>

# .IFCONST, .IFNCONST
  - 소스 파일의 일부를 A정의 여부에 따라 조건부로 최종 코드에 넣어 줌

#a.asm
~~~c
.IFCONST A
	; A가 정의되어 있을 때 들어가는 코드
.ENDIF

.IFNCONST A
	; A가 정의되지 않았을 때 들어가는 코드
.ENDIF
~~~

  - 컴파일 할때  “dasm add.asm -f3 -oadd.bin -DDBGPRINT”를 넣어 줘야 아래의 코드를 같이 컴파일 하게 된다

#a.asm
~~~c
// .IFCONST, .IFNCONST예시
// 디버그용 print()

; A를 LCD로 출력
    .MACRO printa ; () <A, X, Y, P, vstr~vstr+10>
        .IFCONST DBGPRINT
; 1. itoa(A)를 호출하여 주소 vstr 문자열 저장
; 2. LCD 커서의 열 위치를 Y에 저장
        ...

            ldx #$FF

.loop:
            inx
            iny
            lda vstr, x
            sta out
            sty column
            bne .loop
        .ENDIF
    .ENDM
~~~

  - 아래와 같이 nop 2개를 같이 컴파일 하기 위해서는 “dasm add.asm -f3 -oadd.bin -DDBGPRINT -DSCRDELAY” 을 하면 된다

#a.asm
~~~c
// .IFCONST, .IFNCONST예시
// 디버그용 print()

; A를 LCD로 출력
    .MACRO printa ; () <A, X, Y, P, vstr~vstr+10>
        .IFCONST DBGPRINT
; 1. itoa(A)를 호출하여 주소 vstr 문자열 저장
; 2. LCD 커서의 열 위치를 Y에 저장
        …
            .IFCONST SCRDELAY
                nop
                nop
            .ENDIF
            ldx #$FF

.loop:
            inx
            iny
            lda vstr, x
            sta out
            sty column
            bne .loop
        .ENDIF
    .ENDM
~~~

###### [매크로](#매크로)
###### [Top](#top)

<br/>
<br/>

# .REPEAT
  - 코드본문을 count 수 만큼 최종 코드에 복붙해 줌

#a.asm
~~~c
.REPEAT <count>
	; 코드 본문
.REPEND
~~~

  - 아래가, .REPEAT문을 사용하는 방법이며, 컴파일시 “dasm add.asm -f3 -oadd.bin -DDBGPRINT -DSCRDELAY=1000” 와 같이 사용하여 컴파일 한다

#a.asm
~~~c
// .REPEAT 예시
// 디버그용 print()

; A를 LCD로 출력
    .MACRO printa ; () <A, X, Y, P, vstr~vstr+10>
        .IFCONST DBGPRINT
; 1. itoa(A)를 호출하여 주소 vstr 문자열 저장
; 2. LCD 커서의 열 위치를 Y에 저장
        …
            .REPEAT SCRDELAY
                nop
            .REPEND
            ldx #$FF

.loop:
            inx
            iny
            lda vstr, x
            sta out
            sty column
            bne .loop
        .ENDIF
    .ENDM
~~~

###### [매크로](#매크로)
###### [Top](#top)

<br/>
<br/>

# .INCLUDE
  - .INCLUDE <파일이름>
  - C의 #include와 동일하게 동작(=텍스트 복붙)
  - 기능 및 데이터를 여러 파일에 나눠서 개발할 수 있음
    - 그 기능 및 데이터를 사용하는 곳에서 인클루드
    - 어셈블 결과는 원래 한 파일이었던 것과 동일

#a.asm
~~~c
// .INCLUDE 예: 메인 코드
    .INCLUDE "macros.asm"

    ...
    phaddr str
    phaddr copy
    jsr strcpy

    setaddr p0, num0
    setaddr p1, num1
    jsr swap

end:
    jmp end

    .INCLUDE "lib.asm"
~~~

###### [매크로](#매크로)
###### [Top](#top)

<br/>
<br/>

# null 포인터
  - 6502에서 0은 유효한 메모리 주소
    - 제로 페이지의 첫 번째 주소!
  - null포인터는 하드웨어가 아닌 개념적인 정의
    - 어느 메모리 공간도 가리키지 않음을 의미하는 감시값
    - null포인터 개념을 사용하면 주소0은 사용하지 않음
  - C언어에서 하드웨어로 그대로 대칭되지 않는 개념 중 하나

###### [매크로](#매크로)
###### [Top](#top)

<br/>
<br/>

***

# 6502주변기기 연결
  - 따로 주변기기용 핀이 없음
  - 데이터 핀8개, 주소 핀 16개가 전부
  - 16비트 주소 공간의 일부를 주변기기용으로 사용
    - 메모리 맵 입출력(memory-mapped I/O)
  - 메모리 맵 입출력(memory-mapped I/O)
    - CPU의 주소 공간을 분할해서 메모리와 주변기기에 할당하는 방법
      - 메모리 접근에 사용하는 CPU명령어를 주변기기 제어에 그대로 사용
    - 메모리에 사용할 수 있는 주소 공간이 줄어듦
      - 일부는 주변기기용으로 reserved
      - 남은 부분만 메모리에 사용가능
    - 주소 공간 분할은 컴퓨터 설계자의 마음
      - 프로그래머는 그에 맞게 코딩해야 함
  - 포트 맵 입출력(port-mapped I/O)
    - 메모리 맵 입출력과 반대되는 개념
    - 입출력에 필요한 주소공간이 별도로 있음
      - 따라서 주소공간만큼 메모리 접근 가능
      - 데이터 입출력용 CPU명령어도 따로 있음
    - 구현 방법
      - 1. 입출력 <-> 메모리 전환 핀
      - 2. 전용 버스

###### [6502주변기기 연결](#6502주변기기 연결)
###### [Top](#top)

<br/>
<br/>

***

# X86-16 _ intel 8088
  - 1978년 인텔이 16비트 CPU 8086용으로 개발한 아키텍처
    - 그에 맞는 명령어 집합도 제공
  - 현재까지 가장 많이 사용하는 데스크톱 CPU 아키텍처
    - “시작” : 1983년 IBM XT 컴퓨터에 탑재된 8088
    - ~현재 : 내 컴퓨터에 탑재된 64 비트 인텔/AMD CPU
  - 1985년 80386과 함께 32 비트로 확장
    - 명령어 집합도 같이 확장!
  - 2003년 AMD 옵테론과 함께 64 비트로 확장
    - 명령어 집합도 같이 확장!
  - 16비트 이후로 지금까지, 이전에 있었던 16비트 명령어를 거의 그대로 또한 사용하고 있고, 비트가 커지면서 명령어 집합도 같이 많아 졌을 뿐
  - OS, BIOS
    - OS, BIOS에서 제공하는 함수를 사용한다는 것은, 그곳으로 주소를 점프해서 무언가를 하고 다시 돌아온다는 그런 간단한 의미가 된다

<br/>

  - [x86-16개발환경](#x8616개발환경)
  - [MS-DOS의 부팅 순서](#msdos의-부팅-순서)
  - [여러 프로그램 실행의 문제](#여러-프로그램-실행의-문제)
  - [정리 : 프로그래머 관점에서 운영체제란?](#정리--프로그래머-관점에서-운영체제란)
  - [컴파일 환경 세팅 하기](#컴파일-환경-세팅-하기)
  - [Hello, x86! 출력하기](#hello-x86-출력하기)
  - [변수 및 초기화](#변수-및-초기화)
  - [8088의 레지스터](#8088의-레지스터)
  - [피연산자 종류](#피연산자-종류)


###### [X86-16 _ intel 8088](#x8616--intel-8088)
###### [Top](#top)

<br/>
<br/>

# x86-16개발환경
  - MS-DOS에뮬레이터
  - 어셈블러 :  MASM 6.11
    - 1991년 출시
  - 디버거 : CodeView(CV)
    - 에뮬레이터 안에 존재함

###### [X86-16 _ intel 8088](#x8616--intel-8088)
###### [Top](#top)

<br/>
<br/>

# MS-DOS의 부팅 순서
  - 순서1
    - 8088이 리셋됨
    - 리셋 벡터(0xFFFF0)에 있는 명령어를 실행
      - 8088이 강제하는것
      - 1MB에서 16 바이트 아래
      - 보통 ROM BIOS 어딘가로 점프하는 명령어
    - 리셋 벡터로 가서 어딘가로 점프해서 프로그램을 실행하는데, 그것이 BIOS나 운영체제가 되는것!
  - 순서2
    - ROM BIOS가 초기화 루틴을 실행
    - 설치된 장치 확인
    - 설치된 메모리 확인(1MB 공간까지)
    - 장치들을 테스트
테스트 중 문제가 있었다면 사용자에게 보고
  - 순서3
    - 인터럽트 벡터를 초기화[0x00000, 0x003FF]
    - ROM BIOS 데이터를 RAM에 복사
    - 부팅 가능한 장치가 있는지 확인
      - 없으면 새 부팅 장치를 설치하라고 말함
  - 순서4
    - ROM로더가 운영체제 로더를 RAM에 복사
      - low memory에 복사하지 않음
      - 실행이 끝나면 사라질 코드이기 때문
    - 운영체제 로더 코드로 제어권을 넘김
      - 운영체제 로더를 실행한단 뜻
      - 사실상 그 위치로 점프하는 게 전부
      - ROM BIOS의 초기화 루틴은 여기서 끝
  - 순서5
    - 운영체제 로더가 다음 부분을 RAM에 복사
      - 이때 ROM BIOS의 기능을 이용
      - 그 기능 접근은 인터럽트 벡터를 통해
    - 그리고 제어권을 넘김
      - 여기까지가 운영체제 로더의 역할
      - 이후 운영체제 로더 코드는 메모리에서 제거
  - 순서6
    - DOS초기화
    - 메모리 위치를 바꿈
      - 계속 필요한 내용만 los memory에
    - 인터럽트 벡터 일부를 업데이트
      - BIOS의 기능을 DOS 기능으로 교체
    - 셀(shell)(=CMD)을 RAM에 복사 후 제어권 넘김

###### [X86-16 _ intel 8088](#x8616--intel-8088)
###### [Top](#top)

<br/>
<br/>

# 여러 프로그램 실행의 문제
  - 컴퓨터 자원을 공유해야함
    - 파일
    - RAM 등
  - 각 프로그램의 자원을 보호할 장치가 필요
  - 8088에는 이런 장치가 없음
    - 코드 속 메모리 주소와 하드웨어 주소의 1:1대응
    - 다른 프로그램의 메모리를 덮어쓸 수 있음
    - 심지어는 MS-DOS커널 메모리도..
  - 보호모드(protected mode)
    - 80286에 처음 탑재
      - 16MB 메모리 지원이 가장 큰 효과
    - 자원 보호는 80386부터 제대로 사용
    - 권한 수준
      - level 0 : 운영체제 커널
      - level 3 : 응용 프로그램
    - 시스템 함수 사용 불가
    - 몇몇 어셈블리 명령어는 권한이 필요
    - 보호 모드의 의의
      - 이후 x86 계열 CPU 발전의 초석
      - 응용 프로그램이 보호 모드를 사용할 이유는 별로 없었음
        - 16비트에서 보호 모드를 사용했던 건 과도기
        - 최대 접근 가능 주소 문제는 32 비트에서 거의 해소
      - 운영체제에는 중요한 일이었음
        - 커널 보호
        - 페이징을 통한 가상 메모리 구현 등
      - 요즘은 그냥 운영체제가 제공하는 메모리에서 코딩
        - 마치 컴퓨터 자체 메모리 주소를 사용하는 것처럼

###### [X86-16 _ intel 8088](#x8616--intel-8088)
###### [Top](#top)

<br/>
<br/>

# 정리 : 프로그래머 관점에서 운영체제란?
  - 스스로 부팅 가능한 소프트웨어
  - 다른 프로그램을 실행할 수 있음
    - 해당 운영체제용으로 만든 것만
    - COMMAND.COM도 그런 프로그램 중 하나
  - 이런 프로그램에 다양한 기능을 제공 (=추상화)
    - 실제 모드에서는 인터럽트 벡터를 통해
    - 실제 하드웨어를 제어하는 코드의 위치
      - 장치 드라이버
      - ROM BIOS

###### [X86-16 _ intel 8088](#x8616--intel-8088)
###### [Top](#top)

<br/>
<br/>

# 컴파일 환경 세팅 하기
  - 1. MASM 6.11다운받기
  - 2. DosBox-X설치하기
    - https://dosbox-x.com/ 
    - 설치할 도스 버전을 물어보면 MS-DOS 5.00(디폴트)으로 한다

![20231007_002555](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/214587c9-9464-41cd-b1f1-4135c06b8172)

  - 3. DosBox-X가 설치된 곳에 dosbox-x.conf파일을 텍스트 파일로 열고 수정한다

#dosbox-x.conf.txt
~~~
// T로 마운트 되어 있는 곳은 MASM611\BIN 까지 들어가서 ML.EXE를 통해 명령어를 실행하기 위함
set path    = Z:\;Z:\SYSTEM;Z:\BIN;Z:\DOS;Z:\4DOS;Z:\DEBUG;Z:\TEXTUTIL ;T:\MASM611\BIN

[autoexec] // 도스가 시작되자 마자 명령어가 실행 되는곳
# Lines in this section will be run at startup.
# You can put your MOUNT lines here.
MOUNT A C:\assembly\16bit\16bitsource  // 실행할 소스 파일이 있는곳
MOUNT T C:\assembly\16bit\MASM611-main  // MASM압축 폴더를 푼곳
~~~

  - 4. DOSBox-X를 실행한다

![20231007_002614](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/1b7c6a0a-b8d1-469f-83a0-a55f98910ca5)

  - 5. 소스가 마운트된 A드라이브로 이동한다
    - 명령어 : A:

![20231007_002625](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/aaab583b-4392-4db6-994c-ec25f6d53735)

  - 6. 소스 파일을 컴파일 한다
    - 명령어 : ML /W3 파일명.ASM

![20231007_002633](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/84096285-584a-4e1b-b423-8799be203212)

  - 7. 컴파일된 .com파일을 실행한다
    - 명령어 : 파일명.COM

![20231007_002643](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/09cb0470-b74c-4c63-984b-2c2809c7c8f2)

###### [X86-16 _ intel 8088](#x8616--intel-8088)
###### [Top](#top)

<br/>
<br/>

# Hello, x86! 출력하기

#a.asm
~~~c
TITLE Hello x86 //코드가 뭐하는지 제목을 달 수 있음, 하단에 서브 타이틀도 달 수 있음

.DOSSEG // 언제나 넣어 주자 ㅎ
.8086 // 어셈블리어 코드가 어떤 cpu에서 돌지
.NO87 // 현재는 코 프로세서 사용을 하지 않으니 사용하지 않는 다고 표시 한다
.MODEL TINY // 항상 쓰자! TINY모델은 EXE가 아닌 COM파일을 만들어 준다

.DATA // 데이터가 들어있는 segment라고 알려줌
msg DB "Hello, x86!$" // msg : symbol, DB : 뒤에 바이트 들로 데이터를 넣을 것이다, $ : 문자열 출력할때 요구된다

.CODE // CODE segment라고 알려줌
.STARTUP // main함수라고 알려주는것, 여기 아래부터 처음 시작됨
	; 화면 출력
	mov ah, 09h // mov : 데이터를 이동, ah : 레지스터(h : 16비트의 상위 8비트, l : 하위 8비트, x : 16비트 모두 사용), 09h : h는 16진수, 2진수를 쓰려면 b를 넣으면됨, 8진수는 o를 넣으면됨
	lea   dx, msg // msg가 가리키고 있는 것을 dx에 로드 해라
	int 21h // int : 소프트웨어 인터럽트를 발생, 21번을 처리하는 인터럽트 처리 함수를 호출해 달라고 하는것. ms-dos가 제공하는 서비스를 접근할때는 21번을 대부분 사용하게 됨

// 따라서 위의 3줄은, ah에 들어간 09인 함수 9번을 실행해달라고 하는것(화면에 문자열을 출력함)

	; 프로그램 종료
	mov ah, 4ch
	xor   al,  al  ; 리턴값 0
	int 21h

// 위의 3줄은, 종료 함수인 4ch를 넣고, int 21h로 ms-dos의 함수를 사용하는것, al이라는 리턴코드를 넣어서 종료한다

END // 파일의 마지막이라는것(여기까지 어셈블 하라고 알려줌)
~~~

  - ms-dos의 함수는 어떻게 되어 있을까?
    - ms-dos또한 하드웨어가 어떤 주소값에 연결되어 있고, 어떤 하드웨어를 사용하는지 알 수 없기 때문에 일반적으로 하드웨어에 직접 접근하지 않는다
    - 대부분 BIOS함수를 이용하게 되는데, BIOS는 직접 하드웨어를 연결하기 때문에 그러한 것을 알고 있기 때문이다
    - 그렇다면, 어떤것을 할때, ms-dos함수를 사용하지 않고 BIOS함수를 직접 호출 할 수 도 있다는 의미가 된다
    - 혹은, 하드웨어 주소를 찾아서, 하드웨어 주소에 직접 값을 쓸 수도 있겠다

###### [X86-16 _ intel 8088](#x8616--intel-8088)
###### [Top](#top)

<br/>
<br/>

# 변수 및 초기화
  - 정수
    - DB : byte
      - 1바이트
    - DW : word 
      - 2바이트
    - DD : doubleword
      - 4바이트
    - DQ : quadword
      - 8바이트
    - DF : farword(6바이트)
    - DT : 10-byte (10바이트)
  - 실수
    - DD : IEEE754 32비트 실수
    - DQ : IEEE754 64비트 실수
    - DT : 임시 80비트 실수
  - 배열
    - <개수> DUP (<초기값 [ [, 초기값] ]... >)
      - 초기값을 개수 만큼 반복하라는 의미

#a.asm
~~~c
// 정수
.DATA
byte DB 23  ; 1바이트
short0 DW 12*53  ; 2바이트
short1 DW 1234h  ; 2바이트, h는 16비트기호
int DD 2147483647  ; 4바이트
long DQ 74294967295  ; 8바이트
empty DQ ?  ; 초기화 되지 않은 데이터, 메모리 공간만 차지 한다

num0 DW 1234h
.ALIGN 4  
num1 DB 12h

num2 DW 1234h
.EVEN  ; 2바이트 단위로...?
num3 DB 12h

// 실수
float DD 98.6
double DQ 9.312E - 7
edouble DQ 3EAF3EF274A03CABr  ; 9.312E - 7
ten_byte DT 7.341E9

float2 DD 87453333r  ; 98.6

// 문자열
str0 DB 'Hello DOS', 13, 10, '$'
str1 DB "Hello bios", 0
str2 DB "ab" ; 61 62
str3 DD "ab" ; 62 61 00 00
str4 DD "a"  ; 61 00 00 00

//배열
nums DB 1,2,3,4,5
arry DB 20 DUP (2)
masks DB 10 DUP (30h, 20h, 01h, 90h)
str0 DB 32 DUP ("Hello, x86")
ddd DD 3 DUP (3 DUP (3 DUP (0)))
buffer DB 128 DUP (?)

// 변수에 라벨 달기
// 데이터에 접근하는 방식을 다르게 해줌
barray LABEL BYTE  ; array와 동일
warray LABEL WORD  ; array를 60개의 word로 접근
darray LABEL DWORD  ; array 30개의 doubleword로 접근
qarray LABEL QWORD  ; array 15개의 quadword로 접근
farray LABEL FWORD  ; array 20개의 farword로 접근
tarray LABEL TBYTE  ; array 12개의 10-byte로 접근
array DB 120 DUP (?)  ; 120바이트 크기의 배열

// 포인터 변수
msg DB “Hello, x86”, 0
nearptr DW msg
farptr DD msg
~~~

###### [X86-16 _ intel 8088](#x8616--intel-8088)
###### [Top](#top)

<br/>
<br/>

# 8088의 레지스터
  - 범용 레지스터
    - ah, ax, al : primary accumulator
    - bh, bx, bl : base, accumulator
    - ch, cx, cl : counter, accumulator
    - dh, dx, dl : accumulator, extended accumulator
    - bp : base pointer
    - si : source index
    - di : destination index
    - sp : stack pointer
  - 세그먼트 레지스터
    - cs : code segment
    - ds : data segment
    - es : stack segment
    - ss : extra segment
      - 세그먼트는 16비트의 과도기 적인 것이며, 32비트 부터는 사실상 없는 것과 다름 없다
  - 기타 레지스터
    - flags : flags
    - ip : instruction pointer
  - 상태 레지스터
    - O : Overflow
    - S : Sign
    - Z :  Zero
    - C :  Carry
    - D : Direction
      - 방향을 지정해 주는 플래그(편리하게 만든 니모닉들에게 사용)
    - P : Parity
    - I : Interrupt Enable
    - T : Trap
    - A : Auxiliary carry

###### [X86-16 _ intel 8088](#x8616--intel-8088)
###### [Top](#top)

<br/>
<br/>

# 피연산자 종류
  - 즉시 피연산자
  - 레지스터 피연산자
  - 메모리 피연산자
    - 직접 메모리 피연산자
      - 어셈블 도중에 계산된 메모리 주소
      - 주소를 나타내는 상수나 심볼을 피연산자로 사용 가능
        - 색인 연산자와 상수를 사용한 친근한 모습을 볼 수 있음 (예: table[4])
      - 이진 파일에는 16비트 주소값(오프셋)이 들어감
      - 실행 중에 세그먼트 레지스터와 합쳐 20 비트 주소를 만듦
        - 기본 세그먼트 레지스터는 ds
        - 세그먼트 오버라이트 연산자 (:) 로 변경 가능
    - 간접 메모리 피연산자
      - 4개의 레지스터만 사용 가능
        - 베이스 레지스터 : bx, bp
        - 색인 레지스터 : si, did
      - 베이스와 색인 레지스터를 따로 혹은 함께 사용 가능
      - 변위값(displacement)들을 추가할 수 있음
        - 상수나 직접 메모리 주소
        - 모두 어셈블 도중에 계산되어 이진 파일의 일부가 됨
      - 4개의 간접 메모리 피연산자
        - 1. 베이스 / 색인 레지스터
        - 2. 베이스 / 색인 레지스터 + 변위
        - 3. 베이스 레지스터 + 색인 레지스터
        - 4. 베이스 레지스터 + 색인 레지스터 + 변위

#a.asm
~~~c
// 즉시 피연산자
// 상수를 집어 넣는것
// 피연산자가 곧바로 바이너리에 들어간다

mov bx, 9+3 ; 0C 00
mov cx, CONST+3 ; 0C 00
add num, 3  ; 03
or bx, 12h   ; 12
cmp cx, 00110001b ; 31
int 21h  ; 21 00

.DATA
num DB 5
CONST EQU 9  ; 메모리 공간을 먹지 않고, 어셈블 중에 그대로 복붙을 해준다
~~~

<br/>

#a.asm
~~~c
// 레지스터 피연산자
add ax, bx
mov ds, ax
cmp ah, bh

and num, dx  ; 직접 레지스터 피연산자
sub nums[bx+si], ax  ; 간접 레지스터 피연산자

shl ax, 1
cmp cx, counter

mul bx
pop cx
inc ah

.DATA
num DW 5
nums DW 100 DUP (10)
counter DW 1
~~~

<br/>

#a.asm
~~~c
// 직접 메모리 피연산자
mov nums, ax
mov nums, 3
mov al, BYTE PTR nums  ; 21 01

mov ax, nums[2]  ; 23 01
mov ax, nums+2  ; 23 01
mov ax, nums[TYPE nums * 2]  ; 25 01

mov al, ds:100h
mov ax, ds:100h
mov al, es:num

.DATA
num DB 1
nums DW 1,2,3,4,5 ; nums[0] -> 21 01
~~~

<br/>

#a.asm
~~~c
// 간접 메모리 피연산자
mov bx, OFFSET table
mov di, 2

mov al, [bx] ; ax = 0

mov al, [bx+3] ; ax = 3
mov al, table[di] ; ax = 2

mov al, [bx+di] ; ax = 2

mov al, [bx+di+3] ; ax = 5
mov bx, 0
mov al, table[bx+di] ; ax = 2
mov al, table[bx+di+3] ; ax = 5

.DATA
table DB 1,2,3,4,5,6,7,8,9
~~~

###### [X86-16 _ intel 8088](#x8616--intel-8088)
###### [Top](#top)

<br/>
<br/>

***

# x86-16 니모닉 소개
  - 총81개
  - x86-32에서도 여전히 거의 대부분 지원
  - 대체적으로 6502의 니모닉과 비슷
  - 레퍼런스 보는법
    - 1. flage 바꾸는 것이 있는지
    - 2. cpu에 따라서 각 사이클 수
    - 3. dst, src
    - 4. 예시

![20231007_211053](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/fa950169-9534-4381-802f-cbf3f9a92b1f)


  - [데이터 전송 니모닉](#데이터-전송-니모닉)
  - [데이터 크기 변환 니모닉](#데이터-크기-변환-니모닉)
  - [포인터 로드 니모닉](#포인터-로드-니모닉)
  - [스택 사용 니모닉](#스택-사용-니모닉)
  - [포트 입출력 니모닉](#포트-입출력-니모닉)
  - [덧셈 니모닉](#덧셈-니모닉)
  - [뺄셈 니모닉](#뺄셈-니모닉)
  - [곱셈 니모닉](#곱셈-니모닉)
  - [나눗셈 니모닉](#나눗셈-니모닉)
  - [논리 연산 니모닉](#논리-연산-니모닉)
  - [비트 이동/회전 니모닉](#비트-이동회전-니모닉)
  - [제어 니모닉](#제어-니모닉)
  - [반복문 니모닉](#반복문-니모닉)
  - [문자열 니모닉](#문자열-니모닉)
  - [기타 니모닉](#기타-니모닉)


###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 데이터 전송 니모닉
  - mov : 데이터를 이동
    - src의 데이터를 dst로 이동
    - 대부분 lda와 동일
    - 차이점
      - dst피연산자를 선택할 수 있음
        - 8/16비트 모두 피연산자로 사용 가능
        - 따라서 피연산자를 dst, src로 표기
      - 플래그가 바뀌지 않음

~~~c
mov dh, bh
~~~

  - xchg : 데이터를 교환
    - 두 피연산자의 데이터를 교환
    - dst와 src를 교환

~~~c
xchg cx, dx
~~~

  - lahf : 플래그를 ah 레지스터에 load
    - 플래그의 0~7 비트들을 ah로 복사

~~~c
lahf
~~~

  - sahf : ah를 플래그 레지스터로 store
    - ah를 플래그 레지스터의 0~7비트로 복사

~~~c
sahf
~~~

  - xlat : 테이블 룩업
    - 테이블 룩업을 해주는 니모닉
    - 입력값
      - bx : 테이블 시작 주소
      - al : 색인 값
    - 결과 : al

~~~c
lea bx, table
mov al, 02h
xlat

xlat table2
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 데이터 크기 변환 니모닉
  - cbw : 바이트를 워드로 변환
    - al에 들어있는 signed 바이트를 워드(16비트)로 확장
    - 부호 비트를 ah의 모든 비트에 복사함

~~~c
cbw
~~~

  - cwd : 워드를 더블 워드로 변환
    - ax에 저장된 singed 워드를 더블 워드(32비트)로 확장
    - 부호 비트를 dx의 모든 비트에 복사함

~~~c
cwd
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 포인터 로드 니모닉
  - lea : near포인터를 로드
    - src의 주소를 dst에 저장
      - src : 메모리
      - dst : 레지스터
    - 주소
      - 유효주소 중 오프셋 부분만(16비트)
      - near포인터

~~~c
lea dx, msg
lea bx, pointer
~~~

  - lds/les : far 포인터를 로드
    - src 메모리의 전체 주소를 저장
      - dst 레지스터 : 오프셋
      - ds, es : 세그먼트 값
    - lea와 다르게 오프셋 부분 + 세그먼트 주소 까지 넣어준다
      - lds는 ds에 세그먼트 값을 넣는다
      - les는 es에 세그먼트 값을 넣는다
    - mov를 두번하는 느낌이라고 생각하면 된다

~~~c
lds si, fpointer
les di, fpointer
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 스택 사용 니모닉
  - call : 함수를 호출 -> near호출(16비트)
    - 회귀 뒤 실행할 위치를 스택에 push 후 점프
    - 2바이트

~~~c
call upcase
~~~

  - call : 함수를 호출 -> far호출(함수를 호출하는데 그 호출 주소 위치가 현재에서 16비트보다 멀리 있을경우)
    - 세그먼트 값도 스택에 push(총 4바이트)
    - cs세그먼트를 변경

~~~c
all FAR PTR job
~~~

  - ret/retn/retf : 함수로부터 반환
    - near vs far를 알아야함
      - PROC선언에 NEAR나 FAR를 넣을 수 있음
      - ret에 NEAR를 붙이면 = retn
      - ret에 FAR를 붙이면 = retf
    - 추가로 해제할 바이트를 지정할 수 있음

~~~c
ret
ret NEAR
ret FAR

// 추가로 해체할 바이트 수 지정
ret 2
retn 8
retf 32
~~~

  - int : 소프트웨어 인터럽트 발생
    - 소프트웨어 인터럽트를 발생
    - 피연산자 값에 해당하는 인터럽트 서비스를 호출
      - 피연산자 값 : [0x00, 0xFF] = (0~255)
      - 서비스 함수의 주소는 인터럽트 벡터 테이블(IVT)에 저장
      - IVT위치 : [0x00000, 0x003FF]
    - 플래그, cs(코드 세그먼트), ip를 스택에 push
      - 함수를 실행시키기 위해 ROM BIOS까지 올라갈 수 있기 때문에 세그먼트의 값도 가져가야 할 것이다(=FAR 점프)

~~~c
int 21h
int 3
~~~

  - into : 오버플로 인터럽트 발생
    - 오버플로 플래그가 1이면 int 4를 실행
    - MS-DOS의 기본 동작은 그냥 return
    - 다른 동작을 원하면 IVT[4]에 처리 함수의 시작주소를 대임

~~~c
into
~~~

  - iret : 인터럽트 함수로부터 반환
    - 인터럽트 서비스 함수 전용 ret
    - int가 스택에 넣었던 값을 모두 복구

~~~c
iret
~~~

  - push : 스택에 push
    - 값을 push후, ss:sp를 2바이트 감소

~~~c
push dx
push fcount
~~~

  - pop : 스택에서 pop
    - 스택의 제일 위에 있는 값을 pop
    - ss:sp를 2만큼 증가
    - cs는 피연산자로 사용 불가

~~~c
pop cx
~~~

  - pushf : 플래그를 스택에 push
    - 플래그를 2바이트 모두 push

~~~c
pushf
~~~

  - popf : 플래그를 pop
    - 스택 최상위 값을 pop해서 플래그 레지스터에 대입

~~~c
popf
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 포트 입출력 니모닉
  - in : 포트로부터 읽기
    - 바이트나 워드를 포트로부터 읽어 a레지스터에 저장
    - src피연산자 : 포트 주소
      - imm8: 8비트 상수
      - dx: 그보다 큰 포트 주소, 혹은 실행 중 변경되는 포트 주소

~~~c
in ax, 60h
in ax, dx
in al, dx
~~~

  - out : 바이트나 워드는 포트에 쓰기
    - src피연산자 : a레지스터만 가능
    - dst피연산자 : 포트 주소

~~~c
out 60h, al
out dx, ax
out dx, al
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 덧셈 니모닉
  - add :  덧셈
    - 두 피연산자를 더해 dst에 저장
    - 캐리 비트를 사용하지 않음
    - 이 연산을 하기 전에 clc를 할 필요가 없다

~~~c
add ax, bx  ; bx를 ax에 더함
~~~

  - adc : 캐리를 이용한 덧셈
    - add에 캐리 비트까지 더한것
      - 6502의 adc와 동일
    - 레지스터 크기보다 큰 숫자 덧셈에 사용

~~~c
adc dx, cx
~~~

  - inc : 증가
    - dst를 1증가 시키는것(unsigned정수)
    - signed정수 증가는 add로
    - 캐리 플래그 변경 없음

~~~c
inc cl
inc bx
~~~

  - clc/stc : 캐리 플래그 변경

~~~c
clc : 캐리 플래그 끄기
stc : 캐리 플래그 켜기
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 뺄셈 니모닉
  - sub : 뺄셈
    - 캐리 비트를 사용하지 않음
    - dst = dst - src
    - ex) sub ax, bx

~~~c
sub bh, dh
~~~

  - sbb : 받아내림을 이용한 뺄셈
    - sub에 캐리 비트까지 더한 것
      - src에 캐리 플래그를 더한 뒤 뺌
      - sbb전에 clc를 실행해야 한다
        - 6502는 빼기를 할때 C를 1로 해줘야 했지만 8088에서는 clc를 통해서 C를 0으로 해줘야 한다
    - 레지스터 크기보다 큰 숫자 뺄셈에 사용

~~~c
sbb dx, cx
dx, 45
~~~

  - dec : 감소
    - dst를 1감소 시키는것
    - 나머지는 inc와 동일

~~~c
dec cl
~~~

  - neg : 2의 보수
    - 피연산자를 2의 보수 표현으로 바꿈
      - 0 - 피연산자

~~~c
neg ax
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 곱셈 니모닉
  - mul : unsigned곱셈
    - 데이터 손실 없는 곱셈
      - 8비트를 곱하면 결과는 ax에
      - 16비트를 곱하면 결과는 dx : ax에
        - dx : 상위 16비트
        - ax : 하위 16비트
    - 니모닉 옆에 적는 피연산자는 하나
      - 적지 않는 다른 피연산자는 al 또는 ax

~~~c
mul bx
mul dl
~~~

  - imul : signed곱셈
    - 그 외에는 mul과 동일

~~~c
imul dx
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 나눗셈 니모닉
  - div : unsigned 나눗셈
    - 나눗셈을 해서 몫과 나머지를 구함
    - 역시 니모닉 옆에 적는 피연산자는 하나
      - 8비트 -> 목 al, 나머지 ah
      - 16비트 -> 목 ax, 나머지 dx

~~~c
div cx
~~~

  - idiv : signed 나눗셈
    - 그 외에는 div와 동일

~~~c
idiv bx
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 논리 연산 니모닉
  - and :  논리곱
    - 비트별 and연산
    - 6502와 다른 점
      - c = 0, o = 0

~~~c
and dx, bx
~~~

  - or : 논리합
    - c = 0, o = 0

~~~c
or ax, dx
~~~

  - xor : 배타적 논리합

~~~c
xor cx, bx
~~~

  - not : 1의 보수
    - 모든 비트를 뒤집음
    - 플래그가 바뀌지 않음

~~~c
not ax
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 비트 이동/회전 니모닉
  - shl/shr  : 논리적 좌측 비트 이동/논리적 우측 비트 이동
    - 왼쪽/오른쪽 비트 이동
    - 한번에 여러 비트 이동 가능
      - 여러 비트는 cl로 지정
    - 제거된 비트는 캐리 비트에 대입
    - 새로 삽입되는 비트는 0

~~~c
shl si, 1
shl di, cl
shr dx, cl
~~~

  - sal/sar : 산술적 비트 이동
    - 새로 삽입되는 비트
      - sal : 0(shl과 동일)
      - sar : 최상위 비트가 반복
    - 그 외에는 shl/shr과 동일

~~~c
sal bx, 1
sal ah, cl
~~~

  - rol/ror : 비트 회전
    - 왼쪽/오른쪽 비트 회전
    - 8비트/16비트 회전
      - 캐리 비트를 삽입하지 않음
      - 회전되는 비트가 캐리 플래그에도 들어감
    - 한번에 여러 비트 회전 가능
      - 여러 비트는 cl로 지정

~~~c
rol dl, 1
rol dx, cl
~~~

  - rcl/rcr : 캐리 비트를 이용한 비트 회전
    - 9비트/17비트 회전
      - 캐리 비트를 추가 비트로 사용
    - 그 외에는 rol/ror과 동일

~~~c
rcl dx, 1
rcl dx, cl
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 제어 니모닉
  - jmp : 무조건 점프
    - 이진 파일에 들어가는 주소는 상대 주소
      - jmp다음 명령어 기준
    - 어셈블러가 자동으로 셋 중 하나를 선택
      - short :라벨 : 8비트
      - near :라벨 : 16비트
      - far :라벨 : 32비트
    - 직접 short/near/far 지정 가능

~~~c
jmp exit
jmp SHORT target
jmp NEAR PTR target
jmp FAR PTR target
~~~

  - cmp : 두 피연산자를 비교
    - 그 뒤에 조건부 점프를 함
    - 결과를 저장 안 하는 것 외에는 sub와 동일

~~~c
cmp di, bx
~~~

  - jㅁㅁㅁ : 조건부 점프
    - j(ump) + 조건으로 구성
    - short점프만 가능[-128, 127]
    - 조건
      - greater
      - less
      - above
      - below
      - equal
      - not
      - 그 외에 등등 많음
  - jcxz : cx가 0이면 점프
    - 카운터에 특화된 조건문 점프
    - cx가 0이면 점프
      - 반복문에서 cx하고 0을 비교할 필요가 없음
      - x86에서도 역순으로 반복문 도는 게 빠른 이유

~~~c
jcxz notfound
~~~

  - test : 논리 비교
    - 파괴적이지 않은 and연산
      - 플래그만 업데이트 함

~~~c
test dx, bx
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 반복문 니모닉
  - 6502에 없는 니모닉들
  - 반복문이 흔한 연산이다 보니 전용 니모닉을 제공
  - 결과는 조건 검사 후 점프 하는 것과 동일
    - loop : 카운터 감소 + 점프
      - cx감소 후 0이 아니면 라벨로 점프
      - cx감소 시 플래그를 변경하지 않음
    - loopㅁㅁ: 조건부 loop
      - cx감소 후 0이 아니고 조건이 참이면 라벨로 점프
      - 조건
        - equal/not equal
        - zero/not zero

~~~c
// loop : 카운터 감소 + 점프
loop sum
~~~

<br/>

~~~c
// loopㅁㅁ: 조건부 loop
loope zero
loopne not_zero
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 문자열 니모닉
  - movs : 문자열 복사
  - movsb : 문자열 복사(바이트)
  - movsw : 문자열 복사(워드)
  - lods : 문자열을 a 레지스터에 load
  - lodsb : 문자열을 al 레지스터에 load
  - lodsw : 문자열을 ax 레지스터에 load
  - stos : a 레지스터 값을 문자열에 store
  - stosb : al 레지스터 값을 문자열에 store(바이트)
  - stosw : ax 레지스터 값을 문자열에 store(워드)
  - cmps : 문자열 비교
  - cmpsb : 문자열 비교(바이트)
  - cmpsw : 문자열 비교(워드)
  - scas : 문자열 검색
  - scasb : 문자열 검색(바이트)
  - scasw : 문자열 검색(워드)
  - rep : 문자열 반복
  - repㅁㅁ : 조건부 문자열 반복

<br/>

  - string : 바이트 혹은 워드들을 나열해 놓은 것
    - 문자(character)에 국한하지 않음
    - 배열이라 보는 게 더 맞음
  - x86은 string 전용 니모닉을 제공
    - 복사 : movs, movsb, movsw
    - 로드 : lods, lodsb, lodsw
    - 채우기  : stos, stosb, stows
    - 배교 : cmps, cmpsb, cmpsw
    - 검색 : scas, scasb, scasw
  - 모든 string 전용 니모닉에 공통되는 내용
    - 레지스터들을 동일한 방법으로 사용
    - 비슷한 문법을 따름
    - 대부분 반복 명령어를 앞에 붙여서 사용
    - byte버전과 word버전이 있음
      - -sb : 바이트
      - -sw : 워드
      - -s : 피연산자에 따라 위 둘 중 하나를 선택
    - 최적화 팁 : 데이터 버스 크기와 일치하는 버전을 사용할 것
  - string전용 니모닉 사용법
    - 방향 플래그를 올바르게 설정
      - cld : low to high
        - 작은 바이트 부터 높은 바이트까지
      - std : high to low
        - 높은 바이트 부터 작은 바이트로
    - cx 레지스터에 반복 횟수를 저장
    - string 의 포인터를 저장
      - ds : si - src문자열
      - es : di - dst문자열
    - 올바른 반복 접두사 명령어를 선택
    - 접두사 명령어 바로 오른쪽에 string 니모닉을 적음

~~~c
    cld
    mov cx, 16
    mov si, OFFSET src
    mov di, OFFSET dst
    rep movsb
~~~

  - movs : string복사
  - ds : si에서 es : di 로 string을 복사
    - ds 대신 다른 세그먼트 레지스터도 사용 가능
  - 각 요소가 복사될 때마다 si, di가 요소 크기만큼 증감

~~~c
// movsb를 사용한 string복사
    cld
    mov cx, 16
    mov si, OFFSET src
    mov di, OFFSER dst
    rep movsb
~~~

<br/>

~~~c
// 반복문을 사용한 string 복사
    mov cx, 16
    mov si, OFFSET src
    mov di, OFFSET dst
copy_loop : 
    mov al, es : [si]
    mov [di], al
    inc si
    inc di
    loop copy_loop
~~~

  - lods : string 로드
    - ds : si로부터 a레지스터로 값을 읽어옴
      - ds 대신 다른 세그먼트 레지스터도 사용 가능
    - rep와 같이 사용할 실익이 없음
  - stos : string 채우기
    - es : di를 a레지스터 값으로 채움
      - C의 memset()과 비슷
        - 특히 stosb를 사용할 때

~~~c
// memset(nums, 3, 16)과 아래의 코드가 같다
// 16바이트를 3으로 채워 주겠다는것
    mov al, 3

    cld
    mov cx, 16
    mov di, OFFSET dst
    rep stosb
~~~

  - cmps : string 비교
    - es : di 를 ds : si와 비교
      - ds 대신 다른 세그먼트 레지스터도 사용 가능
      - 플래그가 변경됨
    - repe / repne 와 주로 사용
      - repne cmps 후, Z == 0 : match를 찾을 수 없었음
      - repe cmps 후, Z == 1 : string이 동일

~~~c
// cmpsb를 사용한 string비교
    cld
    mov cx, 15
    mov si, OFFSET s0
    mov di, OFFSET s1
    repe cmpsb
    jne not_equal

equal:
    ...
~~~

<br/>

~~~c
// 반복문을 사용한 string 비교
    cld

    mov cx, 15
    mov si, OFFSET s0
    mov di, OFFSET s1

compare_loop : 
    lodsb // si에서 al로 문자열 하나를 읽어옴
    cmp al, [di]
    jne not_equal

    inc di
    loop compare_loop

equal : 
    ...
~~~

  - scas : string 검색
    - es : di 에서 a레지스터의 값을 찾음
    - 결과
      - repne scas 후, Z == 0 : 값을 찾지 못했음
      - repn scas 후, Z == 1 : 모든 요소가 a와 같음

~~~c
    cld
    mov cx, 16
    mov di, OFFSET msg
    mov al, 'P'

    repne scasb
    jz found

not_found : 
    ...
~~~

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

# 기타 니모닉
  - nop : 아무 연산도 하지 않음
  - cmc : 캐리 플래그를 뒤집음
  - cli : 인터럽트 플래그를 끔
  - sti : 인터럽트 플래그를 켬
  - cld : 방향 플래그를 끔
  - std : 방향 플래그를 켬
  - 프로세서 제어
    - wait : BUSY핀이 꺼질 때까지 대기
    - esc : 코프로세서용 명령어를 fetch
    - hlt : CPU실행을 멈춤
    - lock : 명령어 실행 동안 lock을 검
  - 기타 BCD
    - aaa : 덧셈후 BCD로 변환
    - aad : 나누기 전 BCD 숫자를 이진 숫자로 변환
    - aam : 곱셈 후 BCD로 변환
    - aas : 뺄셈 후 BCD로 변환
    - daa : 덧셈 후 packed BCD로 변환
    - das : 뺄셈 후 packed BCD로 변환

###### [x86-16 니모닉 소개](#x8616-니모닉-소개)
###### [Top](#top)

<br/>
<br/>

***

# 콘솔 입 출력
  - [외부장치 입출력](#외부장치-입출력)
  - [인터럽트](#인터럽트)
  - [콘솔 입력](#콘솔-입력)

###### [콘솔 입 출력](#콘솔-입-출력)
###### [Top](#top)

<br/>
<br/>

# 외부장치 입출력
  - 6502 시절과 개념은 바뀌지 않음
    - 입출력 장치가 요구하는 스펙이 있음
    - 스펙에 따라 신호를 보내야 제대로 작동
  - 그 올바른 신호를 보내는 주체가 바뀜
    - 6502시절 : 응용프로그램 프로그래머
    - MS-DOS시절 : DOS, BIOS프로그래머
  - 여전히 응용프로그램 프로그래머가 직접 신호를 보내도 됨

#a.asm
~~~c
// DOS함수 버전
// 아래코드에서는 , msg에 있는 글자의 시작 주소를 dx에 넣고, DOS가 가지고 있는 21h하위에 있는 9번째 함수를 실행 시켰을 뿐

.DATA
msg DB "Hello, x86!$"

.CODE
.STARTUP
	; 화면 출력
	mov ah, 09h
	lea dx, msg
	int 21h

	; 프로그램 종료
	mov ah, 4ch
	xor al, al ; 리턴값 0
	int 21h
END
~~~

<br/>

#a.asm
~~~c
// BIOS버전

TITLE Hello BIOS

.DOSSEG
.8086
.NO87
.MODEL TINY

INCLUDE libs.mac

.DATA
msg DB "Hello, x86!$"

.CODE
.STARTUP
	mov si, OFFSET msg


// 한글자씩 찍어주기 때문에 for문이 필요하다
next_char : 
	lodsb
	cmp al, 0
	je exit

	mov ah, 0Eh  // BIOS함수 중 하나
	mov bx, 0007h // 함수 사용전 필요한 데이터 및 설정값
	int 10h // BIOS인터럽트
	jmp next_char

exit : 
	EXIT0
END
~~~

  - DOS함수든, BIOS함수든, 소프트 인터럽트를 발생시켜서 함수를 사용하러 점프하게 된다

###### [콘솔 입 출력](#콘솔-입-출력)
###### [Top](#top)

<br/>
<br/>

# 인터럽트
  - 마이크로프로세서에서 실행 중인 프로그램을 잠시 멈춰 달라는 요청
  - 그 대신 긴급히 인터럽트 요청을 처리해 줌
    - 해당 인터럽트를 처리하는 코드(인터럽트 서비스 루틴)로 점프
    - 처리를 마치면 다시 돌아와서 원래 실행 중이던 기계어를 계속 실행
  - 인터럽트 서비스 루틴의 시작 주소는 변경 가능
  - 크게 두 가지 종류
      - 하드웨어 인터럽트 : 외부 장치가 인터럽트 핀을 통해 요청
        - 외부에서 cpu핀에 데이터가 오면, 그것을 보는 프로그램이 인터럽트가 왔다고 알려줌
      - 소프트웨어 인터럽트 : 실행 중인 프로그램이 함수 포인터를 호출
  - 소프트웨어 인터럽트
    - 코드에서 int명령어가 일으키는 인터럽트
    - 하드웨어 인터럽트 보다 우선순위가 높음
    - 언제나 곧바로 처리됨
      - 사실상 함수 호출
    - 실행할 함수는 테이블에 저장되어 있음
      - 변경 가능
      - 사실상 함수 포인터
  - 8088의 인터럽트
    - 8088은 총 256개의 인터럽트를 지원
      - 예: int 00h, int 01h …. int FFh
    - 인터럽트 서비스 루틴의 주소는 인터럽트 벡터 테이블(IVT)에 저장
      - [0x00000, 0x003FF]
    - 인터럽트 발생 시 CPU가 하는 일
      - 1. 플래그 레지스터, ip, cs를 스택에 저장
      - 2. 인터럽트 번호 X 4 주소에서 ip와 cs를 읽어 옴
      - 3. 그 위치로 점프
    - 플래그, ip, cs 복구는 iret이 담당

###### [콘솔 입 출력](#콘솔-입-출력)
###### [Top](#top)

<br/>
<br/>

# 콘솔 입력
  - 콘솔 출력과 개념은 동일
  - 우리가 직접 하드웨어와 통신해도 됨
    - 입력 하드웨어의 스펙에 맞게 코드를 작성해야 함
  - 다른 프로그래머가 만들어 놓은 서비스를 사용해도 됨
    - 예 : 도스 함수 21h
    - 그 API 스펙에 맞게 프로그램 작성

#a.asm
~~~c
// 문자 읽기
// 01h

.DATA
prompt DB 'Enter a Character: $'

    PRINTSTR prompt

; 키보드로부터 문자 읽기
    mov ah, 01h
    int 21h ; 받은 데이터를 al레지스터에 들어간다

    mov dl, al

; 대소문자 변경
    or al, 20h
    cmp al, 'a'
    jb not_alpha
    cmp al, 'z'
    ja not_alpha

    xor dl, 20h

; 글자 하나 찍어주는 인터럽트
   not_alpha:
    mov ah, 02h
    int 21h

    EXIT0
~~~

###### [콘솔 입 출력](#콘솔-입-출력)
###### [Top](#top)

<br/>
<br/>

***

# x86-16함수
  - [x86-16의 함수 호출](#x8616의-함수-호출)
  - [cdecl 호출 규약](#cdecl-호출-규약)
  - [near/far함수 호출](#nearfar함수-호출)
  - [함수 호출 종류](#함수-호출-종류)

###### [x86-16함수](#x8616함수)
###### [Top](#top)

<br/>
<br/>

# x86-16의 함수 호출
  - 개념 상으로는 6502와 거의 동일
  - 시대적인 차이점
    - 고수준 언어의 사용량 증가
    - 접근 가능한 메모리 범위 증가
  - 고수준 언어  호출 규약
    - 인자 전달
      - 스택, 레지스터
      - 가장 흔한 방법은 스택(왼쪽->오른쪽 vs 왼쪽<-오른쪽)
    - 반환값
      - 레지스터, 스택 직접, 스택 간접
      - 가장 흔한 방법은 레지스터
    - 스택 정리 책임 : 호출자(caller) vs 함수(callee)
    - 고수준 언어와 컴파일러 따라 호출 규약이 달라짐

###### [x86-16함수](#x8616함수)
###### [Top](#top)

<br/>
<br/>

# cdecl 호출 규약
  - c의 호출 규약 = 가장 널리 사용하는 규약
  - 인자 전달
    - 언제나 스택을 통해
    - 오른쪽에서 왼쪽 순으로 (RTL)
  - 반환값 : ax 혹은 dx:ax
  - 스택 정리 : 호출자(caller)
  - 함수(callee)가 보존해야 하는 레지스터 : bp, si, di
    - 함수 안에서 이렇게 3가지 레지스터는 알아서 스택에 push해서 보존했다가 함수 끝날때 알아서 다시 복구해 준다는것

#a.asm
~~~c
// cdecl을 따르는 호출자 코드
// C언어
add_two(1, 2)

//x86-16코드
mov ax, 2
push ax
mov ax, 1
push ax

call add_two

add sp, 4

//6502코드
lda #2
pha
lda #1
pha

jsr add_two

pla
pla
~~~

<br/>

#a.asm
~~~c
// cdecl을 따르는 함수 코드
add_two PROC NEAR
  push bp
  mov bp, sp
  sub sp, 2  ; 리턴값이 2바이트 이기 때문에 미리 잡아줌

  mov ax, [bp+4] ; 두번째 인자
  add ax, [bp+6] ; 첫번째 인자
  mov [bp-2], ax ; 리턴값
  mov ax, [bp-2]

  mov sp, bp
  pop bp
  ret
add_two ENDP
~~~

###### [x86-16함수](#x8616함수)
###### [Top](#top)

<br/>
<br/>

# near/far함수 호출
  - near 함수
    - 호출 시 오프셋만 스택에 push
    - retn을 사용해야 함
  - far함수
    - 호출 시 오프셋과 cs를 모두 스택에 push
    - retf를 사용해야 함
  - PROC 옆에 단 NEAR/FAR를 통해 자동화
    - ret는 opcode 없는 니모닉
    - call로 최적의 방법으로

###### [x86-16함수](#x8616함수)
###### [Top](#top)

<br/>
<br/>

# 함수 호출 종류
  - near라벨 호출
    - 상대 주소
    - 메모리 직접
  - near메모리 간접 호출
    - 특정한 메모리 주소로 간후, 그 주소에 값을 읽어서 그곳으로 점프 한다
  - near레지스터 간접 호출
    - 주소값을 가지고 있는 레지스터로 가서 그 주소로 점프 한다
  - far메모리 직접 호출
  - far메모리 간접 호출

#a.asm
~~~c
// near메모리 간접 호출

.DATA
pointer DW add_two

mov ax, 2
push ax
mov ax, 1
push ax
call pointer  ; add_two함수 주소로 점프
add sp, 4
~~~

<br/>

#a.asm
~~~c
// near레지스터 간접 호출
mov bx, add_two

mov ax, 2
push ax
mov ax, 1
push ax
call bx ; add_two함수 주소로 점프
add sp, 4
~~~

<br/>

#a.asm
~~~c
// far 메모리 직접 호출
mov ax, 2
push ax
mov ax, 1
push ax
call FAR PTR add_two ; add_two함수 주소로 점프
add sp, 4
~~~

<br/>

#a.asm
~~~c
// far 메모리 간접 호출

.DATA
pointer DW add_two

mov bx, OFFSET pointer
mov ax, 2
push ax
mov ax, 1
push ax
call FAR PTR [bx] ; add_two함수 주소로 점프
add sp, 4
~~~

###### [x86-16함수](#x8616함수)
###### [Top](#top)

<br/>
<br/>

***

# 구조체, 레코드
  - [구조체](#구조체)
  - [레코드](#레코드)

###### [구조체, 레코드](#구조체-레코드)
###### [Top](#top)

<br/>
<br/>

# 구조체
  - C의 구조체
    - 여러 데이터를 모아 놓은 커스텀 자료형
      - 한 덩어리로 사용 할 수 있음
      - 심볼을 사용하여 개별 데이터에 접근
    - 개별 데이터 사이에 패딩이 있을 수 있음
  - x86-16의 구조체
    - C의 구조체와 매우 비슷
    - 별도의 패딩 없음

#a.asm
~~~c
// 구조체 예시

.DATA
date STRUC
	year DW ?
	month DB ?
	day DB ?
date ENDS

date0 date <> ; 메모리만 잡아 두기
date1 date <2043, 10, 1> ; 초기화 순서대로 하기
dates0 date 10 DUP (<>) ; 10개 반복해서 메모리만 잡기
dates1 date 10 DUP (<1992, 1, 2>) ; 10개 반복해서 초기화 하기

mov date0.year, 1990 ; 각각 대입하는 방법
~~~

###### [구조체, 레코드](#구조체-레코드)
###### [Top](#top)

<br/>
<br/>

# 레코드
  - 여러 데이터를 모아 놓은 커스텀 자료형
    - 구조체와 마찬가지
  - 구조체와 차이점
    - 개별 데이터마다 비트 크기를 정의해 줌
    - MASK 등의 연산자를 사용할 수 있음

#a.asm
~~~c
.DATA
color RECORD r : 3, g : 3, b :2

// 초기화 하는 법
r color <7, 0, 0>
g color <0, 7, 0>
b color <0, 0, 7>
~~~

  - 레코드 필드 사용
    - MASK 연산자로 필요한 비트만 뽑아냄
      - NOT연산자와 같이 사용하기도 함
    - 올바른 비트 위치로 이동하려면?
      - 비트 이동 연산을 이용

#a.asm
~~~c
.DATA
color RECORD r : 3, g : 3, b : 2

window color <7, 0, 3>

mov bl, color <7, 7, 3>

mov al, window ; al = 1110 0011
and al, NOT MASK r ; al = 0000 0011
or al, MASK g ; al = 0001 1111
xor al, MASK b ; al = 0001 1100
or al, MASK color ; al = 1111 1111
and al, MASK g ; al = 0001 1100

mov cl, g ; cl = 2
shr al, cl ; al = 0000 0111
~~~

###### [구조체, 레코드](#구조체-레코드)
###### [Top](#top)

<br/>
<br/>

***

# 메모리 세그먼테이션
  - 주소 레지스터 크기와 메모리 범위
    - 16비트 : 64kb
    - 32비트 : 4GB
    - 64비트 : BIG
  - 16비트 레지스터로 20비트 표현하기
    - 레지스터 크기 : 16비트
    - 필요한 비트 수 : 20비트
    - 레지스터를 2개 사용하면 된다!
  - COM파일과 세그먼트
    - 모든 세그먼트가 동일!
      - cs = ds = ss = es
    - 코드, 데이터, 스택이 모두 64KB 블록 하나 안에 들어있음
      - 이는 즉, 16비트 안에 모두 접근 할 수 있게 주소가 놓여져 있다는것
      - 따라서, 64KB보다 커지면 안된다
  - 메모리 모델
    - 단순하게 세그먼트를 정의하는 방법
      - MASM의 기능
    - 세그먼트 레지스터가 사용되는 방법을 제어
    - 미리 정의된 6개 메모리 모델을 제공
  - TINY메모리 모델
    - x86 CPU의 6개 메모리 모델 중 하나
    - 모든 세그먼트가 동일
      - 64KB 안에 코드와 데이터가 모두 들어 있음
    - COM파일을 생성
      - EXE파일 헤더가 없음
      - 대신 100h에 첫 기계어 코드가 있다고 가정
    - 한계 : 데이터와 코드를 합쳐서 64KB 미만일 때만 사용가능
  - x86의 메모리 모델
    - TINY, SMALL, MEDIUM, COMPACT, LARGE, HUGE
  - EXE파일 헤더 (MS-DOS 2.0)
    - .EXE는 MS-DOS 2.0 부터 시작했으며 나중에 윈도우가 되었을때의 .EXE의 시초가 된다
    - MS-DOS의 모든 .EXE 파일 제일 앞에 있는 데이터
    - 프로그램 로딩과 시작에 필요한 내용들을 담고 있음
      - https://wiki.osdev.org/MZ
    - SMALL 이상의 메모리 모델은 .EXE 파일을 만듦
    - 1. 시그니처
      - MZ
    - 2. 파일크기
    - 3. 위치 변경할 개수
    - 4. 헤더 크기
    - 5. 최소 메모리
    - 6. 레지스터 초기값
    - 7. 위치변경 테이블
      - 어떤 주소값들 상황에서 EXE파일을 실행 했는지 모르기 때문에 그 실행한 EXE파일에 해당하는 주소값을 매핑해준다
    - 8. 위치 변경 할 코드
  - .DOSSEG가 하는 일
    - 세그먼트를 일관적, 논리적인 순서로 정렬해줌
      - 프로그래머가 소스 파일에서 세그먼트 순서를 직접 지정하지 않아도 됨
    - 사용하지 않으면 여러 가지 요인에 따라 순서가 결정됨
      - 세그먼트 등장 순서
      - 클래스 이름
      - 링크 순서 등
      - 그냥 .DOSSEG를 쓰면 된다!
  - 어셈블리 코드의 세 가지 섹션
    - 텍스트 섹션(.text)
      - 실제 프로그램의 로직
      - 진입점 : start
    - 데이터 섹션(.data)
      - 초기화된 데이터
    - 블록 시작 심볼 섹션(.bss)
      - 초기화되지 않은 데이터 (변수 등)

###### [메모리 세그먼테이션](#메모리-세그먼테이션)
###### [Top](#top)

<br/>
<br/>

***

# FPU 프로그래밍
  - [8088과 부동 소수점](#8088과-부동-소수점)
  - [일반적인 8087 사용법](#일반적인-8087-사용법)
  - [8087의 레지스터](#8087의-레지스터)
  - [8087의 데이터형](#8087의-데이터형)
  - [8087 니모닉](#8087-니모닉)
  - [8087 명령어](#8087-명령어)
  - [8087 데이터 전송](#8087-데이터-전송)
  - [8087 조건문](#8087-조건문)
  - [x87 코프로세서의 발전](#x87-코프로세서의-발전)

###### [FPU 프로그래밍](#fpu-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 8088과 부동 소수점
  - 8088의 ALU는 정수 연산만 지원
  - 실수 연산을 필요로 하는 프로그램이 많아짐
  - intel 8087을 별도로 달아 실수 연산을 담당
    - 코프로세서(coprocessor), FPU(Floationg-Point Unit)라고도 함
    - x87용 명령어가 별도로 있음
  - 8088 시절에는 일반적으로 달지 않았음
    - 부동 소수점 연산을 하는 프로그램만 혜택을 받음
    - 꽤 비싼 가격
  - intel 8087 Math Coprocessor
    - 부동 소수점 연산의 속도를 높이기 위한 칩
      - 사칙연산, 제곱근 구하기
      - 초월함수
    - 큰 이진수와 십진수도 처리 가능
    - 표준 부동 소수점 포맷을 정립하려 했음
      - IEEE 754 표준의 기반이 됨
      - 80387이 되어서야 IEEE 754를 완벽히 지원
    - 장치 입출력은 처리 불가
      - 대부분의 데이터를 메인 프로세서에서 받아옴

###### [FPU 프로그래밍](#fpu-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 일반적인 8087 사용법
  - 1. 8088에 데이터를 메모리에 저장
  - 2. 그 메모리에서 데이터를 8087 레지스터로 로드
  - 3. 8087이 연산
  - 4. 연산한 값을 메모리에 저장
  - 5. 8088이 그 값을 메모리에서 읽어옴
  - CPU와 FPU 싱크 맞추기
    - 8088 명령어가 먼저인 경우
      - wait : 8088 실행이 끝날 때까지 대기
      - 그 후, 8087 명령어를 실행
    - 8087 명령어가 먼저인 경우
      - fwait : 8087 실행이 끝날 때까지 대기
      - 그 후, 8088 명령어를 실행

#a.asm
~~~c
// 8088 명령어가 먼저인 경우
.DATA
num DW 20

mov ax, 10
mov num, ax
wait
fild num
~~~

<br/>

#a.asm
~~~c
// 8087 명령어가 먼저인 경우
.DATA
num DW 20

fadd
fist num
fwait
mov ax, num
~~~

  - 위와 같이 f명령어를 사용 할때는 wait를 항상 넣어 주자는 것으로 바뀌게 되었고, 8086 cpu부터는 알아서 넣어주게 되었다
  - masm를 사용할때 아래와 같이 넣어 주게 되면, f명령어 사용시 자동으로 wait를 넣어주게 된다
  - 하지만 그래도 fwait는 프로그래머가 넣어 주어야 한다

#a.asm
~~~c
.DOSSEG
.8086   ; 이것을 넣어주면 wait를 넣어주게 된다
.8087
.MODEL TINY
~~~

###### [FPU 프로그래밍](#fpu-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 8087의 레지스터
  - 8087 전용 레지스터가 있음
    - 8088의 레지스터와 완벽히 분리
    - 서로 접근 불가능
    - 데이터 교환은 메모리를 통해
  - 레지스터는 총 8개 : [st0, st7]
    - 80비트 레지스터
    - 스택처럼 사용함 (st0이 제일 위)
    - 모든 수는 임시 부동 소수점 포맷으로 저장

###### [FPU 프로그래밍](#fpu-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 8087의 데이터형
  - 실수
    - 32비트
    - 64비트
    - 80비트 : 임시 부동 소수점 포맷, 확정 정밀도 부동 소수점 포맷, 처음 시작은 이것으로 저장한다고 보면 된다. 비트를 많이 사용해서 계산후 데이터를 가장 많이 가지고 있고 정확도를 높이기 위해 사용한다. 그후 낮은 비트로 저장한다
  - 정수
    - 16비트
    - 32비트
    - 64비트
  - BCD정수 : 18자리

###### [FPU 프로그래밍](#fpu-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 8087 니모닉
  - 모두 f로 시작
  - 두 번째 글자
    - i : 메모리 값이 정수임을 의미
    - b : 메모리 값이 BCD 포맷임을 의미
  - 마지막 글자가 p면 동시에 st 레지스터를 pop함을 의미
  - x87피연산자 형태
    - 피연산자 : 메모리, 레지스터
      - 묵시적으로 직접 표기하지 않는 경우도 있음
      - 두 피연산자가 모두 메모리인 경우는 지원하지 않음
    - 코드에 작성하는 방식은 크게 4가지
      - 1. 스택 형태로 묵시적 피연산자를 사용
      - 2. 메모리 피연산자를 사용
      - 3. 레지스터 형태로 피연산자를 지정
      - 4. 레지스터 & pop형태로 피연산자를 지정

###### [FPU 프로그래밍](#fpu-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 8087 명령어
  - 데이터 전송
    - 메모리 <-> 레지스터
    - 레지스터 <-> 레지스터
  - 상수를 레지스터에 로드
    - 일반적으로 사용되는 상수마다 별도의 명령어
    - 임의의 상수를 로드할 수는 없음
  - 제어 데이터 전송

###### [FPU 프로그래밍](#fpu-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 8087 데이터 전송
  - 메모리 속 데이터
    - 명령어에 따라 메모리에 있는 데이터형이 결정됨
      - 실수 vs 정수 vs BCD
      - 피연산자 크기에 따라 데이터의 바이트 수가 결정됨
    - 8087에 저장되는 값은 언제나 임시 부동 소수점 포맷
      - 언제나 10바이트
    - 두 포맷 사이의 변환은 전송 때 자동으로 된다
    - 실수 전송 명령어
      - fld mem : mem을 st에 push. mem은 4,8,10바이트 중 하나
      - fld st(#) : st(#)의 값을 st에 push
      - fst mem : st를 mem에 복사. mem은 4,8바이트. 스택은 변경하지 않음
      - fst st(#) : st를 st(#)에 복사
      - fstp mem : st를 pop해서 mem에 저장. mem은 4,8,10 바이트 중 하나
      - fstp st(#) : st를 pop해서 st(#)에 저장
      - fxch : st와 st(1)의 값을 교환
      - fxch st(#) : st와 st(#)의 값을 교환
    - 정수 전송 명령어
      - fild mem : mem을 st에 push. mem은 2,4,8 바이트 중 하나
      - fist mem : st를 mem에 복사. mem은 2또는 4바이트
      - fistp mem : st를 pop해서 mem에 저장. mem은 2,4,8바이트 중 하나
    - 상수 로드 명령어
      - fldz : 0을 st에 push
      - fld1 : 1을 st에 push
      - fldpi : 원주율을 st에 push
      - fld12e : log2 e를 st에 push
      - fld12t : log2 10를 st에 push
      - fldlg2  : log10 2를 st에 push
      - fldin2 : loge 2를 st에 push
    - 제어 데이터 전송 명령어
      - fldcw, fstcw, fstsw, fldenv, fstenv, frstor, fsave
    - 사칙연산 명령어
      - 등등등…
    - 기타연산 명령어
      - 등등등…
    - 비교 명령어
      - 등등등…

###### [FPU 프로그래밍](#fpu-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 8087 조건문
  - 8087 자체적으로 조건문 실행은 불가능
    - 점프 명령어가 없음
  - 8088이 대신 처리해줘야 함
    - 1. 8087에서 비교문을 실행
    - 2. 그에 따라 상태 워드의 플래그들이 바뀜
    - 3. 8087이 상태 워드를 메모리로 전송
    - 4. 8088에서 그걸 가져와 분기

###### [FPU 프로그래밍](#fpu-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# x87 코프로세서의 발전
  - 계속된 cpu의 발전
  - 펜티엄부터는 CPU가 FPU를 내장
    - 명령어는 분리가 되어 있는것은 같다!

###### [FPU 프로그래밍](#fpu-프로그래밍)
###### [Top](#top)

<br/>
<br/>

***

# x-86-32
  - CPU가 발전하면서, 더 많은 기능을 넣게 되고, 그렇다면 같은 시간에 더 많은것을 개발해야 하게 되는 상황이 된다
    - 더 빨리 개발하고, 더 많은것을 강제하기 위해서 고수준 언어를 사용하게 된다
  - 고수준 언어 사용의 장단점
    - 장점
      - 메모리 직접 접근을 줄임
      - 공통적인 코딩 방식을 강제
        - 함수 호출 규약
        - 데이터 형
        - 등
      - 멀티 플랫폼 지원
    - 단점
      - 전반적인 성능 저하
      - 기계어 동작이 한 눈에 보이지 않음
      - 정말 필요한데 못하는 일이 있음

<br/>

  - [IA-32 CPU](#ia32-cpu)
  - [IA-32의 레지스터](#ia32의-레지스터)

###### [x-86-32](#x8632)
###### [Top](#top)

<br/>
<br/>

# IA-32 CPU
  - intel 80386 (1985)
    - 첫 IA-32 CPU
    - 최대 메모리 4GB
      - 386컴퓨터는 보통 2~4 MB메모리를 내장
    - 다소 과도기적
      - 여전히 주로 DOS운영체제를 사용
      - 여전히 메모리 세그먼테이션을 사용했음
  - 32비트 CPU의 시장 점유율
    - 약 30년 간 주류 CPU : 1985~2011
    - 64비트로 주도권을 넘겨주게 된 계기
      - 더 큰 최대 메모리 용량
        - 메모리 가격이 엄청 싸짐
        - 2 GB 이상이 필요한 프로그램이 많아짐
      - 여전히 32비트 프로그램을 돌릴 수 있음
    - 2GB제한
      - 일반적인 32비트 운영체제의 구현 문제
      - 프로그램 하나가 사용할 수 있는 최대 주소 공간이 2GB
        - 이런 저런 방법으로 3GB까지 늘리는 방법도 있었음
      - 64비트 운영체제에서 32비트 프로그램을 돌려도 마찬가지
        - 똑같은 방법으로 그 제약을 푸는 법이 있음
        - 이 경우에는 4GB까지

###### [x-86-32](#x8632)
###### [Top](#top)

<br/>
<br/>

# IA-32의 레지스터
  - 기존 레지스터를 32 비트로 늘림
  - 메인 레지스터는 예전처럼 접근 가능
  - 여전히 세그먼트 레지스터가 존재

![20231007_222346](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/d252321b-b733-46c8-93c7-2d7c5061e89f)

###### [x-86-32](#x8632)
###### [Top](#top)

<br/>
<br/>

***

# 인라인 어셈블리
  - 고수준 컴파일러의 기능
  - 고수준 코드 중간에 어셈블리어 코드를 삽입
    - 어셈블리어 코드를 따로 어셈블 한 뒤 링크 단계에서 합치는 게 아님
    - C언어 + 어셈블리 코드를 한 번에 컴파일
  - 컴파일러마다 지원여부와 문법이 다를 수 있음
    - 일반적인 C/C++컴파일러는 모두 지원
    - 본 자료는 Visual C++컴파일러 기준으로 설명
  - 용도
    - 최적화
    - 아직 컴파일러가 지원하지 않는 기능을 사용
      - 특정 프로세서에만 지원되는 명령어에 접근
      - 특수한 호출 규약 사용
    - 시스템 콜
    - 등
  - Visual C++ 인라인 어셈블러
    - 모든 MASM 표현식을 지원
    - C/C++의 변수와 상수를 참조할 수 있음
    - C함수를 호출할 수 있음
    - MASM지시어 (예:DB)로 데이터를 정의할 수 없음
      - 구조체와 레코드도 마찬가지
    - MASM매크로 지시문 사용 불가
      - 그 대신 C매크로 지시문을 사용
  - 함수를 통째로 작성하지 않을 때 주의할 점
    - 함수 안에 인라인 블록이 여러 개 있는 경우
    - 중간에 레지스터 값이 바뀔 수 있음
    - 블록이 끝나기 전에 레지스터를 보존해야 함
    - 특히 Visual C++가 아니면 더 문제

<br/>

  - [인라인 어셈블리 사용 예시](#인라인-어셈블리-사용-예시)
  - [다양한호출규약](#다양한호출규약)
  - [정적 라이브러리, 동적 라이브러리](#정적-라이브러리-동적-라이브러리)

###### [인라인 어셈블리](#인라인-어셈블리)
###### [Top](#top)

<br/>
<br/>

# 인라인 어셈블리 사용 예시
  - 모두 32비트에서 사용할 수 있으니, x64에서는 그냥 아래와 같이 들은 사용할 수 없다!!

#test.c
~~~c
// C 변수 사용

int add(int a, in b)
{
    __asm {
        mov eax, a
        mov eax, b
    }
}
~~~

<br/>

#test.c
~~~c
//C배열 사용
#include <stdio.h>

int main(void)
{
    const int nums[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, };
    int i;

    __asm {
        mov ebx, -1
        mov nums[4], ebx
    }

    for (i = 0; i < sizeof(nums) / sizeof(int); ++i)
    {
        printf("%d,", nums[i]);
    }

    printf("\n");
}

// 0, -1, 2, 3, 4, 5, 6, 7, 8, 9,
~~~

<br/>

#test.c
~~~c
//C배열 사용
#include <stdio.h>

int main(void)
{
    const int nums[10] = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, };
    int i;

    __asm {
        mov ebx, -1
        mov nums[4 * TYPE int], ebx
    }

    for (i = 0; i < sizeof(nums) / sizeof(int); ++i)
    {
        printf("%d,", nums[i]);
    }

    printf("\n");
}

// 0,1,2,3,-1,5,6,7,8,9,
~~~

<br/>

#test.c
~~~c
// C함수 호출
// 인자를 뒷부분 부터 넣는다

#include <stdio.h>

int main(void)
{
	const char* format = "%s %d\n";
	const char* hello = "Hello";

	// printf(fmt, args)
	__asm {
		mov eax, 123
		push eax
		mov eax, hello
		push eax
		mov eax, format
		push eax
		call printf
		add esp, 12
	}
}

// Hello 123
~~~

<br/>

#test.c
~~~c
// C라벨로 점프

#include <stdio.h>

int main(void)
{
	__asm {
		jmp func_exit
	}
	 
	printf("iiii");
	return 0;

func_exit:
	printf("kkkkk");
	return 0;
}

// kkkkk
~~~

<br/>

#test.c
~~~c
// C구조체 사용

#include <stdio.h>

typedef struct point
{
	int xp;
	int yp;
} point_t;

int add(point_t p)
{
	__asm {
		mov eax, p.xp
		add eax, p.yp
	}
}


int main(void)
{
	int res;
	point_t pt;
	pt.xp = 3;
	pt.yp = 5;

	res = add(pt);
	printf("%d\n", res);
}

// 8
~~~

###### [인라인 어셈블리](#인라인-어셈블리)
###### [Top](#top)

<br/>
<br/>

# 다양한호출규약
  - cdecl
    - C의 호출 규약
    - 인자 전달
      - 언제나 스택을 통해
      - 오른쪽 -> 왼쪽으로 인자 전달
    - 반환값 : eax 혹은 edx : eax
    - 스택 정리 : 호출자(caller)
    - cdecl의 반환 위치
      - Plain Old Data(POD)
        - 32비트 이하 : eax
        - 64비트 이하 : eax, edx
      - 그외
        - 호출자가 공간을 할당한 뒤 그 포인터를 스택에 숨은 매개변수로 전달
        - 함수는 그 주소에 반환값을 저장
      - 부동 소수점 값 : st0 레지스터
    - 32비트 호출 규약과 레지스터 보존
      - 함수가 보존하는 레지스터
        - ebp
        - edx
        - edi
        - esi
      - 나머지 레지스터는 아님

#test.c
~~~c
// 함수의 반환이 64비트가 넘어가면 메모리에 따로 쓰고 그 주소를 스택으로 반환한다

#include <stdio.h>

typedef struct
{
	int x;
	int y;
	int z;
} vector3_t;

vector3_t get_negation(const vector3_t vec)
{
	vector3_t ret;
	ret.x = -vec.x;
	ret.y = -vec.y;
	ret.z = -vec.z;

	return ret;
}

int main(void)
{
	vector3_t vv = { 1, 2, 3 };

	vector3_t retult = get_negation(vv);
}
~~~

![20231007_222850](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/4dfbd2bb-1d8b-4f04-b661-2c55c9efbf65)

  - stdcall
    - Windows API함수가 사용하는 호출 규약
      - WINAPI정의를 따라가 보면 __stdcall을 define해놓은것
    - Visual Basic은 stdcall만 지원
    - 인자 전달 : 오른쪽 -> 인쪽
    - 반환값 : cdecl과 동일
    - 스택 정리 : 함수 (callee)
      - 이것만 cdecl과 다르다 
      - 언제나 정해진 수의 인자만 제거할 수 있음
      - 따라서 가변인자 함수를 만들 수 없음
        - 컴파일러가 자동으로 cdecl로 바꿔줌
  - fastcall
    - 레지스터를 통해 인자를 전달해서 성능을 높이려는 시도
      - 후에 마이크로소프트 x64 호출 규약도 이와 비슷하게 동작
    - 인자 전달
      - 첫 두 인자, LTR : ecx, edx
      - 나머지 인자, RTL : 스택
    - 반환값 : cdecl 과 동일
    - 스택 정리 : 함수(callee)
    - fastcall은 인자 2개를 레지스터에 저장
    - asm__블록까지 왔을 때 이미 덮어 쓰였을 수 있음
    - 일반적인 조언
      - 인라인 어셈블리를 포함한 함수는 fastcall로 선언하지 말 것
      - 그 대신 cdecl이나 stdcall을 사용
  - thiscall
    - C++의 멤버 함수의 기본 호출 규약
    - 인자 전달
      - ecx : this 포인터
      - 스택 : 오른쪽 -> 왼쪽
    - 반환값 : cdecl과 동일
    - 스택 정리 : 함수(callee)
  - 그 외 호출 규약들
    - pascal
    - register
    - vectorcall
    - 마이크로소프트 x64호출 규약
    - 등

###### [인라인 어셈블리](#인라인-어셈블리)
###### [Top](#top)

<br/>
<br/>

# 정적 라이브러리, 동적 라이브러리
  - 정적 라이브러리
    - 정적 라이브러리는 컴파일 할때 하나로 합쳐서 .exe를 만들어 준다
    - .exe파일안에 모든 바이너리를 가지고 있는것
  - 동적 라이브러리
    - 함수 시그니쳐만 코딩이 되어 있고, 함수 구현은 코드안에 들어가지 않는다 -> 이게 함수 포인터
    - 실행할 때, 일반적으로 같은 폴더에 dll파일이 있고 같이 로드가 된다
    - 로드가 될때, 내 코드 시그니쳐가 dll에 맞는 함수 주소위치에 매칭이 된다 -> 간접 점프가 되는것

###### [인라인 어셈블리](#인라인-어셈블리)
###### [Top](#top)

<br/>
<br/>

***

# SIMD프로그래밍
  - SIMD : Single Instruction, Multiple Data
    - 데이터 병렬처리 방법 중 하나
    - 여러 개의 데이터에 명령어 하나를 동시에 실행
    - x86 CPU의 SIMD
      - 확장 기능(extenstions) 으로 들어 감
      - 별도의 레지스터와 명령어
      - XMM, SSE, AVX등
    - Intel과 AMD의 경쟁을 가열시킴
  - SIMD가 필요해진 이유
    - 컴퓨터를 갑자기 멀티미디어 용도로 쓰기 시작
      - 비디오 시청
      - 오디오 처리
      - 이미지 처리
      - 게임 등
    - 기본 CPU 명령어로는 이런 데이터를 효율적으로 처리하기 역부족
  - 멀티미디어 데이터의 특징
    - 무수히 많은 데이터 포인트로 이루어져 있음
    - 각 데이터 포인트는 동일한 포맷 (예: RGB)
    - 많은 데이터에 동일한 연산을 적용함
  - intel과 AMD의 많은 싸움들이 있었음
    - 아래 CPU정보에서 SIMD 지원을 확인할 수 있음

![20231007_223443](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/c47340c8-46ec-4fb4-8fb2-46c6f247ad24)

  - 요즘 C/C++ 컴파일러와 SIMD 코드
    - 자동 벡터화 최적화
      - 고수준 언어를 SIMD 어셈블리 명령어로 컴파일하는 기능
      - 지난 몇 년간 컴파일러에서 마개조 된 부분
    - 최적화 플래그를 켜고 컴파일할 때야 제대로 동작
      - 디버그 빌드는 주로 순정 x86 어셈블리로 컴파일
    - 일반 어셈블리 코드도 같이 만들어 줌
      - 해당 SIMD를 지원하지 않는 CPU를 위해
      - 지원 여부 판단 후 해당 코드로 점프

<br/>

  - MMX
    - 가장 처음 나온 SIMD명령어
    - ISA같은 명령어 집합 구조와 같다고 보면 된다
    - 정수 데이터 전용 SIMD명령어 집합 구조
    - 레지스터에 저장돼 있는 모든 정수를 동시에 연산
    - 디지털 신호 처리에 적합
      - 이미지
      - 영상
      - 오디오
    - 무언가의 약자가 아님
    - MMX의 레지스터
      - 64비트 레지스터 8개[mm0, mm7]
      - 데이터 저장 방법
        - 정수 하나만 저장
        - 8,16,32 비트 정수 여러 개를 벡터로 저장
      - FPU레지스터의 가수 부분과 겹침
        - 그 윗부분은 모두 1로 세팅
        - 스택 방식이 아닌 랜덤 접근

<br/>

  - 이동 및 상태 지우기 명령어
    - movd : 32비트 값을 복사
    - movq : 64비트 값을 복사
    - emms : MMX상태를 비움
  - 덧셈 명령어
    - paddb : 8비트 정수를 요소별로 더함
    - paddw : 16비트 정수를 요소별로 더함
    - paddd : 32비트 정수를 요소별로 더함
    - paddq : 64비트 정수를 더함
      - 32비트 CPU에서는 64비트끼리 더할 수 없는데, 이렇게 MMX를 사용하면 할 수 있게 해준다
    - paddsb : 부호 있는 8비트 정수를 요소별로 더함
    - paddsw : 부호 있는 16비트 정수를 요소별로 더함
    - paddusb : 부호 없는 8비트 정수를 요소별로 더함
    - paddusw : 부호 없는 16비트 정수를 요소별로 더함
  - 뺄셈 명령어
    - psubb : 8비트 정수를 요소별로 뺌
    - psubw : 16비트 정수를 요소별로 뺌
    - psubd : 32비트 정수를 요소별로 뺌
    - psubsb : 부호 있는 8비트 정수를 요소별로 뺌
    - psubsw : 부호 있는 16비트 정수를 요소별로 뺌
    - psubusb : 부호 없는 8비트 정수를 요소별로 뺌
    - psubusw : 부호 없는 16비트 정수를 요소별로 뺌

#test.c
~~~c
// 2차원 벡터 더하기
#include <stdio.h>

// 이 메모리가 8바이트의 레지스터 크기 만큼 정렬되어 있기를 요구한다
// MMX연산을 효율적으로 하기 위해서 사용
__declspec(align(8)) 
typedef struct vec2 {
	int x;
	int y;
} vec2_t;

int main(void)
{
	vec2_t v0;
	vec2_t v1;
	vec2_t r;

	v0.x = 2;
	v0.y = 1;

	v1.x = -1;
	v1.y = 3;

	__asm {
		movq mm0, v0  // v0을 mm0으로 이동
		paddd mm0, v1 // mm0과 v1을 더해서 mmo에 저장
		movq r,mm0 // mm0을 r에 저장

		emms // MMX 연산을 끝내고 FPU를 사용할 수 있도록 한다
	}

	printf("%d, %d\n", r.x, r.y);
}

// 1, 4
~~~

<br/>

#test.c
~~~c
// 총점 구하기
#include <stdio.h>

__declspec(align(8)) unsigned char lab2[8] = { 50, 83, 52, 100, 99, 81, 100, 100 };
__declspec(align(8)) unsigned char lab3[8] = { 1, 2, 3, 4, 5, 6, 7, 8 };
__declspec(align(8)) unsigned char total[8];

int main(void)
{
	__asm {
		movq mm0, lab2
		paddb mm0, lab3

		movq total, mm0
		emms
	}

	for(int i = 0; i < 8; i++)
		printf("%d ", total[i]);
}

// 51 85 55 104 104 87 107 108
~~~

  - 논리 연산 명령어
    - pand : 비트별 논리곱
    - por : 비트별 논리합
    - pxor : 비트별 배타적 논리합
    - pandn : 피연산자 하나의 비트를 반전 + 비트별 논리곱
  - unpack명령어
    - punpckhbw : 상위 32비트를 1바이트씩 교차 배치
    - punpckhwd : 상위 32비트를 2바이트씩 교차 배치
    - punpckhdq : 상위 32비트를 4바이트씩 교차 배치
    - punpcklbw : 하위 32비트를 1바이트씩 교차 배치
    - punpcklwd : 하위 32비트를 2바이트씩 교차 배치
    - punpckldq : 하위 32비트를 4바이트씩 교차 배치
  - SIMD용어 1 : unpack
    - 벡터 둘을 합쳐 그 보다 큰 벡터를 만드는 것
    - 각 벡터 레지스터의 절반만 사용
    - 주 용도
      - 정수의 확장
        - 부호 없는: src는 0
        - 부호 있는: src는 부호 비트
      - broadcast
  - SIMD용어2 : broadcast
    - SIMD 레지스터를 한 값으로 채우는 것
      - 32 비트 값을 2번 반복
      - 16 비트 값을 4번 반복
      - 8 비트 값을 8번 반복
  - SIMD용어3 : pack
    - 벡터를 작은 데이터형으로 변환하는 것
    - 레지스터 2개를 1개로 합침
  - SIMD용어4 : shuffle
    - 요소들의 순서를 자유롭게 선택해서 복사
    - 동일한 요소를 반복할 수도 있음
  - SIMD용어5 : horizontal
    - 같은 벡터에 있는 요소들끼리 연산

#test.c
~~~c
#include <stdio.h>

#define ALIGN8 __declspec(align(8))

int main(void)
{
	ALIGN8 short v[2] = {0x0123, 0x4567};

	__asm {
		movd mm0, v  // mm0 = 0x0000000045670123
		punpcklwd mm0, mm0 // mm0 = 0x4567456701230123
		punpckldq mm0, mm0 // mm0 = 0x0123012301230123

		emms
	}

}
~~~

<br/>

#test.c
~~~c
#include <stdio.h>

#define ALIGN8 __declspec(align(8))

int main(void)
{
	ALIGN8 int val = 0x0123ABCD;

	__asm {
		movd mm0, val // mm0 = 00000000 0123abcd
		punpckldq mm0, mm0 // mm0 = 0123abcd 0123abcd

		emms
	}

}
~~~

<br/>

#test.c
~~~c
#include <stdio.h>

#define ALIGN8 __declspec(align(8))

int main(void)
{
	ALIGN8 char v[4] = { 1, 2, 3, 4};
	 
	__asm {
		movd mm0, v // mm0 = 0x00000000 04030201
		punpcklbw mm0, mm0 // mm0 = 0x04040303 02020101
		punpcklwd mm0, mm0 // mm0 = 0x02020202 01010101
		punpckldq mm0, mm0 // mm0 = 0x01010101 01010101

		emms
	}

}
~~~

<br/>

#test.c
~~~c
#include <stdio.h>

#define ALIGN8 __declspec(align(8))

int main(void)
{
	ALIGN8 short v[4] = { 1, 2, 3, 4 };
	ALIGN8 short scale = 3;
	 
	__asm {
		movd mm1, scale
		punpcklwd mm1, mm1
		punpckldq mm1, mm1

		movq mm0, v
		pmullw mm0, mm1
		movq v, mm0

		emms
	}

	for(int i = 0; i < 4; i++)
		printf("%d ", v[i]);
}
~~~

  - 곱셈 명령어
    - pmulhw : 부호 있는 16비트 정수를 곱한 뒤 상위 16비트를 저장
    - pmullw : 부호 있는 16비트 정수를 곱한 뒤 하위 16비트를 저장
    - pmaddwd : 16비트 정수를 곱한 뒤 두 요소씩 더함
  - 비트 이동 명령어
    - 등등 있음
  - pack명령어
    - 등등 있음
  - 비교명령어
    - 등등 있음
  - SSE에서 추가된 MMX명령어도 있음
    - 등등 있음

<br/>

  - SSE(Streaming SIMD Extensions)
    - 부동 소수점 전용 SIMD명령어 집합 구조
      - 32비트 부동 소수점만 지원
      - 여전히 정수 연산은 MMX를 이용
    - 스칼라 연산도 지원
    - 128비트 레지스터 [xmm0, xmm7]
      - 독자 레지스터(FPU레지스터와 겹치지 않음)
      - 최대 4개의 부동 소수점을 동시 연산
    - x86-64에서 64비트 모드면 레지스터 8개가 더 있음

<br/>

  - SSE2
    - 64비트 부동 소수점 지원
    - MMX와 비슷한 정수 명령어를 지원
      - 더 큰 레지스터
      - 더 이상 MMX를 쓸 필요가 없음
      - x87 레지스터가 망가지는 걸 걱정하지 않아도 됨

<br/>

  - SSE3
    - 자잘한 업데이트
    - 주 변경 사항
      - 부동 소수점 : horizontal 연산 지원
      - 정수 : 정렬 안된 데이터를 로드하는 lddqu 명령어 추가
    - 이후, SSE4.1, SSE4.2가 나옴

<br/>

  - AVX(Advanced Vector Extensions)
    - 256비트 레지스터 [ymm0, ymm7]
      - 64 비트 모드면 [ymm8, ymm15]도 사용 가능
      - xmm부분만도 사용할 수 있음
    - 동시 연산
      - 32비트 부동 소수점 8개
      - 64비트 부동 소수점 4개
    - AVX의 주요 변경 사항
      - 별도의 dst 피연산자 지정을 허용
        - 두 src 피연산자가 모두 변하지 않음
      - broardcast 명령어를 추가
      - 바이트 정렬을 강제하지 않음
        - 벡터 크기에 맞출 필요가 없음
        - 여전히 맞추는 게 성능에 유리

<br/>

  - AVX2
    - 대부분의 SSE/AVX 정수 레지스터를 256 비트로 확장
    - gather 명령어 추가
    - 요소별 비트 이동 명령어 추가
    - SIMD용어6 : gather
비연속적인 데이터를 벡터로 로딩하는 것
shuffle처럼 이미 있는 벡터 데이터의 순서만 바꾸는 게 아님

<br/>

  - vectorcall호출 규약
    - fastcall에서 확장된 호출규약
      - SSE벡터 레지스터를 사용
    - 인자 전달
      - 정수형 인자 : 왼쪽에서 오른쪽
      - 벡터형 인자 : 왼쪽에서 오른쪽
      - 나머지 인자 : 오른쪽에서 왼쪽
    - 반환값 : cdecl과 동일
    - 스택 정리 : 함수(callee)

<br/>

  - AVX-512
    - x86 SIMD역사 상 가장 크고 야심 찬 변환
    - 512 비트 레지스터 [zmm0, zmm31]
    - 새로운 연산 들을 추가(예 : scatter)
    - 하위 명령어 집합으로 17개로 구성
      - 다 지원하는 CPU는 아직 없음
    - Visual C++ 2022에서 인라인 어셈블리어로 작성 불가
      - 내장 함수로 사용 가능 : #include <zmmintrin.h>
      - MASM으로 따로 어셈블 후 링크 가능
    - SIMD용어7 : scatter
      - gather의 반대 연산
      - 벡터에 있는 요소들을 메모리에 비연속적으로 저장

###### [SIMD프로그래밍](#simd프로그래밍)
###### [Top](#top)

<br/>
<br/>

***

# x86-64
  - 가장 큰 혜택
    - 최대 메모리 공간이 2^64로 확장
    - 레지스터 수가 늘어남
  - 기존 레지스터를 64비트로 확장
  - 범용 레지스터 8개 추가 [r8, r15]
  - 몇 가지 명령어도 추가

![20231007_224348](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/d21329b5-8973-47d6-8da7-24a1dd2e3c00)

  - 64비트로 올라갔다고 해서 32비트보다 속도가 빠른것은아니다. 만일 32비트에 넣을 레지스터 비트가 부족하거나 수가 부족해서 연산을 더 많이 해야 되는 경우라면 다르지만, 그렇지 않다면, 64비트는 더 많은 메모리를 복사해야 되기 때문에 더 느리다.

<br/>

  - 마이크로소프트 x64 호출 규약
    - 64비트 용으로 컴파일할 때 기본 호출 규약
      - 64비트 fastcall이라 표기하는 문서도 있음
    - 인자 전달
      - 첫 네 인자, 왼쪽 에서 오른쪽 : rcx, rdx, r8, r9 또는 xmm0~xmm3
      - 나머지 인자, 오른쪽 에서 왼쪽 : 스택
    - 반환값 : rax
    - 스택 정리 : 함수(callee)
    - 함수 보존 레지스터 : rbx, rbp, rdp, rsi, rsp, r12, r13, r14, r15

<br/>

  - Visual C++ 인라인 어셈블러
    - x86-64를 지원하지 않음(vs2022기준)
      - MS문서는 그 대신 컴파일러 내장함수를 추천
    - 약간의 수고로 여전히 VS IDE에 통합 가능
      - .asm 파일을 솔루션에 추가
      - ml64.exe로 따로 어셈블
      - 그 후 C/C++로 컴파일 한 다른 .obj 파일과 같이 링크

<br/>

  - 컴파일러 내장 함수
    - 컴파일러가 자체적으로 제공하는 함수
      - 라이브러리에서 오는 함수가 아님
      - 심볼이 보통 밑줄로 시작(예 : __cpuid(), __m256, __m256_u)
    - 컴파일러가 매우 매우 잘 이해하는 함수
      - 거의 인라인이 됨
      - 최적화를 매우 잘해줌
    - SIMD 프로그래밍에 많이 사용
      - 일반 프로그래밍 언어에 SIMD 데이터형이 없음
      - 벡터 레지스터를 손 관리하는 건 꽤 어려운 일
    - SIMD 내장 함수용 헤더 파일

![20231007_224543](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/3e288bc6-aea4-408e-823b-1305ea72e098)

  - 인라인 어셈블리와 내장 함수
    - 인라인 어셈블리어
      - 클래식 x86코드에 더 많이 사용
      - 디스어셈블 결과와 동일한 문법
      - 레지스터를 직접 제어
      - 종종 불명확한 컴파일러 오류 메시지
      - x64에서 사용 불가
    - 내장 함수
      - SIMD프로그래밍에 많이 사용
      - 새로운 API를 익혀야 함
      - 데이터 관리가 쉬움
      - 명확한 오류 메시지
      - x64에서 사용 가능

###### [x86-64](#x8664)
###### [Top](#top)

<br/>
<br/>

***

# 어셈블리어 개인 정리
  - eax: 계산에 대한 저장을 하는 데이터
  - ebx: 베이스 레지스터
  - ecx: 카운터 레지스터(숫자를 세거나)
  - edx: 데이터 레지스터
  - esi: 소스 인덱스 (출발지)
  - edi: 데스티네이션 인덱스 (목적지)
  - ebp: 스택의 아랫부분 (베이스) 포인터
  - esp: 스택의 윗부분 (탑) 포인터
  - eip: CPU가 다음에 실행할 명령어 주소

###### [어셈블리어 개인 정리](#어셈블리어-개인-정리)
###### [Top](#top)

<br/>
<br/>

***
