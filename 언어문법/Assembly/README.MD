<br/>

###### Top

- [컴퓨터 구조](#컴퓨터-구조)
  - [ALU(산술 논리 장치)](#alu산술-논리-장치)
  - [폰 노이만 구조](#폰-노이만-구조)
  - [CPU 명령어 사이클(instruction cycle)](#cpu-명령어-사이클instruction-cycle)
  - [명령어 집합(instruction set)](#명령어-집합instruction-set)
  - [6502 Assembly](#6502-assembly)
  - [명령어 집합 구조(ISA)](#명령어-집합-구조isa)
  - [일반적인 ISA의 명령어 분류](#일반적인-isa의-명령어-분류)
- [기계어 프로그래밍](#기계어-프로그래밍)
  - [6502CPU](#6502cpu)
  - [폰노이만 구조와 프로그램 실행](#폰노이만-구조와-프로그램-실행)
  - [임베디드 시스템과 프로그램 실행](#임베디드-시스템과-프로그램-실행)
  - [65C02의 핀 구성](#65C02의-핀-구성)
  - [조립하기](#조립하기)
  - [ROM](#rom)
  - [프로그램 작성하기](#프로그램-작성하기)
  - [타이밍 다이어그램](#타이밍-다이어그램)
  - [ROM과 RAM의 분리](#rom과-ram의-분리)
- [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
  - [기계어 대신 어셈블리 언어를 사용하는 이유](#기계어-대신-어셈블리-언어를-사용하는-이유)
  - [고수준 대신에 어셈블리 언어를 사용하는 이유](#고수준-대신에-어셈블리-언어를-사용하는-이유)
  - [어셈블리어](#어셈블리어)
  - [dasm](#dasm)
  - [어셈블러와 최적화](#어셈블러와-최적화)
  - [6502명령어의 구성](#6502명령어의-구성)
  - [A주소지정 모드(2사이클)와 6502의 파이프라인](#A주소지정-모드2사이클와-6502의-파이프라인)
  - [A모드 명령어 사이클(상세)](#a모드-명령어-사이클상세)
  - [#모드, 즉시(immedidate)모드(2사이클)](##모드-즉시immedidate모드2사이클)
  - [a모드 : 절대주소(4사이클)](#a모드--절대주소4사이클)
  - [6502의 메모리 페이지](#6502의-메모리-페이지)
  - [zp모드 : 제로 페이지 모드](#zp모드--제로-페이지-모드)
  - [주소지정 모드 종류](#주소지정-모드-종류)
  - [연산자](#연산자)
  - [변수와 상수](#변수와-상수)
  - [스택](#스택)
  - [상수 - 매직넘버, 상수형 변수](#상수--매직넘버-상수형-변수)
  - [데이터 블록](#데이터-블록)
  - [라벨](#라벨)
  - [레지스터(6502)](#레지스터6502)
  - [묵시적 명령어 몇개 소개](#묵시적-명령어-몇개-소개)
  - [프로그램 종료](#프로그램-종료)





<br/>
<br/>

***

# 컴퓨터 구조
  - 현대 CPU의 컴퓨터는 추상화를 함으로써 점차 만들어 졌다.
    - Transistors를 모아서 Logic Gates를 만들고, 그것을 보아서 가산기, 곱셈기를 만드는 것처럼, 제일 작은 단위를 모아 추상화를 하여 다른 장치를 만들어내고 있으며, Programming Languages또한 정말 많은 추상화를 통해서 만들어진 하나의 장치인 셈이다
    - Transistors는 가장 작은 단위인 셈이고, 그것을 몇개 모아서 Logic Gates를만든다
    - Logic Gates는 AND, OR, NOT과 같은 것을 의미하게 된다
    - Logic Gates는 아래와 같다
    - AND인지 OR인지, NOT인지 Transistors를 여럿 이용해서 만들고, A를 누를때 불이 들어올지, B를 눌렀을때 불이 들어올지, 둘다 눌렀을때 불이 들어올지는 게이트의 연산에 따라 달라지게 된다
    - Transistors -> Logic Gates -> 가산기, 곱셈기 -> ALU순으로 추상화 했다 할 수 있음

![20231004_084831](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/600b9f56-edf6-423e-916d-a5def3e4f398)

![20231004_084845](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/11a0b0be-145b-43e6-b55a-d4ce7ed23e79)

  - [ALU(산술 논리 장치)](#alu산술-논리-장치)
  - [폰 노이만 구조](#폰-노이만-구조)
  - [CPU 명령어 사이클(instruction cycle)](#cpu-명령어-사이클instruction-cycle)
  - [명령어 집합(instruction set)](#명령어-집합instruction-set)
  - [6502 Assembly](#6502-assembly)
  - [명령어 집합 구조(ISA)](#명령어-집합-구조isa)
  - [일반적인 ISA의 명령어 분류](#일반적인-isa의-명령어-분류)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# ALU(산술 논리 장치)
  - 이진수 정수의 산술 연산과 비트 연산을 담당하는 장치
  - 수많은 논리 게이트로 구성되어 있음
    - Integer Operand가 A,B로 들어갈때 더 이상 1비트가 아닌, 여러 비트의 조합인 이진수를 넣을 수 있음(더 이상 Transistors같은 아주 작은 단위를 보지 않게 됨) 수많은 Transistors의 조합으로 만들어져 있기 때문에
  - ALU의 입출력 값은 레지스터를 이용
  - ALU에 들어가는 입력값의 비트에 따라서 CPU가 몇 비트인지 이야기 할 수 있다
  - 두 이진수를 넣으면 연산 결과가 나옴
  - 실행할 연산 : opcode
    - 멀티플렉서의 선택 신호로 사용됨
  - 즉, 세 입력 신호가 필요
    - 피연산자 * 2
    - 연산 선택
  - opcode코드를 이용해서 곱셉인지 덧셈인지 등등 명령어를 준다고 할 수있고 이에 따라서, A 와 B에 있는 수많은 Logic Gates가 선택적 작동하게 된다
    - CPU안에 있는 제어장치(control unit)이, 언제 어떤 입력 신호를 넣어줄지 알게 제어해 준다(A 와 B에 어떤것 넣어 줄지, opcode에 어떤걸 넣어 줄지…)

![20231004_085126](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/1e193eac-a979-4bc9-942a-2eff254627b3)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 폰 노이만 구조
  - 모든 현대 컴퓨터는 지금도 폰 노이만 구조를 따르고 있다
  - 폰 노이만 구조의 세 구성 요소
    - 메모리 : 데이터와 명령어를 저장
    - CPU : 명령어를 decode및 실행
    - 입/출력 장치
  - 중앙 처리 장치
    - 처리장치
      - 산술/논리 장치 : ALU
      - 프로세서 레지스터
    - 제어장치(control unit) : 어떤 명령어를 이해하고 실행하게 해준다
      - 명령 레지스터(IR, Instruction Register)
      - 프로그램 카운터(PC, Program Counter) : 다음에 실행할 명령어의 위치 주소값을 가지고 있는곳


![20231004_085609](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f08f5bee-2310-4912-b4fe-239cd30d7ef3)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# CPU 명령어 사이클(instruction cycle)
  - CPU가 메모리에 저장된 기계어 하나를 실행할 때 거치는 과정들
    - 1. fetch :  명령어를 가져옴
    - 2. decode : (명령코드) opcode와 (피연산자)operand로 디코딩
      - Control Unit이 해줌
    - 3. execute : 산술/논리/분기 연산 등을 실행
      - ALU가 해줌
    - 4. write back : 연산 결과를 저장

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 명령어 집합(instruction set)
  - 어떤 기계가 지원하는 명령어들
  - 각 명령어는 명령 코드(opcode)와 피연산자(operand)로 구성
    - 메모리에는 이진수로 적혀 있음
  - 제어 장치는 메모리에 저장돼 있는 이진수를 순서대로 디코딩
    - opcode로부터 실행할 연산을 알아냄(=opcode와 비트 패턴의 매핑 관계)
    - 그 연산에 사용할 피연산자도 알아냄
    - 그 연산을 실행할 수 있는 장치에 필요한 입력값을 모두 전달

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 6502 Assembly
  - High nibble + Low nibble을 하면 하나의 16진수가 되고, 어떤 명령어를 실행할지 찾을 수 있다.
    - ex) 0110 1001(0x69) = ADC#
  - https://en.wikibooks.org/wiki/6502_Assembly 

![20231004_120327](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/42a15e3e-a7d5-470c-b440-b3d05a8c81f4)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 명령어 집합 구조(ISA)
  - 어떤 특정한 하드웨어의 규약!!!(다른 하드웨어는 다르게 만들어 질 수 있음!!)
  - 명령어 집합
  - 여러 CPU가 동일한 ISA를 지원할 수 있음
    - CPU마다 다른 이진 명령어를 만들지 않아도 됨
    - AMD와 intel CPU가 호환되는 이유
  - ISA가 정의하는 것들의 예
    - 기계어의 동작
    - 지원하는 데이터형
    - 레지스터
    - 메모리 모델 등
  - 어떠한 어셈블리어로 코딩을 한다는 것은, 어떤 모델에 맞는 ISA라는 명령어 집합을 정해서, 코딩을 한다는 것과 같다
    - 따라서, 애플사의 m1 cpu와 intel사의 isa의 집합이 다르다는것!!
  - Assembly 보다 추상화된 고수준의 코딩 언어를 컴파일러가 해석해, ISA수준까지 변환을 해준다

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 일반적인 ISA의 명령어 분류
  - 산술 연산(대부분)
  - 논리 연산
  - 메모리 관련(읽기, 저장, 이동 등)
  - 흐름 제어(분기 등)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

***

# 기계어 프로그래밍
  - [6502CPU](#6502cpu)
  - [폰노이만 구조와 프로그램 실행](#폰노이만-구조와-프로그램-실행)
  - [임베디드 시스템과 프로그램 실행](#임베디드-시스템과-프로그램-실행)
  - [65C02의 핀 구성](#65C02의-핀-구성)
  - [조립하기](#조립하기)
  - [ROM](#rom)
  - [프로그램 작성하기](#프로그램-작성하기)
  - [타이밍 다이어그램](#타이밍-다이어그램)
  - [ROM과 RAM의 분리](#rom과-ram의-분리)

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 6502CPU
  - 6502CPU
    - MOS 6502 프로세서
      - 1975년에 출시된 NMOS 기반 8비트 마이크로프로세서
      - 기존 8비트 CPU에 비해 단순한 설계로, 속도가 빠르고 가격이 저렴
      - 개인 컴퓨터의 부흥을 가져옴
      - cpu에서 하드웨어를 직접 제어
        - 운영체제 : 없음
        - BIOS : 없음
        - 부트로더 : 없음
    - WDC 65C02와 임베디드 시스템
      - 1981년 Western Design Center사에서 개발
      - MOS 6502와 후방 호환
        - NMOS 대신 CMOS를 사용
        - 전력 소비를 10~20배 줄임
      - 임베디드 시스템에서 매우 많이 쓰임
      - 데이터 너비 : 8비트
        - 한번에 8비트 단위로 데이터를 읽어 올 수 있다는 의미
      - 레지스터 수 : 6개
      - 명령어 수 : 56개

![20231004_172643](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/cabf8fec-cebd-4895-836e-0943899c7194)


![20231004_172655](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/c2819188-ae20-409c-a43d-863716495f39)


###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 폰노이만 구조와 프로그램 실행
  - 프로그램은 외부장치에 저장되어 있음
  - 따라서 cpu에게 프로그램이 저장된 위치를 알려줘야 한다
  - 데스크톱 컴퓨터에서는 보통 운영체제가 이런일을 해준다
    - 1. 운영체제로 컴퓨터가 부팅
    - 2. 사용자가 원하는 프로그램을 선택
    - 3. OS가 실행 권한을 그 프로그램에게 넘겨줌
  - 니모닉을 통해, 바이트를 하나하나 읽고 옵코드를 확인하고, fetch하고 실행하는 과정을 가진다

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 임베디드 시스템과 프로그램 실행
  - 보통 전원을 켜면 곧바로 프로그램 실행
  - 6502에서 흔히 사용하는 방법
    - 1. cpu리셋될 때 특정 메모리 주소에 저장된 값을 읽어옴
    - 2. 그 값이 가리키는 주소로 점프
    - 3. 그 주소에 저장된 명령어가 실행됨
    - 전원을 켜면, 운영체제를 실행하는것이 아니라, 내가 만든 프로그램을 곧바로 실행한다는것이 다르다.

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 65C02의 핀 구성
  - 각 핀들의 의미는 해당하는 CPU의 ‘datasheet’를 통해 아래와 같이 확인할 수 있다
    - 데이터핀 : 8비트(26번~33번)
    - 주소핀 : 16비트(9번~20번, 22번~25번)
    - VDD : 전원 전압의 +극 : 전원을 연결하는 곳
    - VSS : 접지(ground)

![20231004_173057](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/fff6459d-850d-467b-ae90-b1c486f8a7e4)

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 조립하기
  - 1. 브레드보드 준비(빵판)
    - 전도체를 꽂을 수 있는 구멍이 있음
    - 전기가 통하는 거라면 뭐든 꼽기 가능
    - 동일한 전류가 흐르는 영역이 존재
      - 터미널 띠(5개의 공간중 하나만 꼽아도 전기가 흐른다)

![20231004_173213](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/b5aa5deb-1b23-4ac9-b95e-6fdff8aa3751)

  - 각각 줄들의 값을 같게 하고 싶다면, 연결해 주면 된다

![20231004_173222](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/0ea79245-c0c9-4891-a6a4-21ef02798349)

![20231004_173233](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/8c60b7ab-d34b-4c52-a9a0-8ee30e27f295)

  - 버스띠
    - 전원을 연결해 주기 위해 존재

![20231004_173241](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/75b90b87-a818-44da-8e52-e32269ab8f30)

![20231004_173248](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/ebb2d282-b6a1-40ba-bec4-bec3a0f0451e)

  - 2. cpu설치 및 vdd, vss연결하기(전원연결)

![20231004_173255](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/822766fe-6f7e-40cd-b6a6-96938047c00d)

  - 3. 클럭 및 기타 선 연결하기
  - 4.기타 high핀을 연결
  - 5. cpu리셋 스위치 추가하기
  - 6. 클럭속도 늦추기
  - 7. 스파이더 연결하기
  - 기타 등등의 과정이 밑에 더 있음
  - 영상을 참고하면서 기억나지 않을때 다시 따라 해보기

![20231004_173302](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/7ab07d5e-989f-4549-8209-b93dbcc7a5a3)

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# ROM
  - 원칙상 한 번 쓰면 다시 수정 못하는 메모리
  - 요즘은 여러 번 쓸 수 있는 ROM을 주로 사용
    - EPROM, EEPROM
    - 그래도 실행 중에는 쓸 수 없게 하는 게 보통
    - 별도 하드웨어를 통해서만 쓸 수 있게 함

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 프로그램 작성하기
  - 6502CPU의 리셋백터는 0xFFFC, 0xFFFD이므로, 이곳에 프로그램 시작 주소를 적어야 한다

#test.c
~~~c
#include <stdio.h>
#include <string.h>
#include <assert.h>

#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable: 4996)
#define SIZE (0x8000)

int main()
{
	const char* FILENAME = "program.bin";

	FILE* outfile;
	char bin_out[SIZE] = { 0 };
	size_t program_size;

	const char program[] = {
		0x18,  // CLC
		0xA9, 0x0A, // LDA #$0A
		0x69, 0x06,  // ADC #$06
		0x8D, 0x00, 0x22  // STA $2200
	};

	program_size = sizeof(program) / sizeof(char);

	assert(program_size < 0x7FFC);

	memcpy(bin_out, program, program_size);

	bin_out[0x7FFC] = 0x00;
	bin_out[0x7FFD] = 0x80;

	outfile = fopen(FILENAME, "wb");

	if (outfile == NULL)
	{
		fprintf(stderr, "cannot open outfile");

		return -1;
	}

	fwrite(bin_out, sizeof(char), SIZE, outfile);

	fclose(outfile);

	return 0;
}
~~~

![20231004_173708](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f20edbe7-8278-4f41-96b9-4e007d4e0d7c)

  - FFFC와 FFFD는 리셋 백터 이기 때문에 여기서 8000주소로 점프하게 된다

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 타이밍 다이어그램
  - CPU가 RAM보다 속도가 빠르기 때문에, 서로간의 1사이클 동안에 어떤 EmptyButton시간에 어떻게 작동 되는지나와 있으며, 각자의 유효한 시간안에 정확하게 데이터를 교환하기 위함

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# ROM과 RAM의 분리
  - 코드와 데이터를 별도의 메모리에 담는 것 좋은 생각
  - 실행 중에 코드가 저장된 메모리를 덮어쓸 수 있으면 위험
    - 내가 작성한 코드의 동작을 남이 변경할 수 있음
    - 버퍼 오버 프로를 이용한 해킹이 그러한것
  - 따라서 아예 하드웨어 수준에서 방지하는게 최선책
    - 코드가 들어가 있는 메모리는 쓰기 금지
  - 하지만 최근 PC에는 ROM이 따로 없음
    - RAM에 모든 걸 집어넣되 다른 방법으로 막으려고 함
    - 예 : C언어의 코드 세그먼트와 데이터 세그먼트의 분리

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

***

# 6502 어셈블리 기초 문법
  - [기계어 대신 어셈블리 언어를 사용하는 이유](#기계어-대신-어셈블리-언어를-사용하는-이유)
  - [고수준 대신에 어셈블리 언어를 사용하는 이유](#고수준-대신에-어셈블리-언어를-사용하는-이유)
  - [어셈블리어](#어셈블리어)
  - [dasm](#dasm)
  - [어셈블러와 최적화](#어셈블러와-최적화)
  - [6502명령어의 구성](#6502명령어의-구성)
  - [A주소지정 모드(2사이클)와 6502의 파이프라인](#A주소지정-모드2사이클와-6502의-파이프라인)
  - [A모드 명령어 사이클(상세)](#a모드-명령어-사이클상세)
  - [#모드, 즉시(immedidate)모드(2사이클)](##모드-즉시immedidate모드2사이클)
  - [a모드 : 절대주소(4사이클)](#a모드--절대주소4사이클)
  - [6502의 메모리 페이지](#6502의-메모리-페이지)
  - [zp모드 : 제로 페이지 모드](#zp모드--제로-페이지-모드)
  - [주소지정 모드 종류](#주소지정-모드-종류)
  - [연산자](#연산자)
  - [변수와 상수](#변수와-상수)
  - [스택](#스택)
  - [상수 - 매직넘버, 상수형 변수](#상수--매직넘버-상수형-변수)
  - [데이터 블록](#데이터-블록)
  - [라벨](#라벨)
  - [레지스터(6502)](#레지스터6502)
  - [묵시적 명령어 몇개 소개](#묵시적-명령어-몇개-소개)
  - [프로그램 종료](#프로그램-종료)

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 기계어 대신 어셈블리 언어를 사용하는 이유
  - 기계어의 모든 장점을 가지고 있음
  - opcode를 읽기 편함
  - 바이트로 표현된 opcode보다 적은 opcode만 암기하면 됨
  	- 인자에 따라 주소지정 모드가 결정되기 때문
  - 프로그래머의 실수를 막을 수 있는 기능들이 있음
  	- “변수명”
  	- 라벨
  	- 매크로
  	- 등 등

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 고수준 대신에 어셈블리 언어를 사용하는 이유
  - 일반적으로 없음
  - 하지만 예외적인 상황들이 있음
  	- 일부 코드를 어셈블리어로 작성해 컴파일러보다 최적화를 더 잘하고 싶음
  	- 컴파일러가 지원 안 하는 하드웨어 기능을 사용하고 싶음
  	- 코드가 오작동하는 이유가 컴파일러 버그 때문이란 걸 확인하고 싶음
  	- 컴파일러 버그를 우회하고 싶음
  	- 고수준으로 작성한 언어가 실제 어떻게 동작하는지 확인하고 싶음
  	- 커스텀 하드웨어에서 간단한 제어 프로그램을 작성하고 싶음

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 어셈블리어
  - 언매니지드
  - 저수준
  - 컴파일 언어(정확히 말하면, 컴파일 언어라고 할 수는 없음
  	- 고수준의 언어를 어셈블하는 과정을 컴파일이라고 할 수 있음
  - 강타입, 약타입언어로 나뉠수 없음
  - 명령형 프로그래밍
  - 어셈블러
  	- 어셈블리어를 기계어 형태의 오브젝트 코드로 해석해 주는 컴퓨터 언어 번역 프로그램
  	- dasm, vasm 등
  - 따라서 고수준언어를 저수준 언어인 어셈블리어를 만들기 위해 컴파일을 하고 그 어셈블리어를 어셈블하여 기계어를 만든다

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# dasm
  - 1. dasm설치하기 https://dasm-assembler.github.io/

![20231005_084916](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/0fe1bd0d-4c6d-4dea-8ec3-a4187d9ffed0)

  - 2. 압축풀기
  - 3. exe가 있는 곳의 폴더 위치를 확인하고 환경 변수에 등록하기

![20231005_084928](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/2fd0e19e-95da-48f2-97ab-f91633ab37f7)

![20231005_084940](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/df6f7a20-ca0c-4797-9026-0f455bdfec68)

![20231005_084953](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f7c82f2a-f530-4791-be0c-168de1fe6db6)

  - 4. add.asm파일 만들고, cmd를 그곳에서 명령 실행하기
  - 5. 명령어

~~~asm
dasm add.asm -f3 -oadd.bin
// dasm을 실행하고, add.asm은 내가 만든 파일, -f3은 컴파일 옵션, -o는 어떤 파일을 아웃풋으로 낼껀지, add.bin파일을 아웃풋으로 내겠다는뜻
~~~

<br/>

# add.asm
~~~asm
// 코드를 쓸때 TAB을 해준다
// 다양한 ISA를 어셈블 할 수 있기 때문에 맨 위에 어떤 ISA를 사용하는 CPU 프로세서를 명시해준다(ex. .PROCESSOR 6502)
	.PROCESSOR 6502 
// ROM시작 주소를 언급해준다(ex. .ORG $8000)
	.ORG $8000 

	clc
	lda #$04
	adc #$06
	sta $2200

// 리셋 벡터를 적어 준다(ex. ORG $FFFC)
// ORG $FFFC 아래에 있는 것들이 FFFC에서부터 시작 된다는 것을 알려줌
// 6502 CPU는 리셋 벡터가 FFFC, FFFD로 시작한다(CPU가 강제하는 상황이기 때문에 무조건)
// FFFC : 1111 1111 1111 1100
// FFFD : 1111 1111 1111 1101
	.ORG $FFFC,0 

// WORD는 2바이트를 의미
// 리틀 엔디안 이기 때문에 실제 메모리에는 0080으로 들어가게 된다
	.WORD $8000
	.WORD $0000
~~~

  - 6.성공!!

![20231005_090233](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/a21c5921-c92b-4515-a24d-90720f4f1dfb)

  - 7. 주의점
  	- 실행할때 powerShell에서 하면 명령어 작동이 되지 않았음..참고! 

# a.asm
~~~asm
	.PROCESSOR 6502
	.ORG $1000

	clc
	lda $C000
	adc $C001
	adc $C002
	adc $C003
	sta $1000

	.ORG $2000, 0
	.BYTE $00, $01, $02, $03
	.BYTE "Hello World"
	.BYTE  0 ; 널 문자
	.WORD $1000, $1001

	.ORG $FFFC,0
	.WORD $8000
	.WORD $0000
~~~

  - 바로 위의 코드를 다시 설명해 보면, ROM시작 주소가 1000이기 때문에
  - ORG $2000, 0은 1000부터 기록이 되고
  - ORG $FFFC, 0은 EFFFC,0부터 기록이 된다

# a.asm
~~~c
	.PROCESSOR 6502
	.ORG $8000

	clc
	lda $C000   -> 여기는 0부터 기록이 됨 여기부터 실행되고 C0000에 있는 것을 가져와서 실행하게 됨
	adc $C001
	adc $C002
	adc $C003
	sta $1000

	.ORG $C000, 0   -> 4000부터 기록이 됨
	.BYTE $00, $01, $02, $03
	.BYTE "Hello World"
	.BYTE  0 ; 널 문자
	.WORD $1000, $1001

	.ORG $FFFC,0
	.WORD $8000
	.WORD $0000
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 어셈블러와 최적화
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 6502명령어의 구성
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# A주소지정 모드(2사이클)와 6502의 파이프라인
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# A모드 명령어 사이클(상세)
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# #모드, 즉시(immedidate)모드(2사이클)
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# a모드 : 절대주소(4사이클)
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 6502의 메모리 페이지
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# zp모드 : 제로 페이지 모드
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 주소지정 모드 종류
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 연산자
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 변수와 상수
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 스택
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 상수 - 매직넘버, 상수형 변수
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 데이터 블록
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 라벨
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 레지스터(6502)
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 묵시적 명령어 몇개 소개
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 프로그램 종료
  - 


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>
