<br/>

###### Top

- [컴퓨터 구조](#컴퓨터-구조)
  - [ALU(산술 논리 장치)](#alu산술-논리-장치)
  - [폰 노이만 구조](#폰-노이만-구조)
  - [CPU 명령어 사이클(instruction cycle)](#cpu-명령어-사이클instruction-cycle)
  - [명령어 집합(instruction set)](#명령어-집합instruction-set)
  - [6502 Assembly](#6502-assembly)
  - [명령어 집합 구조(ISA)](#명령어-집합-구조isa)
  - [일반적인 ISA의 명령어 분류](#일반적인-isa의-명령어-분류)
- [기계어 프로그래밍](#기계어-프로그래밍)
  - [6502CPU](#6502cpu)
  - [폰노이만 구조와 프로그램 실행](#폰노이만-구조와-프로그램-실행)
  - [임베디드 시스템과 프로그램 실행](#임베디드-시스템과-프로그램-실행)
  - [65C02의 핀 구성](#65C02의-핀-구성)
  - [조립하기](#조립하기)
  - [ROM](#rom)
  - [프로그램 작성하기](#프로그램-작성하기)
  - [타이밍 다이어그램](#타이밍-다이어그램)
  - [ROM과 RAM의 분리](#rom과-ram의-분리)
- [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
  - [기계어 대신 어셈블리 언어를 사용하는 이유](#기계어-대신-어셈블리-언어를-사용하는-이유)
  - [고수준 대신에 어셈블리 언어를 사용하는 이유](#고수준-대신에-어셈블리-언어를-사용하는-이유)
  - [어셈블리어](#어셈블리어)
  - [dasm](#dasm)
  - [어셈블러와 최적화](#어셈블러와-최적화)
  - [6502명령어의 구성](#6502명령어의-구성)
  - [A주소지정 모드(2사이클)와 6502의 파이프라인](#A주소지정-모드2사이클와-6502의-파이프라인)
  - [A모드 명령어 사이클(상세)](#a모드-명령어-사이클상세)
  - [#모드, 즉시(immedidate)모드(2사이클)](##모드-즉시immedidate모드2사이클)
  - [a모드 : 절대주소(4사이클)](#a모드--절대주소4사이클)
  - [6502의 메모리 페이지](#6502의-메모리-페이지)
  - [zp모드 : 제로 페이지 모드](#zp모드--제로-페이지-모드)
  - [주소지정 모드 종류](#주소지정-모드-종류)
  - [연산자](#연산자)
  - [변수와 상수](#변수와-상수)
  - [스택](#스택)
  - [상수 - 매직넘버, 상수형 변수](#상수--매직넘버-상수형-변수)
  - [데이터 블록](#데이터-블록)
  - [라벨](#라벨)
  - [레지스터(6502)](#레지스터6502)
  - [묵시적 명령어 몇개 소개](#묵시적-명령어-몇개-소개)
  - [프로그램 종료](#프로그램-종료)
- [6502어셈블리 니모닉 정리](#6502어셈블리-니모닉-정리)
- [6502어셈블리 플래그 정리](#6502어셈블리-플래그-정리)
- [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
  - [adc : 받아올림을 이용한 덧셈(C, V플래그)](#adc-받아올림을-이용한-덧셈c-v플래그)
  - [sbc : 받아내림을 이용한 뺄셈](#sbc--받아내림을-이용한-뺄셈)
  - [증감 연산](#증감-연산)
  - [색인 주소지정 모드](#색인-주소지정-모드)
  - [페이지 크로싱](#페이지-크로싱)
  - [비트 이동/회전 연산](#비트-이동회전-연산)
  - [논리 연산, NOT연산구현,6502에 없는 연산들..](#논리-연산-not연산구현6502에-없는-연산들)
  - [CPU에 데이터 형은 없다 해석은 남의 몫](#cpu에-데이터-형은-없다-해석은-남의-몫)
  - [단항 바이트 연산자](#단항-바이트-연산자)
- [조건문](#조건문)
  - [cmp, jmp, beq, bne, bcc, bcs](#cmp-jmp-beq-bne-bcc-bcs)
  - [bmi, bpl, bvc, bvs](#bmi-bpl-bvc-bvs)
  - [조건문 작성](#조건문-작성)
  - [상대 주소지정 모드](#상대-주소지정-모드)
  - [기타if문 관련](#기타if문-관련)






<br/>
<br/>

***

# 컴퓨터 구조
  - 현대 CPU의 컴퓨터는 추상화를 함으로써 점차 만들어 졌다.
    - Transistors를 모아서 Logic Gates를 만들고, 그것을 보아서 가산기, 곱셈기를 만드는 것처럼, 제일 작은 단위를 모아 추상화를 하여 다른 장치를 만들어내고 있으며, Programming Languages또한 정말 많은 추상화를 통해서 만들어진 하나의 장치인 셈이다
    - Transistors는 가장 작은 단위인 셈이고, 그것을 몇개 모아서 Logic Gates를만든다
    - Logic Gates는 AND, OR, NOT과 같은 것을 의미하게 된다
    - Logic Gates는 아래와 같다
    - AND인지 OR인지, NOT인지 Transistors를 여럿 이용해서 만들고, A를 누를때 불이 들어올지, B를 눌렀을때 불이 들어올지, 둘다 눌렀을때 불이 들어올지는 게이트의 연산에 따라 달라지게 된다
    - Transistors -> Logic Gates -> 가산기, 곱셈기 -> ALU순으로 추상화 했다 할 수 있음

![20231004_084831](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/600b9f56-edf6-423e-916d-a5def3e4f398)

![20231004_084845](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/11a0b0be-145b-43e6-b55a-d4ce7ed23e79)

  - [ALU(산술 논리 장치)](#alu산술-논리-장치)
  - [폰 노이만 구조](#폰-노이만-구조)
  - [CPU 명령어 사이클(instruction cycle)](#cpu-명령어-사이클instruction-cycle)
  - [명령어 집합(instruction set)](#명령어-집합instruction-set)
  - [6502 Assembly](#6502-assembly)
  - [명령어 집합 구조(ISA)](#명령어-집합-구조isa)
  - [일반적인 ISA의 명령어 분류](#일반적인-isa의-명령어-분류)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# ALU(산술 논리 장치)
  - 이진수 정수의 산술 연산과 비트 연산을 담당하는 장치
  - 수많은 논리 게이트로 구성되어 있음
    - Integer Operand가 A,B로 들어갈때 더 이상 1비트가 아닌, 여러 비트의 조합인 이진수를 넣을 수 있음(더 이상 Transistors같은 아주 작은 단위를 보지 않게 됨) 수많은 Transistors의 조합으로 만들어져 있기 때문에
  - ALU의 입출력 값은 레지스터를 이용
  - ALU에 들어가는 입력값의 비트에 따라서 CPU가 몇 비트인지 이야기 할 수 있다
  - 두 이진수를 넣으면 연산 결과가 나옴
  - 실행할 연산 : opcode
    - 멀티플렉서의 선택 신호로 사용됨
  - 즉, 세 입력 신호가 필요
    - 피연산자 * 2
    - 연산 선택
  - opcode코드를 이용해서 곱셉인지 덧셈인지 등등 명령어를 준다고 할 수있고 이에 따라서, A 와 B에 있는 수많은 Logic Gates가 선택적 작동하게 된다
    - CPU안에 있는 제어장치(control unit)이, 언제 어떤 입력 신호를 넣어줄지 알게 제어해 준다(A 와 B에 어떤것 넣어 줄지, opcode에 어떤걸 넣어 줄지…)

![20231004_085126](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/1e193eac-a979-4bc9-942a-2eff254627b3)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 폰 노이만 구조
  - 모든 현대 컴퓨터는 지금도 폰 노이만 구조를 따르고 있다
  - 폰 노이만 구조의 세 구성 요소
    - 메모리 : 데이터와 명령어를 저장
    - CPU : 명령어를 decode및 실행
    - 입/출력 장치
  - 중앙 처리 장치
    - 처리장치
      - 산술/논리 장치 : ALU
      - 프로세서 레지스터
    - 제어장치(control unit) : 어떤 명령어를 이해하고 실행하게 해준다
      - 명령 레지스터(IR, Instruction Register)
      - 프로그램 카운터(PC, Program Counter) : 다음에 실행할 명령어의 위치 주소값을 가지고 있는곳


![20231004_085609](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f08f5bee-2310-4912-b4fe-239cd30d7ef3)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# CPU 명령어 사이클(instruction cycle)
  - CPU가 메모리에 저장된 기계어 하나를 실행할 때 거치는 과정들
    - 1. fetch :  명령어를 가져옴
    - 2. decode : (명령코드) opcode와 (피연산자)operand로 디코딩
      - Control Unit이 해줌
    - 3. execute : 산술/논리/분기 연산 등을 실행
      - ALU가 해줌
    - 4. write back : 연산 결과를 저장

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 명령어 집합(instruction set)
  - 어떤 기계가 지원하는 명령어들
  - 각 명령어는 명령 코드(opcode)와 피연산자(operand)로 구성
    - 메모리에는 이진수로 적혀 있음
  - 제어 장치는 메모리에 저장돼 있는 이진수를 순서대로 디코딩
    - opcode로부터 실행할 연산을 알아냄(=opcode와 비트 패턴의 매핑 관계)
    - 그 연산에 사용할 피연산자도 알아냄
    - 그 연산을 실행할 수 있는 장치에 필요한 입력값을 모두 전달

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 6502 Assembly
  - High nibble + Low nibble을 하면 하나의 16진수가 되고, 어떤 명령어를 실행할지 찾을 수 있다.
    - ex) 0110 1001(0x69) = ADC#
  - https://en.wikibooks.org/wiki/6502_Assembly 

![20231004_120327](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/42a15e3e-a7d5-470c-b440-b3d05a8c81f4)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 명령어 집합 구조(ISA)
  - 어떤 특정한 하드웨어의 규약!!!(다른 하드웨어는 다르게 만들어 질 수 있음!!)
  - 명령어 집합
  - 여러 CPU가 동일한 ISA를 지원할 수 있음
    - CPU마다 다른 이진 명령어를 만들지 않아도 됨
    - AMD와 intel CPU가 호환되는 이유
  - ISA가 정의하는 것들의 예
    - 기계어의 동작
    - 지원하는 데이터형
    - 레지스터
    - 메모리 모델 등
  - 어떠한 어셈블리어로 코딩을 한다는 것은, 어떤 모델에 맞는 ISA라는 명령어 집합을 정해서, 코딩을 한다는 것과 같다
    - 따라서, 애플사의 m1 cpu와 intel사의 isa의 집합이 다르다는것!!
  - Assembly 보다 추상화된 고수준의 코딩 언어를 컴파일러가 해석해, ISA수준까지 변환을 해준다

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

# 일반적인 ISA의 명령어 분류
  - 산술 연산(대부분)
  - 논리 연산
  - 메모리 관련(읽기, 저장, 이동 등)
  - 흐름 제어(분기 등)

###### [컴퓨터 구조](#컴퓨터-구조)
###### [Top](#top)

<br/>
<br/>

***

# 기계어 프로그래밍
  - [6502CPU](#6502cpu)
  - [폰노이만 구조와 프로그램 실행](#폰노이만-구조와-프로그램-실행)
  - [임베디드 시스템과 프로그램 실행](#임베디드-시스템과-프로그램-실행)
  - [65C02의 핀 구성](#65C02의-핀-구성)
  - [조립하기](#조립하기)
  - [ROM](#rom)
  - [프로그램 작성하기](#프로그램-작성하기)
  - [타이밍 다이어그램](#타이밍-다이어그램)
  - [ROM과 RAM의 분리](#rom과-ram의-분리)

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 6502CPU
  - 6502CPU
    - MOS 6502 프로세서
      - 1975년에 출시된 NMOS 기반 8비트 마이크로프로세서
      - 기존 8비트 CPU에 비해 단순한 설계로, 속도가 빠르고 가격이 저렴
      - 개인 컴퓨터의 부흥을 가져옴
      - cpu에서 하드웨어를 직접 제어
        - 운영체제 : 없음
        - BIOS : 없음
        - 부트로더 : 없음
    - WDC 65C02와 임베디드 시스템
      - 1981년 Western Design Center사에서 개발
      - MOS 6502와 후방 호환
        - NMOS 대신 CMOS를 사용
        - 전력 소비를 10~20배 줄임
      - 임베디드 시스템에서 매우 많이 쓰임
      - 데이터 너비 : 8비트
        - 한번에 8비트 단위로 데이터를 읽어 올 수 있다는 의미
      - 레지스터 수 : 6개
      - 명령어 수 : 56개

![20231004_172643](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/cabf8fec-cebd-4895-836e-0943899c7194)


![20231004_172655](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/c2819188-ae20-409c-a43d-863716495f39)


###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 폰노이만 구조와 프로그램 실행
  - 프로그램은 외부장치에 저장되어 있음
  - 따라서 cpu에게 프로그램이 저장된 위치를 알려줘야 한다
  - 데스크톱 컴퓨터에서는 보통 운영체제가 이런일을 해준다
    - 1. 운영체제로 컴퓨터가 부팅
    - 2. 사용자가 원하는 프로그램을 선택
    - 3. OS가 실행 권한을 그 프로그램에게 넘겨줌
  - 니모닉을 통해, 바이트를 하나하나 읽고 옵코드를 확인하고, fetch하고 실행하는 과정을 가진다

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 임베디드 시스템과 프로그램 실행
  - 보통 전원을 켜면 곧바로 프로그램 실행
  - 6502에서 흔히 사용하는 방법
    - 1. cpu리셋될 때 특정 메모리 주소에 저장된 값을 읽어옴
    - 2. 그 값이 가리키는 주소로 점프
    - 3. 그 주소에 저장된 명령어가 실행됨
    - 전원을 켜면, 운영체제를 실행하는것이 아니라, 내가 만든 프로그램을 곧바로 실행한다는것이 다르다.

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 65C02의 핀 구성
  - 각 핀들의 의미는 해당하는 CPU의 ‘datasheet’를 통해 아래와 같이 확인할 수 있다
    - 데이터핀 : 8비트(26번~33번)
    - 주소핀 : 16비트(9번~20번, 22번~25번)
    - VDD : 전원 전압의 +극 : 전원을 연결하는 곳
    - VSS : 접지(ground)

![20231004_173057](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/fff6459d-850d-467b-ae90-b1c486f8a7e4)

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 조립하기
  - 1. 브레드보드 준비(빵판)
    - 전도체를 꽂을 수 있는 구멍이 있음
    - 전기가 통하는 거라면 뭐든 꼽기 가능
    - 동일한 전류가 흐르는 영역이 존재
      - 터미널 띠(5개의 공간중 하나만 꼽아도 전기가 흐른다)

![20231004_173213](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/b5aa5deb-1b23-4ac9-b95e-6fdff8aa3751)

  - 각각 줄들의 값을 같게 하고 싶다면, 연결해 주면 된다

![20231004_173222](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/0ea79245-c0c9-4891-a6a4-21ef02798349)

![20231004_173233](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/8c60b7ab-d34b-4c52-a9a0-8ee30e27f295)

  - 버스띠
    - 전원을 연결해 주기 위해 존재

![20231004_173241](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/75b90b87-a818-44da-8e52-e32269ab8f30)

![20231004_173248](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/ebb2d282-b6a1-40ba-bec4-bec3a0f0451e)

  - 2. cpu설치 및 vdd, vss연결하기(전원연결)

![20231004_173255](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/822766fe-6f7e-40cd-b6a6-96938047c00d)

  - 3. 클럭 및 기타 선 연결하기
  - 4.기타 high핀을 연결
  - 5. cpu리셋 스위치 추가하기
  - 6. 클럭속도 늦추기
  - 7. 스파이더 연결하기
  - 기타 등등의 과정이 밑에 더 있음
  - 영상을 참고하면서 기억나지 않을때 다시 따라 해보기

![20231004_173302](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/7ab07d5e-989f-4549-8209-b93dbcc7a5a3)

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# ROM
  - 원칙상 한 번 쓰면 다시 수정 못하는 메모리
  - 요즘은 여러 번 쓸 수 있는 ROM을 주로 사용
    - EPROM, EEPROM
    - 그래도 실행 중에는 쓸 수 없게 하는 게 보통
    - 별도 하드웨어를 통해서만 쓸 수 있게 함

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 프로그램 작성하기
  - 6502CPU의 리셋백터는 0xFFFC, 0xFFFD이므로, 이곳에 프로그램 시작 주소를 적어야 한다

#test.c
~~~c
#include <stdio.h>
#include <string.h>
#include <assert.h>

#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable: 4996)
#define SIZE (0x8000)

int main()
{
	const char* FILENAME = "program.bin";

	FILE* outfile;
	char bin_out[SIZE] = { 0 };
	size_t program_size;

	const char program[] = {
		0x18,  // CLC
		0xA9, 0x0A, // LDA #$0A
		0x69, 0x06,  // ADC #$06
		0x8D, 0x00, 0x22  // STA $2200
	};

	program_size = sizeof(program) / sizeof(char);

	assert(program_size < 0x7FFC);

	memcpy(bin_out, program, program_size);

	bin_out[0x7FFC] = 0x00;
	bin_out[0x7FFD] = 0x80;

	outfile = fopen(FILENAME, "wb");

	if (outfile == NULL)
	{
		fprintf(stderr, "cannot open outfile");

		return -1;
	}

	fwrite(bin_out, sizeof(char), SIZE, outfile);

	fclose(outfile);

	return 0;
}
~~~

![20231004_173708](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f20edbe7-8278-4f41-96b9-4e007d4e0d7c)

  - FFFC와 FFFD는 리셋 백터 이기 때문에 여기서 8000주소로 점프하게 된다

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# 타이밍 다이어그램
  - CPU가 RAM보다 속도가 빠르기 때문에, 서로간의 1사이클 동안에 어떤 EmptyButton시간에 어떻게 작동 되는지나와 있으며, 각자의 유효한 시간안에 정확하게 데이터를 교환하기 위함

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

# ROM과 RAM의 분리
  - 코드와 데이터를 별도의 메모리에 담는 것 좋은 생각
  - 실행 중에 코드가 저장된 메모리를 덮어쓸 수 있으면 위험
    - 내가 작성한 코드의 동작을 남이 변경할 수 있음
    - 버퍼 오버 프로를 이용한 해킹이 그러한것
  - 따라서 아예 하드웨어 수준에서 방지하는게 최선책
    - 코드가 들어가 있는 메모리는 쓰기 금지
  - 하지만 최근 PC에는 ROM이 따로 없음
    - RAM에 모든 걸 집어넣되 다른 방법으로 막으려고 함
    - 예 : C언어의 코드 세그먼트와 데이터 세그먼트의 분리

###### [기계어 프로그래밍](#기계어-프로그래밍)
###### [Top](#top)

<br/>
<br/>

***

# 6502 어셈블리 기초 문법
  - [기계어 대신 어셈블리 언어를 사용하는 이유](#기계어-대신-어셈블리-언어를-사용하는-이유)
  - [고수준 대신에 어셈블리 언어를 사용하는 이유](#고수준-대신에-어셈블리-언어를-사용하는-이유)
  - [어셈블리어](#어셈블리어)
  - [dasm](#dasm)
  - [어셈블러와 최적화](#어셈블러와-최적화)
  - [6502명령어의 구성](#6502명령어의-구성)
  - [A주소지정 모드(2사이클)와 6502의 파이프라인](#A주소지정-모드2사이클와-6502의-파이프라인)
  - [A모드 명령어 사이클(상세)](#a모드-명령어-사이클상세)
  - [#모드, 즉시(immedidate)모드(2사이클)](##모드-즉시immedidate모드2사이클)
  - [a모드 : 절대주소(4사이클)](#a모드--절대주소4사이클)
  - [6502의 메모리 페이지](#6502의-메모리-페이지)
  - [zp모드 : 제로 페이지 모드](#zp모드--제로-페이지-모드)
  - [주소지정 모드 종류](#주소지정-모드-종류)
  - [연산자](#연산자)
  - [변수와 상수](#변수와-상수)
  - [스택](#스택)
  - [상수 - 매직넘버, 상수형 변수](#상수--매직넘버-상수형-변수)
  - [데이터 블록](#데이터-블록)
  - [라벨](#라벨)
  - [레지스터(6502)](#레지스터6502)
  - [묵시적 명령어 몇개 소개](#묵시적-명령어-몇개-소개)
  - [프로그램 종료](#프로그램-종료)

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 기계어 대신 어셈블리 언어를 사용하는 이유
  - 기계어의 모든 장점을 가지고 있음
  - opcode를 읽기 편함
  - 바이트로 표현된 opcode보다 적은 opcode만 암기하면 됨
  	- 인자에 따라 주소지정 모드가 결정되기 때문
  - 프로그래머의 실수를 막을 수 있는 기능들이 있음
  	- “변수명”
  	- 라벨
  	- 매크로
  	- 등 등

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 고수준 대신에 어셈블리 언어를 사용하는 이유
  - 일반적으로 없음
  - 하지만 예외적인 상황들이 있음
  	- 일부 코드를 어셈블리어로 작성해 컴파일러보다 최적화를 더 잘하고 싶음
  	- 컴파일러가 지원 안 하는 하드웨어 기능을 사용하고 싶음
  	- 코드가 오작동하는 이유가 컴파일러 버그 때문이란 걸 확인하고 싶음
  	- 컴파일러 버그를 우회하고 싶음
  	- 고수준으로 작성한 언어가 실제 어떻게 동작하는지 확인하고 싶음
  	- 커스텀 하드웨어에서 간단한 제어 프로그램을 작성하고 싶음

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 어셈블리어
  - 언매니지드
  - 저수준
  - 컴파일 언어(정확히 말하면, 컴파일 언어라고 할 수는 없음
  	- 고수준의 언어를 어셈블하는 과정을 컴파일이라고 할 수 있음
  - 강타입, 약타입언어로 나뉠수 없음
  - 명령형 프로그래밍
  - 어셈블러
  	- 어셈블리어를 기계어 형태의 오브젝트 코드로 해석해 주는 컴퓨터 언어 번역 프로그램
  	- dasm, vasm 등
  - 따라서 고수준언어를 저수준 언어인 어셈블리어를 만들기 위해 컴파일을 하고 그 어셈블리어를 어셈블하여 기계어를 만든다

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# dasm
  - 1. dasm설치하기 https://dasm-assembler.github.io/

![20231005_084916](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/0fe1bd0d-4c6d-4dea-8ec3-a4187d9ffed0)

  - 2. 압축풀기
  - 3. exe가 있는 곳의 폴더 위치를 확인하고 환경 변수에 등록하기

![20231005_084928](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/2fd0e19e-95da-48f2-97ab-f91633ab37f7)

![20231005_084940](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/df6f7a20-ca0c-4797-9026-0f455bdfec68)

![20231005_084953](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f7c82f2a-f530-4791-be0c-168de1fe6db6)

  - 4. add.asm파일 만들고, cmd를 그곳에서 명령 실행하기
  - 5. 명령어

#add.asm
~~~c
dasm add.asm -f3 -oadd.bin
// dasm을 실행하고, add.asm은 내가 만든 파일, -f3은 컴파일 옵션, -o는 어떤 파일을 아웃풋으로 낼껀지, add.bin파일을 아웃풋으로 내겠다는뜻
~~~

<br/>

#add.asm
~~~c
// 코드를 쓸때 TAB을 해준다
// 다양한 ISA를 어셈블 할 수 있기 때문에 맨 위에 어떤 ISA를 사용하는 CPU 프로세서를 명시해준다(ex. .PROCESSOR 6502)
	.PROCESSOR 6502 
// ROM시작 주소를 언급해준다(ex. .ORG $8000)
	.ORG $8000 

	clc
	lda #$04
	adc #$06
	sta $2200

// 리셋 벡터를 적어 준다(ex. ORG $FFFC)
// ORG $FFFC 아래에 있는 것들이 FFFC에서부터 시작 된다는 것을 알려줌
// 6502 CPU는 리셋 벡터가 FFFC, FFFD로 시작한다(CPU가 강제하는 상황이기 때문에 무조건)
// FFFC : 1111 1111 1111 1100
// FFFD : 1111 1111 1111 1101
	.ORG $FFFC,0 

// WORD는 2바이트를 의미
// 리틀 엔디안 이기 때문에 실제 메모리에는 0080으로 들어가게 된다
	.WORD $8000
	.WORD $0000
~~~

  - 6.성공!!

![20231005_090233](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/a21c5921-c92b-4515-a24d-90720f4f1dfb)

  - 7. 주의점
  	- 실행할때 powerShell에서 하면 명령어 작동이 되지 않았음..참고! 

#a.asm
~~~c
	.PROCESSOR 6502
	.ORG $1000

	clc
	lda $C000
	adc $C001
	adc $C002
	adc $C003
	sta $1000

	.ORG $2000, 0
	.BYTE $00, $01, $02, $03
	.BYTE "Hello World"
	.BYTE  0 ; 널 문자
	.WORD $1000, $1001

	.ORG $FFFC,0
	.WORD $8000
	.WORD $0000
~~~

  - 바로 위의 코드를 다시 설명해 보면, ROM시작 주소가 1000이기 때문에
  - ORG $2000, 0은 1000부터 기록이 되고
  - ORG $FFFC, 0은 EFFFC,0부터 기록이 된다

#a.asm
~~~c
	.PROCESSOR 6502
	.ORG $8000

	clc
	lda $C000   -> 여기는 0부터 기록이 됨 여기부터 실행되고 C0000에 있는 것을 가져와서 실행하게 됨
	adc $C001
	adc $C002
	adc $C003
	sta $1000

	.ORG $C000, 0   -> 4000부터 기록이 됨
	.BYTE $00, $01, $02, $03
	.BYTE "Hello World"
	.BYTE  0 ; 널 문자
	.WORD $1000, $1001

	.ORG $FFFC,0
	.WORD $8000
	.WORD $0000
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 어셈블러와 최적화
  - 컴파일러는 보통 최적화를 해줌
  	- 고수준 언어와 최종 하드웨어 ISA의 차이가 큼
  	- 따라서 컴파일러가 최종 하드웨어에 적합한 어셈블리 코드를 만들어 줌
  	- 좋은 컴파일러를 돈 내고라도 쓰는 이유
  - 어셈블러는 최적화를 거의 안 해 줌
  	- 있어도 그냥 명령어 하나에 대한 최적화 정도
  	- 여러 줄을 합쳐서 최적화를 해주진 않음
  	- 좋은 어셈블러는 프로그래머에게 유용한 기능들을 지원
  		- 지시문, 매크로 등
  		- 최종 바이너리는 달라지지 않음

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 6502명령어의 구성

![20231005_091121](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/082269d2-9144-493b-86c1-8a46b8e60a82)

  - 어셈블리어 구문
  	- 명령어
  	- 지시문
  	- 매크로
  - 어셈블리어 명령어 구조
  	- 명령어 = 니모닉 + 피연산자
  	- 니모닉(언제나 1개)
  		- 기계어에서 언제나 1바이트를 차지한다
  	- 피연산자(0~2개)
  		- 기계어에서 0~2바이트
  		- 피연산자 앞에 $ 이면 주소이고, #이면 상수이다, 주소일 경우에는 주소가 16비트인 경우가 있어서 하나만으로 2바이트를 차지한다
  			- 즉, 8비트 또는 16비트 피연산자 하나가 바이트 1~2를 차지한다
  			- 나머지 피연산자는 opcode로 들어감(피연산자는 2바이트 인데, 하나가 2바이트를 차지 하니, 나머지 하나는 이렇게 된다고함..!)
  			- 심지어 opcode하나로 모든 피연산자를 표현하는 경우도 있음

#test.asm
~~~c
// lda 로 니모닉이 전부 같은데 , A9, A5, AD와 같이 opcode가 다르게 나오게 된다
// 구문에 있는 니모닉과 피연산자에 따라 opcode가 결정됨

// char a = 0x0A
// a레지스터에 0A라는 상수를 넣어라
lda #$0A  // 상수로 사용해라        ; A9 0A

// char* p = (char*)0x0A
// a = *p
// 0A라는 주소로 가서 거기에 있는 데이터를 a레지스터에 넣어라
lda $0A  //  8진수 짜리 주소           ; A5 0A

// char* p = (char*)0xCB0A
// a = *p;
// 0A라는 주소로 가서 거기에 있는 데이터를 a레지스터에 넣어라(위에 것과 같다, 단지 2바이트 주소일뿐!)
lda $CB0A // 16진수 짜리 주소    ; AD 0A CB
~~~

  - 니모닉 + 주소지정 모드(addressing mode) = opcode
  - 주소지정 모드
  	- CPU설계에서 ISA의 한 측면
  	- 명령어가 피연산자를 찾는 방법을 정의
  	- 6502의 주소지정 모드는 총 13개
  	- 어셈블리 코드의 피연산자에 따라 주소지정 모드를 알 수 있음
  	- 주소지정 모드에 따라 opcode 바이트를 알 수 있음
  	- 아래에는 4개만 소개하도록 함
  	  - A모드 : 누산기
  	  - #모드 : 즉시
  	  - a모드 : 절대주소
  	  - zp모드 : 제로 페이지 주소


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# A주소지정 모드(2사이클)와 6502의 파이프라인
  - 피연산자로 A레지스터를 사용한다는 암묵적 동의
  	- 코드에서 피연산자를 별도로 표기하지 않음
  - 가장 효율적인 주소지정 모드
  	- 바이트 : 1바이트
  	- 실행 사이클 : 가장 적음
  - 명령어 사이클
  	- 중요한 것은, 사이클을 진행하면서, 순차적으로 명령어를 한개씩 처리하는것이 아니라, 각 단계에 한개씩 넣어서 처리 한다고 생각해야 하며, 각 단계에 동시에 처리할 수 있는 연산은 cpu마다 차이가 있게된다
  	- 6502같은 경우는, 동시에 2가지 연산을 처리하게 된다
  		- 이것을 CPU파이프라인이라고 한다
  			- CPU의 명령어 처리 속도를 향상하는 하드웨어 설계
  			- 단일 코어가 둘 이상의 명령어를 동시에 실행할 수 있게 해 줌(명령어 수준 병렬성)

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# A모드 명령어 사이클(상세)

#a.asm
~~~c
lda #$FF  ; A9 FF
asl       ; 0A
lsr       ; 4A  lsr : 논리적 우측 비트 이동
ror       ; 6A  ror : 우측 비트 회전
rol       ; 2A  rol : 좌측 비트 회전
~~~

  - 아래 부분에서는 lda #$FF  ; A9 FF 은 A모드가 아니기때문에 건너 뛰고 아래 부터 설명하도록 한다

![20231005_091653](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/62b20047-3bc1-4a0b-880f-13405c664af9)

  - 1.0A인 asl을 읽어옴(Fetch)
  - 2.0A가 어떤 모드인지 확인(Decode), 4A를 읽어옴(Fetch)
  - 3.0A가 asl인지 다른것인지 확인 할 수 있게 되고 실행(Execute), 0A였다면 asl이고 추가로 피연산자를 받아 오지 않는 것을 알기 때문에 현재 Fetch된 것을 버린다(4A),  하지만 방금 버렸던 것을 다시 Fetch해오면서 Decode를 하기 위한 준비를 한다.(4A)
  	- 이후에는 Fetch된 것을 Decode하게 되며, 다음것을 Fetch해온다. 그렇다면 처음에는 3사이클로 Execute를 하는게 맞지만, 그 다음부터는 2사이클 만에 Execute를 하게 된다

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# #모드, 즉시(immedidate)모드(2사이클)

#a.asm
~~~c
lda #$0A
adc #$06
sbc #$01
and #$F0
~~~

  - 1. lda 를 읽어옴(Fetch)
  - 2. lda가 어떤 모드인지 확인(Decode), 0A를 읽어옴(Fetch)
  - 3. 현재 Fetch에 있는 0A가 사용해야할 피연사자인것을 확인하고 실행(Execute), 다음 것인 adc를 읽어옴(Fetch)
  	- 이후에는 Fetch된 것을 Decode하게 되며, 다음것을 Fetch해온다. 그렇다면 처음에는 3사이클로 Execute를 하는게 맞지만, 그 다음부터는 2사이클 만에 Execute를 하게 된다

  - 니모닉 바로 옆에 적힌 숫자를 값으로 그대로 사용
  	- 데이터 레지스터가 8비트니 당연히 8비트
  	- 따라서 명령어는 총 2바이트(니모닉 + 8비트 숫자)
  - C언어에서 매직 넘버 상수를 사용하는 것과 비슷
  - CPU최적화가 있었다면 다른 곳에서 읽어오는 것보다 빠르다
  	- 메모리캐시 및 파이프라인
  - 즉시 모드는 상수를 이용함으로써 빠르다
  	- 즉시모드
  		- 1. 연산자 읽음
  		- 1. 2. 피연산자 읽음
  		- 1. 3. 연산에 사용함
  	- 절대 주소 모드
  		- 1. 1. 연산자 읽음
  		- 1. 2. 피연산자(주소)를 읽음
  		- 1. 3. 그 주소에서 다른 값을 읽어 옴
  		- 1. 4. 그 값을 연산에 사용

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# a모드 : 절대주소(4사이클)

#a.asm
~~~c
lda $825B
adc $CB0A ; 6D
sta $2000 ; 
~~~

  - 1. lda 를 읽어옴(Fetch)
  - 2. lda가 어떤 모드인지 확인(Decode), 0A를 읽어옴(Fetch)
  - 3. 피연산자가 2바이트 이니, CB도 읽어옴
  - 4. 해당 주소로 가서 data를 얻음

  - 피연산자는 전체 메모리 범위에서 특정된 한 주소
  	- 전체 메모리 범위 : [0x0000, 0xFFFF]
  - 그 주소에 저장되어 있는 값을 가져와 사용
  	- C에서의 포인터
  	- Java/C# 등에서의 인스턴스
  - 포인터 연산의 단점
  	- 주소를 한 번 거치면 연산이 확 느려짐
  		- ADC는2 -> 4싸이클
  		- 여러 번 거치면 그에 비례해 느려짐
  	- 따라서 포인터 연산이 적을수록 성능에 유리
  	- 하지만 변수를 어딘가에 저장해야 함
  		- 최고의 장소는 CPU레지스터
  		- 6502에서 ALU에 적합한 레지스터는 하나밖에 없음

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 6502의 메모리 페이지
  - 1바이트로 표현 가능한 주소 범위는 [0x00, 0xFF]
  - 이 범위를 페이지(page)라고 부름
  - 6502에는 256장이 존재
  - 첫 번째 페이지를 제로 페이지라고 부름

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# zp모드 : 제로 페이지 모드

#a.asm
~~~c
lda $5B
adc $0A
sta $00
~~~

  - 6502 CPU에서 레지스터가 부족하기 때문에 2바이트 피연산자를 읽어오기 위해서 1사이클 더 많은 작업이 필요하기 때문에 이것을 페이지화 해서, 2바이트 주소를 가진 피연산자를 한번의 작업으로 읽어오기 위해서 나오게 되었다.
  - 절대 모드와의 차이점
  	- 니모닉 옆 피연산자가 1바이트 주소(0x00~0xFF)
  	- 실제 메모리 상의 주소 범위는 [0x0000, 0x00FF] 임
  	- 주소 fetch에 1사이클만 사용
  - 그 외 동작은 절대 모드와 동일
  - 6502의 메모리 페이지 레이아웃
  	- 6502에서 강제하는 메모리 페이지는 딱 두 장
  		- page 0 :  제로 페이지 주소지정 모드에 사용
  		- page 1 : 프로세서 스택 메모리
  	- page 2 ~ 255는 설계자 마음대로 사용가능
  		- ROM공간
  		- RAM공간
  		- 화면에 보여줄 픽셀 배열
  		- 디스크 I/O버퍼 등

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 주소지정 모드 종류
  - A : 누산기, A레지스터
  - # : 즉시
  - a : 절대 주소
  - zp : 제로 페이지 주소
  - i : 묵시적
  - r : 상대주소
  - (a) : 절대 간접 주소
  - a, x : 절대 주소 + x
  - a, y : 절대 주소 + y
  - zp, x : 제로 페이지 주소 + x
  - zp, y : 제로 페이지 주소 + y
  - (zp, x) : 색인 후 간접 참조
  - (zp), y : 간접 참조 후 색인

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 연산자
  - 아주 간단한 덧셈조차도 adc와 같은 니모닉을 사용하기 때문에 연산자는 존재하지 않음
  - 니모닉을 함수라고 생각하여도 됨
  - 하지만 어셈블리를 기계어로 바꿔주는 어셈블러는 연산자를 지원하기도 함
  	- 실행중에 동작하는 연산자가 아님
  	- 어셈블 과정 중에 평가해서 최종 결과만 코드로 삽입
  	- 프로그래머를 위해 어셈블러가 지원하는 기능
  		- 주로 가독성을 위해
  		- 일반적으로 산술/논리 연산자를 모두 지원
  - 어셈블리어는 연산자 우선순위가 없음(위에서 한줄씩 읽기 때문에!)
  	- 하지만 어셈블러가 지원하는 연산자에는 존재할 수도 있기 때문에, 우선순위를 직접 지정해 주는 게 좋음

#a.asm
~~~c
// 어떤 어셈블러는 연산자를 지원하기 때문에, 이런 경우 우선순위를 직접 지정해 주는것이 좋음

lda #1+2*3  ; A9 07
lda #1+2*3  ; A9 09

// 우선순위 직접 지정
lda #1+(2*3)  ; A9 07
lda #(1+2)*3  ; A9 09
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 변수와 상수
  - 실행중 데이터는 기본적으로 RAM에 저장 한다
  	- 즉, 변수도 RAM에 저장되고, 따라서 모든 데이터에는 메모리 주소가 있다
  	- 데이터 읽기(load) : 특정 주소로 가서 데이터를 읽어옴
  	- 데이터 쓰기(store) : 특정 주소로 가서 데이터를 덮어씀
  - 기본적으로는 RAM에 저장을 하지만, 100%는 아니며, CPU 레지스터에 데이터를 저장해 쓰는 상황들도 있다
  - 아래의 간단한 덧셈 예 처럼, 어셈블리어는 변수를 지정한다는 것이 lda를 통해 값을 집어 넣고 사용한다는 것과 같다
  - 긴 코드에서 많은 변수를 사용한다면, 주소가 충분치 않을 수 있기 때문에 사용하지 않는 주소를 재사용한다
  	- 고수준 언어의 좋은 컴파일러는 이런 일을 알아서 해준다
  	- 어셈블리어의 변수는 C나 C++에서 사용하는 전역변수가 비슷한 느낌이다

#a.asm
~~~c
// 간단한 덧셈 예 - a 모드

; 3+ 12
clc  ; 받아올림 초기화
lda #3
adc #&0C
sta $1000

; 2 + 1
lda #2
adc #1
sta $1001
; (3+12)-(2+1)

sec ; 받아내림 초기화
lda $1000
sbc $1001
sta $1002
~~~

  - zp모드를 사용하면, 데이터를 접근할때 2바이트 주소인것에 사이클을 1회씩 아낄수가 있다

#a.asm
~~~c
// 간단한 덧셈 예 - zp 모드

; 3+ 12
clc  ; 받아올림 초기화
lda #3
adc #&0C
sta $00

; 2 + 1
lda #2
adc #1
sta $01
; (3+12)-(2+1)

sec ; 받아내림 초기화
lda $00
sbc $01
sta $02
~~~

  - a모드 : 바이트 : 25 / 사이클 32
  - zp모드 : 바이트 : 20 / 사이클 27

  - 긴코드에서 많은 변수를 사용한다면
  	- 언제나 새로운 주소를 사용
  		- 제로 페이지 안에 다 못 넣을 수 있음
  		- 절대 주소는 충분할 수도 아닐 수도
  	- 이제는 사용하지 않는 주소를 재사용
  		- 고수준 언어의 좋은 컴파일러는 이런 일을 알아서 해줌
  	- 어떤 방식이든 간에 단점
  		- 사용 중인 메모리 주소를 프로그래머가 기억해야 함
  		- 누구든 그 메모리 주소를 덮어쓸 수 있음

  - 고수준 언어에서 메모리 주소를 직접 기억 안 해도 되는 이유
    - 변수가 있기 때문(컴파일러가 주소에 별칭을 달아서 해줌)
  - 어셈블리어에서는 변수명 대신에, 별칭을 달아 줄 수 있음


###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 스택
  - 누구나 어떤 주소에 값을 덮어 쓸 수 있는 이유는 전역 변수이기 때문
    - 어셈블리어에서는 흔한 일
    - 출력 장치도 그대로 메모리 주소에 매핑되어 있음
  - 스택(0x0100 ~ 0x01FF)을 사용할 수도 있음
    - 실행 중에 메모리 주소가 결정됨
  - 스택 관련 6502 니모닉
    - pha : A레지스터 값을 스택에 push
    - pla  : 스택에서 A레지스터로 pop
    - php : 프로세서 상태를 스택에 push
    - plp : 스택에서 프로세서 상태를 pop
    - tsx : 스택 포인터를 X 레지스터로 전송
    - txs : X레지스터 값을 스택 포인터로 전송

#a.asm
~~~c
// 스택을 사용한 예시

; 3+ 12
clc  ; 받아올림 초기화
lda #3
adc #&0C
pha

; 2 + 1
lda #2
adc #1
tsx ; 스택 위치 저장
pha
; (3+12)-(2+1)

sec ; 받아내림 초기화
pla
pla
sbc $0100, x
sta $02
~~~

  - 스택사용 : 바이트 : 20 / 사이클 35
  - 6502 CPU에서는 레지스터가 한개밖에 없기 때문에 복잡해지는 경향이 있다.
  - 따라서 6502 CPU에서는 스택이 아닌, 메모리 주소를 따로 주고, 별칭을 주는 방법을 더 선호 한다
  - 스택의 진정한 효능은 함수 호출시

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 상수 - 매직넘버, 상수형 변수
  - 상수 - 매직넘버
    - 명령어 코드의 일부가 됨
    - 어셈블러는 보통 여러 상수 표기법을 지원한다
      - 10진수 :
      - 16진수 : $
      - 2진수 : %
      - ASCII : ‘
    - 16진수를 사용하는 게 가독성에 좋음

#a.asm
~~~c
ex) lda #10  ; 0A
ex) lda #$10  ; 10
ex) lda #%10  ; 02
ex) lda #'A  ; 41
ex) adc 1000  ; 03EB
ex) adc $1000  ; 1000
ex) adc %1000  ; 08
~~~

  - 상수형 변수
  	- 매직넘버는 의미가 분명치 않으니, 상수형 변수를 쓰는것이 좋음
  	- 보통 어셈블러도 상수형 변수를 지원

#a.asm
~~~c
THICK = 2  ; 상수형 변수

lda $2200  ; AD 00 22
adc #THICK  ; 69 02
sta $2200  ; 8D 00 22

THICK = 2
width = $2200  ; 포인터 변수

lda $2200  ; AD 00 22
adc #THICK  ; 69 02
sta width  ; 8D 00 22
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 데이터 블록
  - 명령어와 함께 상수를 사용하지 않고, 그냥 메모리 안에 데이터만 저장하고 싶을때는 어셈블러의 데이터 지시문들을 사용한다
  	- .BYTE :  1바이트
  	- .WORD : 2바이트

#a.asm
~~~c
	.PROCESSOR 6502
	.ORG $8000

	clc
	lda $8000
	adc $8001
	adc $8002
	adc $8003
	sta $1000

	.ORG $C000, 0
	.BYTE $00, $01, $02, $03
	.BYTE "Hello World"
	.BYTE  0 ; 널 문자
	.WORD $1000, $1001

	.ORG $FFFC,0
	.WORD $8000 <- 프로그램은 여기 주소로 이동해서 시작한다
	.WORD $0000
~~~

![20231005_122600](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/38ea1442-0116-4841-8a7a-7f5534012448)

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 라벨
  - 위치한 곳의 바이트 주소를 가리키는 별칭
  - 코드에서 주소 대신 라벨을 사용 가능
  	- C의 goto,  label : 명령어의 실체
  - 어셈블 중에 실제 주소로 변환 됨
  	- 최종 이진 파일에서 공간을 차지하지 않음
  	- 참고 : sum도 마찬가지
  - 코드 변경의 여파가 줄어듦
  	- 좋은 습관이 중요한 이유

#a.asm
~~~c
sum=$1000

    clc  <- clc이후부터 nums주소를 읽을때 아래에 있는 nums label주소로 이동한다
    lda nums
    adc nums+1
    adc nums+2
    adc nums+3
    sta sum

    .ORG $C000, 0
nums : 
    .BYTE $00, $01, $02, $03
hello :
    .BYTE "Hello World"
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 레지스터(6502)
  - CPU속에 위치한 초저용량 메모리
    - 어떤 부품보다 빠르게 접근 가능
    - 레지스터 개수는 아주 제한적이다
  - 궁극의 최적화 장소
    - 캐시 메모리의 영향조차 받지 않음
    - 어셈블리어로만 직접 접근 가능
  - 외부에서 값을 직접 볼 수 없음
    - 어셈블리어로도 직접 접근할 수 없는 레지스터도 있음
  - 레지스터
    - 메인 레지스터(A레지스터 1개존재)
      - 특히 ALU의 입출력으로 쓸 수 있는지가 중요
      - 그 당시 타 CPU에 비해도 현저히 적음
      - 그걸 만회하려 만든 꼼수가 제로 페이지
    - 색인 레지스터(X,Y2개)
      - ALU의 거의 대부분 연산에 사용 불가 ㅠ
      - 배열 색인처럼 사용(주 용도)
        - ldx
        - ldy
        - stx
        - sty
        - inx
        - iny
        - dex
        - dey
      - 비교 값으로 사용
        - cpx
        - cpy
      - 8비트 데이터 임시 저장
        - tax
        - tay
        - txa
        - tya
      - 스택 내 데이터에 접근
        - txs
        - tsx
      - 프로세서 상태 레지스터
      - 프로그램 카운터
    - 색인 레지스터(S 1개)
      - 스택 메모리를 사용하는 곳이며, 스택이 쌓일때, 스택의 다음 빈 공간을 가리키는 스택 포인터!
      - [0x00, 0xFF]의 주소를 가리키는 포인터
        - 실제로는 페이지 1속의 주소 : [0x0100, 0x01FF]
      - 직접 push/pop 연산을 하며 증감
        - pha, php, pla, plp
      - 함수 호출 및 인터럽트의 일부로 자동 증감이 되기도 함
        - jsr, brk, rts, rti
      - S레지스터의 초기값
        - S의 초기값을 강제하지 않음
        - 스택 오버플로 상태 플래그에 따라 분기하지 않으면 어떤 값도 상관 없음
          - 링 버퍼 처럼 작동하기 때문에 스택 사용량이 256바이트만 안 넘으면 됨
        - ROM처음에서 이렇게 초기화해 주는 것이 바람직
        - ex)   ldx #$FF
        -         txs
    - 프로세서 상태 레지스터 - P
      - 7개의 비트 플래그
        - N : negative
        - V : overflow
        - Z : zero
        - C : carry
        - B : break
        - D : decimal
        - I : interrupt disable
      - 프로세서의 현 상태를 나타냄
        - 바로 직전에 실행한 명령어의 결과
        - 직접 켜거나 끌 수 있는 비트도 있음
    - 프로그램 카운터 - pc
      - 유일한 16비트 레지스터
      - 현재 fetch 중인 명령어의 주소
        - 부팅 시 리셋 벡터에 저장된 값이 pc로 설정
      - 명령어가 실행됨에 따라 자동으로1 씩 증가
        - 직접 pc값을 읽어 오거나 덮어쓸 수 없음
        - 기타 함수 호출 및 인터럽트 등의 연산을 통해 변경 가능
          - 함수 호출시, 반한 후 실행해야 할 코드의 주소를 스택에 push, push
          - 함수 반환 후, 스택을 pull, pull하여 PC에 설정

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 묵시적 명령어 몇개 소개
  - nop
    - 의미 : 연산 없음
      - 아무런 연산도 하지 않음
    - 용도
      - 프로그램 실행에 딜레이를 넣고 싶을때
      - 코드 메모리에 빈 공간을 reserve 하고 싶을 때
      - 디버깅 중 짜증 나는 코드를 지워버릴 때
      - 프로그램의 끝을 표기할 때
      - 모드 : i / opcode : EA / 바이트 : 1 / 사이클 : 2

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

# 프로그램 종료
  - 임베디드 시스템의 기본 동작은 무한 루프
    - 전원이 끊길 때까지 같은 동작을 반복
  - 한 번 실행 후 아무것도 안하게 하고 싶다면?
    - 자기 스스로에게 점프하며 무한 루프

#a.asm
~~~c
// 자기 스스로에게 점프하며 무한 루프

out=$4000

    ldx #$FF
    txs
start:
    lda #'H
    sta out
    lda #'i
    sta out
end:
    jmp end
~~~

###### [6502 어셈블리 기초 문법](#6502-어셈블리-기초-문법)
###### [Top](#top)

<br/>
<br/>

***

# 6502어셈블리 니모닉 정리
  - lda 피연산자 : A레지스터에 피연잔사 값넣기
  - clc : 받아올림 초기화(C = 0)
  - sec : 받아내림 초기화(C = 1)
  - adc 피연산자 : 받아올림을 이용한 덧셈
  - sbc 피연산자 : 받아내림을 이용한 뺄셈
  - sta  피연산자 : A레지스터에 있는 값을 피연산자 주소에 넣기
  - pha : A레지스터 값을 스택에 push
  - pla  : 스택에서 A레지스터로 pop
  - php : 프로세서 상태를 스택에 push
  - plp : 스택에서 프로세서 상태를 pop
  - tsx : 스택 포인터를 X 레지스터로 전송
  - txs : X레지스터 값을 스택 포인터로 전송
  - tax : A레지스터 값을 X레지스터로 전송
  - tay : A레지스터 값을 Y레지스터로 전송
  - txa : X레지스터 값을 A레지스터로 전송
  - tya : Y레지스터 값을 A레지스터로 전송
  - inc : 메모리의 값을 1 증가
  - inx : x레지스터를 1 증가
  - iny : y레지스터를 1 증가
  - dec : 메모리의 값을 1 감소
  - dex : x레지스터를 1 감소
  - dey : y레지스터를 1 감소
  - lsr : 논리적 우측 비트 이동
  - rti : 인터럽트에서 복귀
  - asl : 산술적 좌측 비트 이동
  - rol : 비트들을 1 비트만큼 왼쪽으로 이동
  - ror ; 비트들을 1 비트만큼 오른쪽으로 이동
  - and : A레지스터와 논리곱
  - ora : A레지스터와 논리합
  - eor : A레지스터와 배타적 논리함
  - cmp : A레지스터와 비교
  - jmp : 특정 주소로 점프
  - beq : Z == 1 일때 특정 주소로 점프 A == M
  - bne : Z == 0 일때 특정 주소로 점프 A != M
  - bcc : C == 0 일때 특정 주소로 점프 A < M
  - bcs : C == 1 일때 특정 주소로 점프 A >= M
  - bmi : N == 1 일때 특정 주소로 점프
  - bpl : N == 0 일때 특정 주소로 점프
  - bvc : V == 0 일때 특정 주소로 점프
  - bvs : V == 1 일때 특정 주소로 점프
  - cpx : x레지스터와 비교(그다음은 cmp와 같음)
  - cpy : y레지스터와 비교(그다음은 cmp와 같음)
  - bit : A레지스터 값을 바꾸지 않는 and연산
  - jsr : 함수를 호출할 때 사용(서브루틴으로 점프)
  - rts : 함수에서 돌아올 때 사용(서브루틴에서 회귀)

###### [6502어셈블리 니모닉 정리](#6502어셈블리-니모닉-정리)
###### [Top](#top)

<br/>
<br/>

***

# 6502어셈블리 플래그 정리
  - C(bit 0) : 받아올림 플래그
    - bit 7에서 받아올림이 생기면 C플래그도 켜짐
  - Z(bit 1) : 제로 플래그
    - 8비트가 모두 0이면 켜짐
    - 모든 데이터 이동 및 계산 연산에 적용됨
  - V(bit 6) : 오버플로 플래그
    - A와 M의 bit7이 같았는데 결과의 bit7이 다르면 V 켜짐
  - N(bit 7) : 음수 플래그
    - bit 7이 1이면 켜짐
    - 모든 데이터 이동 및 데이터 산술 연산에 적용
    - 주 용도는 음수 판단
      - 실제 음수란 뜻이 아니다
      - 프로그래머가 0~255수를 더한다면 양수가 된다
      - -128~127을 원한다면 음수가 된다
        - N플래그에 따라 프로그래머가 결정해야 할 일

###### [6502어셈블리 플래그 정리](#6502어셈블리-플래그-정리)
###### [Top](#top)

<br/>
<br/>

***

# 6502 어셈블리 산술 논리 연산
  - [adc : 받아올림을 이용한 덧셈(C, V플래그)](#adc-받아올림을-이용한-덧셈c-v플래그)
  - [sbc : 받아내림을 이용한 뺄셈](#sbc--받아내림을-이용한-뺄셈)
  - [증감 연산](#증감-연산)
  - [색인 주소지정 모드](#색인-주소지정-모드)
  - [페이지 크로싱](#페이지-크로싱)
  - [비트 이동/회전 연산](#비트-이동회전-연산)
  - [논리 연산, NOT연산구현,6502에 없는 연산들..](#논리-연산-not연산구현6502에-없는-연산들)
  - [CPU에 데이터 형은 없다 해석은 남의 몫](#cpu에-데이터-형은-없다-해석은-남의-몫)
  - [단항 바이트 연산자](#단항-바이트-연산자)

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# adc : 받아올림을 이용한 덧셈(C, V플래그)
  - 두 8비트 정수 간 덧셈을 수행
    - A레지스터
    - 피연산자(메모리)
    - ALU가 A레지스터 와 피연산자(메모리)에 접근할 수 있지만 CPU레지스터에 있는 A레지스터에는 직접 접근할 수 있어 굉장히 빠르지만 그보다 피연산자(메모리)는 접근이 느릴 수 밖에 없다
  - 결과 : A레지스터에 다시 대입
    - bit 7에서 받아올림이 생기면 C플래그도 켜짐
    - A와 M의 bit7이 같았는데 결과의 bit7이 다르면 V도 켜짐
  - 정수 오버 플로
    - 산술 연산의 결과가 주어진 비트로 표현 가능한 범위를 벗어나는 경우, 제대로 표현하려면 비트가 더 필요함, 현재 6502 CPU의 A레지스터는 1바이트(=8비트)이므로 255까지의 수를 표현 가능하다.(=255 초과되는 수는 비트가 한개 더 필요하니, 정수 오버플로가 난다)
  - 정수 오버 플로 처리 방법
    - 하나의 레지스터에 표현 가능하면 그냥 무시하기(오버플로)
      - 현대 고수준 언어에서 일반적인 덧셈 방법
      - 결과가 범위를 넘지 않는다고 가정하고 코드 작성
      - 8비트 기계에서는 너무 제한적인 방법..ㅠ
    - 다음 바이트 계산에 추가 하기(2배 정밀도 덧셈)
      - 1. bit7의 받아올림 결과를 C에 저장(c는 상태 레지스터!)
      - 2. bit 0을 더할 때 C도 같이 더함
  - 받아올림(carry)플래그 - C (bit 0 )
    - 수학 및 비트 회전 연산에 사용하는 받아올림/받아내림 플래그
      - 프로세서 상태 레지스터의 C 비트
    - 특정 ALU 연산 결과에 따라 이 비트가 켜지거나 꺼짐
      - 모든 명령어가 이 비트를 바꾸는 게 아님
  - adc와 clc
    - 두 수를 더하기 전에 받아올림 플래그 ( C )를 지워줘야 함
      - ALU는 우리가 수를 더하는 중인지 새로 덧셈을 시작하는지 모름
    - adc는 언제나 C값을 같이 더함
    - ALU는 adc 연산 결과에 따라 C비트를 변경
      - 오버플로가 있었을 경우 : C = 1
      - 오버플로가 없었을 경우 : C = 0
    - 따라서 첫 바이트를 더하기 전에만 clc를 호출해 0이 더해지게 함
      - 다음 바이트부터는 앞 바이트의 받아올림 결과를 같이 더해야 함
  - 하지만 오버 플로우는 unsigned일때도 있지만, signed일때도 일어난다. 어셈블리어 수준에서 본다면 같은 비트 패턴 이지만 unsigned일때와 signed일때 값이 달라지기 때문에 이것은 프로그래머의 판단으로 맡기게 된다, 고수준 에서는 이것을 하나의 변수로 지정해서, 컴파일러가 대신 해주게 된다
    - C비트인 carry플래그가 켜진다고 해서 무조건 오버 플로우가 생겼다고 할 수 없다(=unsinged일때만 가능한것이고, singed일경우에는 최상위 비트가 음수이면 무조건 1이기 때문에, 음수 + 음수는 무조건 carry가 생기기 때문)
  - signed덧셈의 가능한 조합
    - 양수 + 음수
      - 계산 후 양수일때 : C : 1 / V : 0
      - 계산 후 음수일때 : C : 0 / V : 0
    - 양수 + 양수
      - 계산 후 오버플로일때 : C : 0 / V : 1
      - 계산 후 정상일때 : C : 0 / V : 0
    - 음수 + 음수
      - 계산 후 오버플로일때 : C : 1 / V : 1
      - 계산 후 정상일때 : C : 1 / V : 0
  - carry플래그도 있지만 오버플로우 플래그(V - bit 6)도 존재한다
    - 특정 ALU연산 결과에 따라 이 비트가 켜지거나 꺼짐
    - signed연산을 할 때 특히 유용
    - unsigned는 캐리 플래그로 충분
    - 7비트로 표현 못하는 연산 결과가 있음을 나타내야 하는 플래그이다

#a.asm
~~~c
// 2배 정밀도 덧셈 예

NUM0=%01101000
NUM1=%10011010
out1=$2000
outh=out1+1

    ldx #$FF
    txs

    clc         ; c = 0
    lda #NUM0
    adc #NUM1   ; c = 1
    sta out1
    lda #0
    adc #0      ; c == 0      <- adc는 언제나 C값을 같이 더함, 여기서는 더한후에 캐리가 된것이 없기 때문에 c 가 0이 된다
    sta outh
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# sbc : 받아내림을 이용한 뺄셈
  - 두 8비트 정수 간 뺄셈을 수행
    - A레지스터
    - 피연산자 (메모리)
  - 결과 : A레지스터에 다시 대입
    - V플래그 : signed 오버플로가 발생하면 켜짐
      -  결과가 [-128, 127] 범위를 넘어서면 켜짐
    - C플래그
      -  C == 1 : 결과가 0이상, 받아내림이 없었음
        -  bit7 끼리 더해서 받아 올림이 생기면 C는 1이된다
      -  C == 0 : 결과가 음수, 받아내림이 있었음
        -  bit7 끼리 더해서 받아 올림이 없다면 C는 0이된다
      -  따라서 새로운 수의 뺄셈을 하기 전에 sec를 호출해야 함
        -  C를 1로 셋팅 해줌

#a.asm
~~~c
out=$2000
    ldx #$FF
    txs

    sec   ;  c = 1
    lda #$0A   ; 00001010
    sbc #$02   ; 11111110  ; c = 1
    sta out

1. C를 1로 시작
2. 내부적으로 sbc의 피연산자의 비트를 반전 시키고(반전시킨 비트 = 11111110)
3. A에 더함
4. 결과 = 1 00001000 (받아 내림이 없었음)
~~~

<br/>

#a.asm
~~~c
out=$2000
    ldx #$FF
    txs

    sec   ;  c = 1
    lda #$0A   ; 00001010
    sbc #$0C   ; 11110100  ; c = 0
    sta out

1. C를 1로 시작
2. 내부적으로 sbc의 피연산자의 비트를 반전 시키고(반전시킨 비트 = 11110100)
3. A에 더함
4. 결과 = 0 11111110 (받아 내림이 있었음)
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 증감 연산
  - 값을 1만큼 증가 혹은 감소하는 연산
  - 잦은 연산이라 별도의 명령어를 제공
    - C언어에서 ++ , - - 를 하는것과 같은것
    - num = num + 1 보다 빠름
    - 일반적으로는 lda(3사이클) + adc(2사이클) + sta(3사이클) = 총8사이클이 지만, inc니모닉을 사용하면 5사이클만으로 증감 연산을 할 수 있다
  - inc : 메모리의 값을 1 증가
  - inx : X레지스터를 1 증가
  - iny : Y레지스터를 1 증가
  - dec : 메모리의 값을 1 감소
  - dex : X레지스터를 1 감소
  - dey : Y레지스터를 1 감소

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 색인 주소지정 모드
  - X 또는 Y 레지스터의 값을 배열 색인처럼 사용
    - 피연산자 주소는 고정
    - inx를 통해 X를 증가시켜 줌

#a.asm
~~~c
// 절대 주소지정 모드

sum=$1000
    ldx #$FF
    txs

    clc
    lda nums
    adc nums+1
    adc nums+2
    adc nums+3
    sta sum

    .ORG $C000, 0
nums:
    .BYTE $00, $01, $02, $03
~~~

<br/>

#a.asm
~~~c
// 색인 주소 지정 모드
sum=$1000
    ldx #$FF
    txs

    clc
    lda nums
    ldx #1 <- X레지스터를 1로 세팅
    adc nums, X
    inx   <- 이것을 통해서 x를 1씩 증가시키면서 다음 다음 저장된 값을 가져 온다
    adc nums, X
    inx
    adc nums, X
    sta sum

    .ORG $C000, 0
nums :
    .BYTE $00, $01, $02, $03
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 페이지 크로싱
  - 주소 연산 결과가 다음 페이지를 가리키는 현상
    - 하위 주소의 덧셈에서 받아올림이 생김
    - 그 받아올림을 상위 주소에 더해야 함
    - 한마디로, 0페이지에서 1페이지로 넘어가게 되면, 주소를 하위주소만 가져오는 것이 아니라 상위주소도 가져 와야 하는 상황이 생기기 때문에 1사이클이 증가하게 된다
  - 최종 주소를 찾으려면 1 사이클이 추가로 필요
    - 명령어 바이트 크기는 동일
    - 속도가 중요하다면 페이지 경계에 데이터가 걸치지 않도록 조심할 것
  - adc nums, x
  - 위와 같은것이 a, x, a, y a모드
  - zp, x가 여전히 4 사이클인 이유
    - a, x 모드에서 BAh fetch는 공짜
      - BAl + X를 계산하는 동안 BAh를 fetch
    - zp, x 모드에서 BAh를 fetch 안 해 얻는 이득이 없음
      - BAl + X 계산은 피할 수 없음
      - 이 주소를 알기 전까지는 데이터 읽기/쓰기가 불가

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 비트 이동/회전 연산
  - 데이터의 비트들을 왼쪽 혹은 오른쪽으로 이동
    - 6502는 한 번에 1씩 이동
    - 밀려나간 비트는 C플래그로 들어감
  - 이동과 회전의 차이는 새로 들어오는 비트
    - 이동 : 언제나 0
    - 회전 : C플래그의 값
  - 일반적으로 매우 빠른 연산 중 하나
    - 특히 레지스터에서 작동할 때
  - asl
    - 비트들을 1 비트만큼 왼쪽으로 이동
    - 새로채워지는 비트는 0
    - A레지스터 또는 메모리에서 동작
    - A모드 : 2사이클
    - 영향받는 플래그 : N, Z, C
    - C플래그
      - 밀려나간 비트를 저장
      - 그 값을 사용하진 않음
  - lsr
    - 비트들을 1비트만큼 오른쪽으로 이동
    - A레지스터 또는 메모리에서 동작
    - 한번이라도 사용하면 그 값은 N플래그를 언제나 0으로 만듬(최상위 비트를 0으로 만들기 때문에)
  - rol
    - 비트들을 1 비트만큼 왼쪽으로 이동
    - 새로 채워지는 비트는 C에 들어있던 값으로 채움
    - 밀려나간 비트는 C에 저장
  - ror
    - rol과 같고, 이동을 오른쪽으로 할 뿐
  - 비트 이동
    - 빠른 2의 배수 곱셈/나눗셈
    - CRC체크섬 계산
    - 엔디언 변환
    - 빠른 해시값 계산
    - 비트 플래그 (비트 마스킹)
    - 등
  - 비트 회전
    - 2배 정밀도 덧셈 최적화
    - 비트 패턴 뒤집기
    - 워드보다 큰 데이터를 비트 이동할 때
    - 등

#a.asm
~~~c
// 비트이동, 비트회전

    .PROCESSOR 6502
    .ORG $8000

VAL=%01011000
r=$80
    ldx #$FF
    txs

    lda #VAL
    rol      ; 왼쪽에 하나를 빼서 C레지스터에 저장
    ror r    ; 다른 메모리에 C레지스터에 있는 값을 빼서 오른쪽으로 밀면서 저장
    rol
    ror r
    rol
    ror r
    rol
    ror r

    rol
    ror r
    rol
    ror r
    rol
    ror r
    rol
    ror r

    .ORG $FFFC, 0
    .WORD $8000
    .WORD $0000
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 논리 연산, NOT연산구현,6502에 없는 연산들..
  - 3개의 논리 연산 명령어를 제공
    - and(=and)
      - A레지스터와 논리곱
    - ora(=or)
      - A레지스터와 논리합
    - eor(=xor)
      - A레지스터와 배타적 논리함
    - A와 M사이의 논리 연산
      - 각 비트 별로 연산
      - 결과를 A레지스터에 저장
    - 영향 받는 플래그 : N, Z

#a.asm
~~~c
// 비트마스킹

VAL=%01011000
MASK0=%01000000
MASK2=%00100000
	ldx #$FF
	txs

	lda #VAL
	and #MASK0  ; Z == 0

; Z값에 따라 분기

	lda #VAL
	and #MASK1  ; Z == 1

; Z값에 따라 분기
~~~

<br/>

#a.asm
~~~c
// 대문자 -> 소문자로 바꾸기

ch=$80
MASK=%00100000
    ldx #$FF
    txs

    lda ch
    ora #MASK
    sta ch

// 바이트 : 9
// 사이클 : 12
~~~

<br/>

#a.asm
~~~c
// NOT연산 구현

VAL=%01011000
	ldx #$FF
	txs

	lda #VAL
	eor #%11111111
~~~

<br/>

#a.asm
~~~c
// eor를 사용한 두 수 교환
num0=$80
num1=$81
	ldx #$Ff
	txs

	lda num0
	eor num1
	sta num0

	eor num1
	sta num1

	eor num0
	sta num0
~~~

  - NOT연산 구현
    - eor #%11111111 연산을 하면 not게이트가 된다

  - 6502에 없는 연산들
    - 곱셈, 나눗셈 등…
    - 이런것들은 대부분 기본적인 것으로부터 만들수 있음

#a.asm
~~~c
// 2의 배수를 곱하는 경우 : asl(비트들을 1 비트만큼 왼쪽으로 이동)
// shift연산을 사용하면 된다
num=$20
	ldx #$FF
	txs

	lda num
      asl
      asl
      asl
      asl
      sta num
~~~

<br/>

#a.asm
~~~c
// 다른 양의 정수를 곱하는 경우 : adc
// 곱하는 수만큼 더해주면 된다
num=$20
	ldx #$FF
	txs

	clc

	lda num
	adc num
	adc num
	sta num
~~~

<br/>

#a.asm
~~~c
// 2의 배수로 나누는 경우 : lsr
// shift비트 사용
lda num
lsr
lsr
sta num
~~~

<br/>

#a.asm
~~~c
// 다른 양의 정수로 나누는 경우 : sbc
// 0보다 클때까지만 빼면서 수를 1씩 올리면 그 올린수가 값이 된다
ldx #0

sec
lda num
sbc #DENOM  ; $03


; while (A >= 0)
; {
inx
sbc #DENOM
; }

stx num
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# CPU에 데이터 형은 없다 해석은 남의 몫
  - 데이터 형
    - CPU의 핀을 보면 많은 걸 알 수 있음
    - 6502의 데이터 너비는 8비트
      - 하드웨어가 이해하는 최대 데이터 크기는 1바이트
      - 최소 데이터 크기는 1비트
    - 엄밀히 말하면 데이터형은 없음
      - 해석은 프로그래머나 고수준 언어 컴파일러의 몫
    - 하지만 byte 데이터 형이 있다고 말 할 수도 있음
      - 데이터 레지스터와 데이터 핀이 한번에 8비트씩 처리
      - ALU도 8비트씩 연산 가능
      - byte : 6502가 유일하게 아는 자료형(ALU의 워크 크기)
  - 메모리에서의 문자
    - 그냥 8비트 정수값
    - 아스키코드 : 그 정수와 문자와의 관계를 정의
      - 01000001(65) : A
      - 01100001(97) : a
    - 그걸 보고 해석하는 건 다른 사람의 몫
      - 예 : 입력장치, 화면, 프로그래머 등
  - 컴퓨터의 기본 입출력
    - 임베디드 : 여러 하드웨어의 스펙에 따라 잘 코딩
    - 하지만 기본 입출력은 여러 기계에 매우 공통적인 작업
      - PC에 BIOS가 등장하며 이런 일을 대신 처리해 줌
      - 이제는 운영체제(OS)의 역할
  - 6502에서 실수형, 형 변환
    - 실수형
      - ALU는 정수 처리를 기초로 함
      - 6502를 비롯한 오래된 CPU의 ALU는 정수만 지원
      - 실수 연산 및 자료형은 직접 만들어 써야 함
        - 6502의 BCD(Binary Coded Decimal)모드 지원
        - 고정 소수점과 부동 소수점(IEEE 754) 모두 구현 가능
        - 일반적으로 고정 소수점을 사용했음
      - 실수 처리를 위해 별도의 회로를 탑재할 수도 있음
    - 형 변환
      - 일반적인 프로그래밍 언어에서의 형 변환
        - 정수 <> 정수
        - 정수 <> 실수_6502에서 없음
        - 개체 레퍼런스 <> 개체 레퍼런스_6502에서 없음
          - 개체는 어떤 개체의 시작주소가 담겨 있을 뿐
          - 고수준에서 개체 형변환을 할때 그 주소는 바뀌지 않고, 어떤 개체의 시작주소로 가서 해석할지 바뀌는 것이다.
        - 비트패턴은 없다고 생각하면 되고, 프로그래머가 비트 패턴을 해석하기 나름
      - 고수준에서의 정수형 변환
        - 묵시적으로 바뀌는 경우는, 대입해도 정보를 잃지 않을때 허용하게 되며, 앞부분에 0 비트를 넣어주는 것일 뿐이다(작은 비트 -> 큰 비트로 갈때)
          - byte -> short
          - short -> int
          - ing -> long
        - 명시적으로 바꾸는 경우는, 정보를 잃을 수 있어서 프로그래머가 직접 명령을 해야 할때이다. 상위 바이트를 해석하지 않고, 허용된 하위 바이트만 해석하게 된다
          - 1. 저장 공간이 줄어들 때
            - short -> byte
            - int -> short
            - long -> byte
          - 2. singed <> unsigned
            - 비트 패턴 안 변함
            - 해석만 다르게 함
      - 정리 : 고수준 언어의 정수형 변환
        - 비트 패턴은 변하지 않음
        - 그 비트 패턴을 다르게 해석할 뿐
        - 비트 패턴을 잘못 해석하는 일을 막는 건 프로그래머의 몫
        - 즉, 정수형을 변환한다는 것보다 정수형을 어떻게 해석한다는 표현이 더 옳다
        - 어셈블리어 에서는 그 해석또한 프로그래머가 알아서 해야 함

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

# 단항 바이트 연산자
  - < 연산자 : 하위 바이트 반환
    - <$1234 = $34
  - > 연산자 : 상위 바이트 반환
    - >$1234 = $12
  - 어셈블러의 기능

#a.asm
~~~c
VAL=$1234
num=$80
	ldx #$FF
	txs

	lda num
	adc #<VAL  ; $34
	adc #>VAL  ; $12
	sta num
~~~

###### [6502 어셈블리 산술 논리 연산](#6502-어셈블리-산술-논리-연산)
###### [Top](#top)

<br/>
<br/>

***

# 조건문
  - [cmp, jmp, beq, bne, bcc, bcs](#cmp-jmp-beq-bne-bcc-bcs)
  - [bmi, bpl, bvc, bvs](#bmi-bpl-bvc-bvs)
  - [조건문 작성](#조건문-작성)
  - [상대 주소지정 모드](#상대-주소지정-모드)
  - [기타if문 관련](#기타if문-관련)

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

# cmp, jmp, beq, bne, bcc, bcs
  - 어셈블리어는 참/거짓을 판단할때, 하나만 비교하는 것이 아니라 모든 조건을 다 비교한다
    - a와 b를 다 비교
      - if (a < b)
      - if (a > b)
      - if (a == b)
      - if (a != b)
    - 비교 결과 중 하나에 따라 점프
    - 비교할때 쓰는 명령어 “cmp”
  - cmp
    - A와 M을 비교
      - A-M을 수행
    - 결과
      - N,Z,C플래그가 변경됨
        - 이 플래그에 따라서 어떤 비교가 되었는지 확인 할 수 있음
      - A값은 바뀌지 않음
    - 가장중요한것!!!!
      - cmp는 비트 패턴만 보기 때문에, unsigned만을 비교 할 수 있다!!! -5와 5를 비교하면, 비트 패턴으로는 -5가 더 크기 때문에..! 비교할 수가 없음
    - 따라서 아래와 같이 N,Z,C플래그의 변경됨을 통해서, 값이 어떻게 비교 됐는지 확인 할 수 있고 그것을 니모닉으로 만들어 놓았음

#a.asm
~~~c
A == M / N = 0 / Z = 1 / C = 1
A < M / N = ? / Z = 0 / C = 0
A > M / N = ? / Z = 0 / C = 1

1. Z == 1 / beq / A == M
2. Z == 0 / bne / A != M
3. C == 0 / bcc / A < M
4. Z == 0 && C == 1 / A > M
5. C == 1 / bcs / A >= M
~~~

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

# bmi, bpl, bvc, bvs
  - 일반 조건이 아닌, 산술연산 후에 점프하는 경우
    - bmi : N == 1 일때 특정 주소로 점프
    - bpl : N == 0 일때 특정 주소로 점프
    - bvc : V == 0 일때 특정 주소로 점프
    - bvs : V == 1 일때 특정 주소로 점프

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

# 조건문 작성

#a.asm
~~~c
if(NUM == 5)
{
   *ret = 'E';
}
else if(NUM < 5)
{
   *ret = 'L';
}
else
{
   *ret = 'G';
}

위의 조건문을 어셈블리어로 작성

ret=&80

0x8000 lda #Num
0x8002 cmp #$05

0x8004 bne $800B
0x8006 lda #'E   ; $45
0x8008 jmp $8014

0x800B bcs $8012   // cmp를 이미 앞에서 했기 때문에 한번더 필요 없음
0x800D lda #'L   ; $4C
0x800F jmp $8014

0x8012 ida #'G  ; $47

0x8014 sta ret
~~~

  - cmp는 비트 패턴만 보기 때문에, unsigned만을 비교 할 수 있다!!! -5와 5를 비교하면, 비트 패턴으로는 -5가 더 크기 때문에..! 비교할 수가 없음(실제로 -5 - 5를 하면 C가 1로 세팅이 되기 때문)
    - signed비교 방법
      - 1. A와 M의 부호 비트(비트7)를 뒤집는다
        - eor #$80
      - 2. cmp 연산을 한다
      - 3. 원래 공식에 따라 분기한다
    - 비교할때의 생각
      - 양수 양수라면 큰 값의 양수가 비트패턴이 크기 때문에 이상이 없음
      - 음수 음수 라면, 큰 값의 음수가 비트패턴이 크기 때문에 이상이 없음(-1이 -2보다 큰값이다)
      - 문제는 양수와 음수를 비교할때인데, 이때는 음수가 비트패턴이 무조건 크다. 따라서 bit7의 비트 패턴을 서로 바꿔주고 분기하면 된다
    - 최신 ISA에는 signed/unsinged분기용 니모닉이 별도로 존재

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

# 상대 주소지정 모드
  - 지정된 오프셋만큼 점프
  - 기준 : 현재 명령어
  - 오프셋 : 8비트
    - 따라서 앞뒤로 127바이트 정도만 점프 가능
    - 42~127명령어 범위
    - 분기의 대상인 코드가 이 보다 멀리 있기 어려움
  - 분기할때는 8비트 정도로만 점프할 수 있으며
    - 어셈블 중에 피연산자가 오프셋으로 바뀐다
    - 아래와 같은 경우 현재 FA의 위치는 8009가 되고,
    - FF부터 FA는 6바이트 이기 때문에 6바이트 전인 8003으로 점프한다
    - 점프할 크기를 FF부터 빼면 확인 할 수 있다

#a.asm
~~~c
//예1 : 근처로 분기 할 경우
0x8003 lda num  ; A5 20
0x8005 cmp #1   ; C9 01
0x8007 bne $8003  ; D0 FA
~~~

<br/>

#a.asm
~~~c
//예2 : 멀리로 분기 할 경우
// 컴파일 오류가 난다
0x8003 lda num 
0x8005 cmp #1  
0x8007 bne $FFFF
~~~

  - 일반적으로 분기를 쓸때는 라벨을 사용하게 된다, 유지보수 측면과, 보기가 훨씬 편하다

#a.asm
~~~c
num=$20

read:
	lda num
	cmp #1
	bne read <- 라벨을 사용하면 어셈블러가 알아서 이동시켜줌
~~~

  - 점프를 하는 것은 비용이 꽤나 드는 일 임으로, 데이터 분포를 알면, 최대한 점프를 적게 하는 방향을 생각할 수 있으며, 그것이 더 빠른 방법이 된다

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>

# 기타if문 관련
  - switch/case문 없음
  - 조건 연산(삼항 연산자) 없음
  - 비교 연산 : 이미 봤음
  - 논리 연산 : and / ora / ero이후 N, Z플래그에 따라 분기
  - bit 니모닉(A & M)
    - A레지스터 값을 바꾸지 않는 and연산
    - Z플래그에 결과가 저장됨
      - Z == 1 : and결과의 모든 비트가 0
    - M의 bit7과 bit6을 N, V플래그에 대입
    - 이후 다양한 분기 명령어를 사용 가능

#a.asm
~~~c
// 문자열 패딩하기
//  X에 저장된 문자열의 길이가 8이 되도록 뒤에 . 을 출력하기로 가정
out=$4000  ; 여기에 출력하면 LCD가 화면에 출력한다고 가정
column=$4001

    txa    ; 6이라고 가정
    and #%00000011 ; 뒤에 2바이트는 0~3을 가리키기 때문에 여기가 00이여야 4의 배수가 된다

    beq pad0

    ldx #'.

    cmp #3
    beq pad1

    cmp #2
    beq pad2

pad2:
    sta out
    iny
    sty column

pad1:
    stx out
    iny
    sty column

pad0:
	...
~~~

###### [조건문](#조건문)
###### [Top](#top)

<br/>
<br/>
