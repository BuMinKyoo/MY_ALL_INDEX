<br/> 

###### Top

- [Basic](#basic)
  - [Native Code,중간언어,이진법,컴퓨터기본구조 3가지](#native-code중간언어이진법컴퓨터기본구조-3가지)
  - [언어수준(저수준언어, 고수준언어)](#언어수준저수준언어--고수준언어)
  - [타입별(강한타입, 약한타입)](#타입별강한타입-약한타입)
  - [처리수준(컴파일언어, JIT컴파일언어, 인터프리터)](#처리수준컴파일언어--jit컴파일언어--인터프리터)
  - [메모리관리(매니지드, 언매니지드)](#메모리관리매니지드-언매니지드)
  - [프로그래밍 패러다임(절차적언어, 개체지향 언어OOP)](#프로그래밍-패러다임절차적언어-개체지향-언어oop)
  - [프레임워크, 라이브러리](#프레임워크-라이브러리)
  - [디버그(debug)빌드, 릴리즈(release)빌드](#디버그debug빌드-릴리즈release빌드)
  - [컴파일(Compile)](#컴파일compile)
  - [CLI(CMD,터미널,쉘)](#clicmd터미널쉘)
  - [장치통신](#장치통신)
  - [기타, 도움링크](#기타-도움링크)

 <br/>
 <br/>
 
- [컴퓨터 기본수학](#컴퓨터-기본수학)
  - [자료크기](#자료크기)
  - [접두사](#접두사)
  - [형변환](#형변환)
  - [값형, 참조형](#값형-참조형)
  - [이스케이프문자](#이스케이프문자)
  - [음수-표현법](#음수-표현법)
  - [문자인코딩](#문자인코딩)
  - [유리수표현법](#유리수표현법)
  - [불대수](#불대수)
  - [빅오 표기법(시간복잡도)](#빅오-표기법시간복잡도)
  - [알고리즘](#알고리즘)
  - [자료구조](#자료구조)
  - [컴퓨터가 사진을 다루는법(그래픽 카드의 원리, VGA)](#컴퓨터가-사진을-다루는법그래픽-카드의-원리-vga)
  - [컴퓨터가 글자를 다루는법](#컴퓨터가-글자를-다루는법)
  - [진법](#진법)
  - [8진법, 16진법, 32진법](#8진법-16진법-32진법)
  - [진수변환](#진수변환)
  - [비트,바이트](#비트바이트)
  - [비트, 음수와 양수의 관계 및 수의표현, 및 최하위 비트로 짝수 홀 수 판단](#비트-음수와-양수의-관계-및-수의표현-및-최하위-비트로-짝수-홀-수-판단)
  - [비트마스킹(bit masking)](#비트마스킹bit-masking)
  - [증감 연산자](#증감-연산자)
  - [비트이동연산자](#비트이동연산자)
  - [비트연산자](#비트연산자)

<br/>
<br/>

- [운영체제](#운영체제)
  - [32비트와 64비트](#32비트와-64비트)
  - [기억 장치의 종류](#기억-장치의-종류)
  - [HDD의 논리적 구조와 SSD](#hdd의-논리적-구조와-ssd)
  - [API, Kernel, System Call, Interrupt](#api-kernel-system-call-interrupt)
  - [DMA(Direct Memory Access)](#dmadirect-memory-access)
  - [CPU와GPU](#cpu와gpu)
  - [Virtual Memory](#virtual-memory)
  - [Process와 Thread](#process와-thread)
  - [Process간 통신 IPC, SOKET, MESSAGE PASSING](#process간-통신-ipc-soket-message-passing)
  - [메모리관리](#메모리관리)
  - [동기/비동기](#동기/비동기)
  - [Garbage Collection(GC), Automatic Reference Counting(ARC)](#garbage-collectiongc-automatic-reference-countingarc)
  - [스택, 힙, 코드, 데이터영역](#스택-힙-코드-데이터영역)
- [Window시스템기초](#window시스템기초)
  - [보안DACL](#보안dacl)
  - [Process, Thread, _beginthreadex, 동기화](#process-thread-_beginthreadex-동기화)
  - [Context Switch](#context-switch)
  - [Sleep()](#sleep)
  - [Windows시스템 메모리 운용 방법](#windows시스템-메모리-운용-방법)
  - [Window 프로세스 기본 힙할당](#window-프로세스-기본-힙할당)
  - [보호모드](#보호모드)

<br/>
<br/>

- [암호기술](#암호기술)
  - [Hash](#hash)
  - [대칭키(Symmetric key)](#대칭키symmetric-key)
  - [비대칭키 체계(SSL)](#비대칭키-체계ssl)

<br/>
<br/>

  - [Network기초](#network기초)
    - [컴퓨터구조, 네트워크 계층](#컴퓨터구조-네트워크-계층)
    - [Port, IP, MAC](#port-ip-mac)
    - [LAN, WAN](#lan-wan)
    - [Host, Switch, End-point, Network](#host-switch-end-point-network)
    - [IP주소 종류](#ip주소-종류)
    - [DNS](#dns)
    - [웹 서비스 구조](#웹-서비스-구조)
    - [GET, POST](#get-post)
    - [네트워크 데이터 단위](#네트워크-데이터-단위)
    - [패킷의 생성 원리](#패킷의-생성-원리)
    - [Router의 구조, Inline, Out of path](#router의-구조-inline-out-of-path)
    - [Proxy](#proxy)
    - [TCP/IP 송수신 원리](#tcpip-송수신-원리)
    - [소켓(Socket) 입/출력 버퍼](#소켓socket-입/출력-버퍼)
    - [L2스위치](#l2스위치)
    - [TCP/IP통신시 MAC주소 변화](#tcpip통신시-mac주소-변화)
    - [L2스위치 작동원리, ARP](#l2스위치-작동원리-arp)
    - [TTL](#ttl)
    - [3 way handshake, 4 way Handshaking](#3-way-handshake-4-way-Handshaking)
    - [MTU, Packet 단편화](#mtu-packet-단편화)
    - [Unicast, Broadcast, Multicast](#unicast-broadcast-multicast)
    - [서브넷팅](#서브넷팅)
    - [공유기 작동원리](#공유기-작동원리)
    - [부하분산(Load Balancer)](#부하분산load-balancer)
    - [VPN작동원리(L3, IPSec)](#vpn작동원리l3-ipsec)
    - [네트워크 보안 종류](#네트워크-보안-종류)
  - [Network활용](#network활용)
    - [http와 Socket통신과 TCP](#http와-socket통신과-tcp)
    - [서버 상태 확인하기](#서버-상태-확인하기)
    - [wireshark(패킷 분석 프로그램)](#wireshark패킷-분석-프로그램)
    - [Ping테스트](#ping테스트)
    - [네트워크 경로 추적(tracert)](#네트워크-경로-추적tracert)
    - [내부 서버 만들기](#내부-서버-만들기)
    - [CSR,SSR,TTV,TTI](#csr,ssr,ttv,tti)
    - [웹 어셈블리(WebAssembly 혹은 WASM)](#웹-어셈블리webassembly-혹은-wasm)

<br/>
<br/>

- [리버싱](#리버싱)

<br/>
<br/>

***

# Basic
  - [Native Code,중간언어,이진법,컴퓨터기본구조 3가지](#native-code중간언어이진법컴퓨터기본구조-3가지)
  - [언어수준(저수준언어, 고수준언어)](#언어수준저수준언어--고수준언어)
  - [타입별(강한타입, 약한타입)](#타입별강한타입-약한타입)
  - [처리수준(컴파일언어, JIT컴파일언어, 인터프리터)](#처리수준컴파일언어--jit컴파일언어--인터프리터)
  - [메모리관리(매니지드, 언매니지드)](#메모리관리매니지드-언매니지드)
  - [프로그래밍 패러다임(절차적언어, 개체지향 언어OOP)](#프로그래밍-패러다임절차적언어-개체지향-언어oop)
  - [프레임워크, 라이브러리](#프레임워크-라이브러리)
  - [디버그(debug)빌드, 릴리즈(release)빌드](#디버그debug빌드-릴리즈release빌드)
  - [컴파일(Compile)](#컴파일compile)
  - [CLI(CMD,터미널,쉘)](#clicmd터미널쉘)
  - [장치통신](#장치통신)
  - [기타, 도움링크](#기타-도움링크)

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# Native Code,중간언어,이진법,컴퓨터기본구조 3가지

  - Native Code : CPU와 운영체제가 직접적으로 실행할 수 있는 코드이다. C와 C++언어 같은 경우 '컴파일'이라는 과정(전처리->컴파일->어셈블->링크)을 거쳐서 '실행파일인 기계어'가 된다. 프로그램을 실행하면, 이미 바로 기계가 이해할 수 있는 기계어 이기 때문에 바로 실행하게 된다. 하지만 단점으로는, OS변경, OS버전변경 및 HW환경이 달라지면 실행이 불가능 하게 되는 경우도 있다.(C언어 C++언어 -> 컴파일(윈도우 API와 맞춰지면서 기계어로 변경) -> 기계어로 바뀐 exe를 실행 시켜서 작동)
  - 가상환경 위에서 작성되는 코드(C#, 자바 등)  : 각각의 언어들은 컴파일 및 실행을위한 가상 환경을 필요로 한다. 컴파일 하게 되면 각각의 언어들이 가지는 중간 언어로 작성된 실행 파일을 만든다. 프로그램을 실행 시키면, 가상환경에서 중간 코드를 읽어 들여 CPU 및 하드웨어가 이해할 수 있는 네이티브 코드로 컴파일한 후에 실행하게 된다. C#을 컴파일한 후 JIT 컴파일러에 의해 생성된 네이티브 코드는 C 및 C++용으로 컴파일된 기계어 코드와 동일하지 않다. 런타임 시 JIT 컴파일러에 의해 생성되는 플랫폼별 코드인 반면, C 및 C++용 머신 코드는 일반적으로 특정 플랫폼에 대해 미리 별도의 컴파일러에 의해 생성된다. JIT 컴파일러에 의해 생성된 코드는 실행 중인 특정 아키텍처 및 운영 체제에 맞게 최적화될 수 있으며 C 및 C++용 머신 코드는 특정 대상 플랫폼에 맞게 최적화된다.
  - 안드로이드 개발시 , 자바코드 -> 컴파일(자바 중간 언어,ART) -> 에뮬레이터 위에서 실행 -> 자바중간언어가 에뮬레이터안에 있는 안드로이드 API와 맞춰지면서 안드로이드 원시코드로 변경 되면서 실행 및 작동

<br/>

  - 컴퓨터는 왜 이진법을 사용하는가
    - 하드웨어 적으로 컴퓨터는 '전기가 흐른다 1', '전기가 흐르지 않는다 0'라는 두가지 상태밖에 없기 때문(2진법을 사용)
    - 예전에는 전압의 크기를 이용해서, 2진법이상으로 사용해보려고 했지만, 예민한 부분들로 인해 그것들이 정확하지 않았고, 결국 이진법을 사용하기로한 것으로 알고 있다

<br/>

  - 컴퓨터의 기본 구조3가지
    - C언어 같은 네이티브 언어는, OS에 직접적으로 의존적인 언어가 된다

![image](https://user-images.githubusercontent.com/39178978/209467550-f66135b7-f6fc-4a64-9f63-bb0300b7e469.png)

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# 언어수준(저수준언어 , 고수준언어)
  - 컴퓨터가 이해하지 쉬운 언어에 가까울수록 저수준 언어
    - 0과1로만 이루어짐(= 기계어)
  - 인간이 이해하기 쉬운 언어에 가까울수록 고수준
    - 어셈블리어, C, C++ 등등
      - 어셈블리어는 기계어와 1:1대응하는 언어기 때문에 사실상 저수준 언어..(다른 언어는 1:1대응이 아님)
  - 언어의 수준은 상대적인 부분이 있음(ex 어셈블리어는 C 보다 상대적으로 저수준 언어)

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# 타입별(강한타입, 약한타입)
  - 타입검사에 엄격한가, 엄격하지 않은가에 대한것. 컴퓨터가 이해하는 데이터는 수로 이루어져 있기 때문에 사람 입장에서는 그 수만 보아서는 실제로 정수를
의미하는지 문자열을 의미하는지 알 수가 없기 때문에 타입지정이 생겨났음.따라서 강한타입일 수록 타입 검사에 엄격하기 때문에 추후에 생길 버그나 오류를 줄 일 수 있다.
  - ex) 파이썬 같은 경우는 변수형을 비선언 한다.

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# 처리수준(컴파일언어 , JIT컴파일언어 , 인터프리터)
  - 컴파일언어(코드 - 컴파일[기계어로 바꿔줌] - 기계어[실행파일로 바꿔줌 exe파일] - 실행)
    - 실행만 할 경우 마지막 두 단계만 왔다 갔다 하는것
    - 코드를 바꿔야 할 경유 처음부터 순서를 밟아 다시 진행한다
    - 다양한 최적화 가능(2시간 동안 컴파일, 0.1초 만에 실행)
    - 기계어가 나오기 때문에(다른 CPU에서 이해 불가능) 플랫폼마다 다른 exe파일을 컴파일 해야함
    - C, C++
  - JIT컴파일언어(코드 - 컴파일러[중간언어로 바꿔줌] - 중간언어["exe" <- 실행 파일이라고 하기 뭐함..] - JIT컴파일러(기계어) - 실행)
    - 프로그램 실행 중에 VM이 중간 언어를 기계가 이해하는 언어로 바꿔서 실행
    - 플랫폼 별로 VM(가상머신)을 설치해야함
    - 플랫폼에 종속적이지 않고 VM에 종속적임
    - C#, Java 등
  - 인터프리터언어(코드 - 인터프리터[기계어로 바꿔줌 <- 실행하면서 실시간으로 바꿔줌] - 실행)
    - 실제로 실행하기 전까지 코드의 문제를 잡아낼 수 없음

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# 메모리관리(매니지드, 언매니지드)
  - 매니지드 언어 : 언어가 메모리를 관리해줌
    - 언어가 자체적으로 모든 상황에서, 충분한 판단으로 메모리를 반환하기 때문에 명시적으로 반환하는 것보다 효율적이지 않음
  - 언매니지드 언어 : 언어가 메모리를 관리 안해줌
    - 명시적으로 메모리를 반환하기 때문에 효율적임
    - 프로그래머가 신경써 줘야 되기 때문에 실수가 나올 수 있음
    - 성능이 필요할 경우에 사용
    - 메모리동작원리, CPU동작원리, 컴퓨터처럼 생각하는 방법, 매니지드 언어에서 지원하는 마법같은 기능의 동작원리 등을 알 수 있고 이해할 수 있게 된다.

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# 프로그래밍 패러다임(절차적언어, 개체지향 언어OOP)
  - 절차적 언어 : 순서에 따라 위에서 부터 아래로 절차적으로 코드를 실행하는 것. 컴퓨터의 처리구조와 유사해 속도가 빠름
  - 개체지향 언어(클래스) : 기능과 자료를 하나의 개체에 합침
    - 사람에게 직관적. ex)사물을 볼때 하나의 정보만 보는 것이 아니라 컬러,질감,모양,무게 등 다양한 정보로 하나의 사물을 바라봄
    - 복잡한 프로그램의 구조를 잡기 쉽다, 재사용성 증가, 변형가능성을 높일 수 있음

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# 프레임워크, 라이브러리
  - 라이브러리 : 여러 함수들을 모아 놓은 집합. 프로그래머가 필요할때 가져와서 대체해 사용할 수 있음
  - 프레임워크 : 라이브러리의 상위 개념, 제공받은 일정한 요소와 틀, 규약을 가지고 무언가를 만들어 낼 수 있음
  - 라이브러리와 프레임워크의 차이는, 라이브러리는 필요할때 필요한 함수를 프로그래머가 불러다가 쓸 수 있지만, 프레임워크는 프로그래머가 부르는 것이 아니라, 프로그래머가 그 안에 들어가 일정한 틀과 규약을 준수 하면서 개발을 해날갈때 쓰는 도구 같은것.
  - C#은 최상단에 'Using'지시어 뒤에 사용할 라이브러리(= 네임 스페이스 라고도 부름) 이름을 넣는다.

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# 디버그(debug)빌드, 릴리즈(release)빌드
  - 디버그빌드 : 개발자가 개발 중에 사용하는 실행파일
    - 디버깅에 유용한 많은 정보가 담겨 있음
    - 성능 떨어짐
  - 릴리즈빌드 : 실제 사용자에게 배포하는 실행파일
    - 디버깅을 위한 정보는 빠지게 됨
    - 성능 빠름

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# 컴파일(Compile)
  - 소스코드를 기계 또는 VM(Virtual Machine)이 이해할 수 있는 언어로 변경하는 행위
    - 컴파일로(compiler)라는 프로그램이 진행해줌 ex)IDE(통합개발 환경)
    - 컴파일 할때 오류또는 경고가 발생할 수 있음

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# CLI(CMD,터미널,쉘)
  - 현재는 GUI로 컴퓨터를 사용했지만 예전에는 GUI환경이 아닌 CLI(명령어로 컴퓨터를 조작하는 방식)환경에서 컴퓨터를 이용해 왔음. 요즘에는 대부분 운영체제에서 GUI로 작동 시키기 때문에 현재는 CLI를 ‘컴퓨터를 직접 제어하기 위해 사용하는 소프트웨어’ 정도로 생각해보면 된다.
  - CLI가 일부 작업을 완료하는 것이 훨씬 빠르고, GUI로 사용하는 것보다 훨씬 많은 명령을 내릴 수가 있다
  - GUI로 여러번 해야 하는 것을, 명령어 하나로 처리 할 수 있다

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# 장치통신
  - OS에서 모든 장치와 통신하려면 일반적으로 디바이스 드라이버가 필요하다. 디바이스 드라이버는 하드웨어 장치와 컴퓨터 운영 체제 간의 인터페이스 역할을 한다. 디바이스 드라이버는 운영 체제가 하드웨어 장치를 제어하고 데이터를 전송하는 방법을 알 수 있도록 지원한다.
  - 일부 경우에는 디바이스 드라이버가 필요하지 않을 수도 있다. 예를 들어, 일부 하드웨어 장치는 표준 프로토콜을 사용하여 운영 체제와 통신할 수 있으며, 이 경우 운영 체제에 이미 내장된 표준 드라이버를 사용하여 장치와 통신할 수 있다.
  - 표준 드라이버는, 일반적으로 하드웨어 장치의 제조업체가 제공하는 것이 아니라 운영 체제에서 제공하는 것이고, 윈도우 11에 포함된 표준 드라이버의 종류로는 디스플레이 드라이버, 네트워크 어댑터 드라이버, 오디오 드라이버, 프린터 드라이버, USB 드라이버 등이 있다. 이러한 표준 드라이버는 일반적으로 하드웨어 장치와 호환되며, 사용자가 추가적인 드라이버 설치 없이도 장치를 사용할 수 있도록 지원한다.

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

# 기타, 도움링크
- CS공부 하기 좋은 사이트 : https://gyoogle.dev/blog/computer-science/data-structure/Heap.html

###### [Basic](#basic)
###### [Top](#top)

<br/>
<br/>

***

# 컴퓨터 기본수학
  - [자료크기](#자료크기)
  - [접두사](#접두사)
  - [형변환](#형변환)
  - [값형, 참조형](#값형-참조형)
  - [이스케이프문자](#이스케이프문자)
  - [음수-표현법](#음수-표현법)
  - [문자인코딩](#문자인코딩)
  - [유리수표현법](#유리수표현법)
  - [불대수](#불대수)
  - [빅오 표기법(시간복잡도)](#빅오-표기법시간복잡도)
  - [알고리즘](#알고리즘)
  - [자료구조](#자료구조)
  - [컴퓨터가 사진을 다루는법(그래픽 카드의 원리, VGA)](#컴퓨터가-사진을-다루는법그래픽-카드의-원리-vga)
  - [컴퓨터가 글자를 다루는법](#컴퓨터가-글자를-다루는법)
  - [진법](#진법)
  - [8진법, 16진법, 32진법](#8진법-16진법-32진법)
  - [진수변환](#진수변환)
  - [비트,바이트](#비트바이트)
  - [비트, 음수와 양수의 관계 및 수의표현, 및 최하위 비트로 짝수 홀 수 판단](#비트-음수와-양수의-관계-및-수의표현-및-최하위-비트로-짝수-홀-수-판단)
  - [비트마스킹(bit masking)](#비트마스킹bit-masking)
  - [증감 연산자](#증감-연산자)
  - [비트이동연산자](#비트이동연산자)
  - [비트연산자](#비트연산자)

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 자료크기
  - 비트(bit) : 최소단위 1혹은0을 담을 수 있음
  - 바이트(byte) : 8비트가 모인것
  - 1024바이트 = 1킬로 바이트(KB)
  - 1024킬로바이트 = 1메가 바이트(MB)
  - 기가,테라,페타....

<br/>

  - 하지만 현재 판매하고 있는 하드디스크, 네트워크, 인터넷망 등은 1000바이트 = 1킬로 바이트, 1000킬로바이트 = 1메가 바이트 이렇게 되어 있음. 그래서 1GB외장 하드를 구매 해서 컴퓨터에서 본다면 데이터를 잃어 버리는 격이 된다.(하드디스크 : 1GB = 1,000,000,000바이트, 컴퓨터 : 1,000,000,000 / 1024 / 1024 / 1024 = 0.931GB)

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 접두사
  - 0b- : 2진수 ex) int num1 = 0b10  //이때 num1에 들어가는 수는 2가됨
  - 0x- : 16진수 ex) int num1 = 0x10 //이때 num1에 들어가는 수는 16이됨  

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 형변환
  - 묵시적 변환 : 컴파일러가 '알아서' 해주는것
    - 모든 자료형을 바꿀 수 있는 것은 아님
  - 명시적 변환 : 프로그래머가 명시적으로 형변환을 지시함(전부x)
  - 승격 : 컴파일러가 자동으로 실수형이나 부동소수형 자료의 이진 표현을 확장 하는것
    - double num1 = 5.5, int num2 = 3 / num1 + num2 = 8.5가 나오게 된다. double로 승격하여 계산 한것
      - [꼼수 : 승격을 이용하여double number = 123.456 을 소수점 첫째 자리만 나타내기
](https://github.com/BuMinKyoo/TIL/tree/main/C%23/%EA%BC%BC%EC%88%98...)

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 값형, 참조형
  - 값형 : 자신이 직접 데이터를 저장해서 보관하는 자료형(스택 영역에 저장)
    - 스택은 메모리에 아래서부터 데이터가 쌓였다가 데이터가 제거될 때는 맨 위에 있는 데이터부터 차례로 제거되는 방식이다
  - 참조형 : 데이터가 저장되어 있는 힙의 위치만 자신이 저장하고 있다가 필요할 때 그 데이터가 있는 곳으로 가서 데이터를 얻어오는 자료형(힙 영역에 저장)  
    - 힙은 쌓여 있는 구조가 아니라, 임의의 메모리에 데이터를 저장한다. 그러한 특성 때문에 힙은 자유 기억 공간이라고도 한다

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 이스케이프문자
  - \n -> 줄바꿈
  - \t -> 탭
  - \' -> 작은따옴표 출력
  - \" -> 큰따옴표 출력
  - \\ -> 백슬래시 출력
  - \x(숫자) -> 아스키값16진수 출력 ex) \x120출력 -> ?가 출력됨

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 음수 표현법
  - 공부한 블로그 링크 : https://st-lab.tistory.com/189 
  - 부호 절대값(Sign-Magnitude) : 컴퓨터 세계에서 부호를 붙이기 위해서 8비트의 최상위 비트가 0이면 양수, 1이면 음수로 지정하게 됨
    - 단점
      - +0과, -0둘다 존재하는것
      - 양수+양수 덧셈은 문제가 없지만, 음수+양수, 양수+음수, 음수+음수를 할때 각 상황마다 다르게 고려해야 된다.

<img src="https://user-images.githubusercontent.com/39178978/155979686-84fee69b-40e6-4c00-b021-39c656c943ed.png"/>

  - 1의 보수 (One's Complement)
    - ex) 7에 대한 10의 보수 : 7 + 3 = 10 => 3 / 17에 대한 10의 보수 : 17 + 83 = 100 => 83
    - ex) 7에 대한 9의 보수 : 7 + 2 = 9 => 2 / 17에 대한 9의 보수 : 17 + 92 = 99 => 82
    - ex) 10의 보수를 이용한 계산(-20+45) : (100-20)+45-100 => 80+45-100 => 125-100(올림이 발생하니 버림) = 25
    - ex) 0000 0011에 대한 1의 보수 : 0000 0011 + 1111 1100 = 1111 1111 => 1111 1100(음수는 양수의 비트를 반전시킨 값)
    - 8비트짜리 정수일경우 0과 +0이 존재 하기 때문에 수의 범위는 [-127,127]
    - 단점
      - +0과, -0둘다 존재하는것
      - 계산시 캐리가 발생하면 +1을 해줘야함

<img src="https://user-images.githubusercontent.com/39178978/155984631-d0175195-6254-4aa8-99cf-86a2675d8f4c.png"/>

  - 2의 보수 (Two's Complement)
    - 1의 보수에서 사용하면 -0(1111 1111)을 없애고 -1씩 대응시키게됨
    - 어떤 수의 부호를 바꾸고자 하면 비트를 반전시키고 거기에 1을 더하면됨
    - 부호 절대값과 1의 보수에 있었던 문제를 모두 해결하게 됨
    - 8비트짜리 정수일 경우 0이 하나만 존재 하기 때문에 수의 범위는 [-128,127]
    - 장점
      - 0이 1개 밖에 없음
      - 캐리가 발생해도 +1을 하지 않아도 됨
      - 양수+양수, 양수+음수, 음수+양수, 음수+음수의 모두 계산이 문제가 없음

<img src="https://user-images.githubusercontent.com/39178978/155987419-97bcb7b8-b958-41b7-8039-c88b5ca37a2c.png"/>

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 문자인코딩
  - 아스키(ASCII)
    - 영어 알파펫과 기호들을 컴퓨터에서 표현하는 규약
    - 최초의 아스키는 총 128개의문자를 표현(7비트사용, 1비트는 오류 검증으로 사용)
    - 영어권에서는 주로 아스키를 사용함(영어와, 특수문자가 다 들어가 있기 때문)
  - ANSI(Windows-1252, CP-1252)
    - ASCII의 확장판
    - 영어뿐만 아니라 다른 라틴문자 기반의 언어를 표시하기 위해 만든 문자 인코딩
    - 256개의 문자를 표현(8비트를 모두사용) => 하지만 이렇게 해도 세상의 모든 언어를 표시 할 수 없기 때문에 CodePage개념이 추가됬다.
    - ANSI = ASCII Code(7bit) + CodePage(1bit)
  - 멀티바이트(Multibyte)_MBCS
    - Ms사가 급부상 하게 되었을때, Ms사가 만들었음
    - 표기할 문자가 많은, 1바이트에 담을 수 없는 언어들을 위해서 나옴
    - 기본적으로 아스키코드에 들어가 있는 1바이트(영문,숫자,기본적인 특수문자)는 그대로 가고, 그다음에 더 필요한 문자들을 채워 넣음
    - ex) EUC-KR, EUC-CN, EUC-TW 등등...
    - 여러 언어를 한번에 표현 하지 못하기 때문에, 한페이지에 다른 나라 언어가 적혀 있으다면 동시에 표현이 안됨
    - 영문 한글자 = 1byte처리, 한글 한글자 = 2byte처리
  - 유니코드(Unicode)
    - 전 세계의 모든 문자 및 이모지까지 '일관되게'표현할 수 있는 규격
    - 2021년09월14일에 Unicode 14.0이 나왔고 144,697문자를 표현한다, 지금도 계속 늘려 가고 있음
    - UTF-8(1바이트), UTF-16(2바이트), UTF32(4바이트) : 한글자를 저장할때 몇바이트를 쓸건지 명시하는것
    - 한글은 초기에 조합형, 완성형에 대한 고민이 있었지만, 완성형으로 결정됨(아래 사이트에서 확인 가능)
      - unicode.org
        - 여기에 나와 있는 것은 기본적으로 UTF-16 인코딩되어 표기되어 있기때문에, 영문과 한글 모두 2byte로 표기됨
 
![image](https://user-images.githubusercontent.com/39178978/209461102-1413d2db-b1db-45c6-8a48-e02749055ac4.png)

![image](https://user-images.githubusercontent.com/39178978/209461105-ce2030cd-b642-4e4d-9a7c-ad7216581a1b.png)
 
![image](https://user-images.githubusercontent.com/39178978/209461958-03535740-02e4-4a8f-8a35-216bc93a8664.png)

![image](https://user-images.githubusercontent.com/39178978/209462079-55778768-5ec4-4392-a429-fc1fe8d282b8.png)
 
 <br/>
 
  - 유니코드(Unicode) 인코딩 규칙
    - UTF-8
      - 아스키 코드와 100% 호환
      - 바이트 정렬(엔디언)문제가 발생하지 않음
      - CJK(중국,일본,한국)를 제외한 거의 모든 문자에 1바이트 또는 2바이트를 사용
        - 한국어는 대부분 3바이트가 필요함 => UTF-16을 쓰면 대부분 2바이트로 표현 가능
      - UTF-8은 1바이트, 즉 8비트 이다, 유니코드상 표기가 높은 수쪽에 있는 한국어의 경우 UTF-8로 인코딩 했을시 2바이트 또는 3바이트가 필요하기 때문에, '비트 패턴을 넣어서 이 글자가 몇 바이트로 인코딩 되고 있는지'를 알려 주어야 한다. => 따라서 몇개의 비트수를 낭비하지만 4바이트까지 총 21개 비트를 표현 할 수 있다.(2,097,152개 표현)
      - 글자가 영어인지, 한글인지 등 확인후, 범위에 따라서 바이트 수가 달라지게 표현됨

<img src="https://user-images.githubusercontent.com/39178978/156084310-07986758-02a3-48a4-bab5-dbda2e15edd3.png"> 

![image](https://user-images.githubusercontent.com/39178978/209461779-2f28861c-3224-4e49-9aa9-6381cc8ee944.png)

  - 유니코드(Unicode) 인코딩 규칙(이어서)
    - UCS-2
      - 고정 2바이트 인코딩
      - UTF-16이 나오기 전에는 이것을 사용했으며, 기본 언어판영역(U+0000~U+FFFF)만 인코딩 할 수 있는 고정인코딩 방식이며, 그 것을 넘어가는 글자는 표현할 수 없다

    - UTF-16
      - 인코딩/디코딩 규칙이 복잡
      - 엔디언 문제 ex)리틀 엔디언으로 저장했는데 빅 엔디언으로 읽으면 잘못된 결과 나옴
      - 아스키와 호환 안됨
      - 메모장을 다른이름 으로 저장시 UTF-16 LE : 리틀 엔디언, UTF-16 BE : 빅 엔디언
      - UTF-16은 UCS-2와 다르게 가변길이이며. 기본 언어판영역(U+0000~U+FFFF)은 한개의 16-bit가 되고, 다른 언어판(U+10000 이상)은 두개의 16-bit로 표현되어, 모든 언어를 표현할 수 있는 인코딩이다.

![image](https://user-images.githubusercontent.com/39178978/209461833-f9b0ae99-a62c-4b15-ae69-9dc3d0e7b838.png)

![image](https://user-images.githubusercontent.com/39178978/209462086-a47b784e-f0cf-47e6-b482-b278d53a4f96.png)

  - 유니코드(Unicode) 인코딩 규칙(이어서)
    - UTF-32
      - 유니코드 code point와 1:1대응
      - 용량 낭비가 심함
      - 아스키와 호환 안됨
      - 엔디언 문제 있음

<br/>

  - URL인코딩
    - 웹통신을 할때 쓰는 인코딩값(= UTF-8을 사용)
    - 16진수 값으로 날아가게 되고, 16진수 값을 그대로 썼다는 의미로 앞에 % 를 붙이게 된다
    - EX) 감 == %EA %B0 %90 

<br/>

  - Window어플리케이션 개발시
    - MBCS(멀티바이트) : 영문은 1byte, 한글은 2byte
    - WBCS(= 일명 유니코드 방식) : 모든 문자를 2byte
    - 멀티바이트는, 문자에 따라 크기를 다르게 가지므로 프로그램을 짤때 항상 문자의 종류에 따라 문자의 크기를 고려하여 프로그램을 해야 하기 때문에 번거롭게 되지만, 유니코드방식으로 하게 되면 항상 일정하기 때문에 쉬워진다

<br/>

  - Base64인코딩
    - 6bit씩 끊어서, 특정한 ASCII문자로 처리하게 된다
    - Base64인코딩을 하면 6bit를 ASCII문자(8bit) 하나로 처리하게 되어 오히려 효율 면에서 떨어지게 된다
    - 6bit씩 자르다가 마지막에 6bit가 남아 있지않다면, "="을 사용해서 padding을(필요 없는 값) 추가해 보내게 된다.
    - 왜 할까?
      - HTML문서는 ASCII로 되어 있음. ASCII로 표현할 수 없는 바이너리 데이터가 있을 수 있음(ex. 이미지). 그것을 강제로 HTML문서 안에다가 포함 시킬때 유용하다.
        - 누군가가 HTML + 이미지를 요청할때, HTML안에 모두 포함되어 있으면 1번의 요청 만으로 다 받을 수 있지만 그렇지 않다면 HTML + 이미지를 각각 한번씩 요청해서 받아야 한다(요청을 1번 한다는 효율이 있음!)

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 유리수표현법
  - 10진법 실수  550.337 = 500 + 50 + 0 + 0.3 + 0.03 + 0.07

<img src="https://user-images.githubusercontent.com/39178978/156096606-5d286196-a5f5-4165-9bbc-05431083b942.png"/>

<br/>

  - 2진법 실수 101.011 = 4 + 0 + 1 + 0/2 + 1/4 + 1/8

<img src="https://user-images.githubusercontent.com/39178978/156096940-4a6397b9-14a9-479d-98da-cb4414ba8a50.png"/>

<br/>

  - 실수의 10진수 -> 2진수 변환
    - 11.8125 = 1011.1101(2진수) => [8  4  2  1 . 0.5  0.25  0.125  0.0625]
    - 10진수 0.1을 2진수로 바꾸려고 하면 나누어 떨어지지 않기 때문에 정확하게 표현 되지 못한다.

<img src="https://user-images.githubusercontent.com/39178978/156138197-24e8bfb0-a508-41ac-922e-fda36f809007.png" width="250" height="500"/>

<br/>

  - 고정 소수점 수
    - 언제나 정해진 자리에 소수점이 찍혀 있다는것
    - 8비트를 예로 들면, 부호비트로 1개소, 정수부분 4개소, 소수부분 3개소로 표현 한다면 기호로 Q4.3이라고 표현 함
    - 표현할 수 있는 범위의 값은 확실히 표현 가능(오차가 없어야 하는 제품에 적합)
    - 표현 가능한 범위가 작아짐

  - 부동 소수점 수
    - 소수점 자리가 정해져 있지 않다
    - 돈 관련되서는 사용하는데 부적합함 => 하지만 다른곳에 사용하는데는 큰 문제는 없음 ex) 0.001m잘못 움직였다고 일반적으로 큰일이 나지 않음
    - 표현 가능한 범위가 넓음
    - IEEE 754표준을 따름

  - IEEE 754표준(32비트 부동 소수점)
    - 부호비트 : 1비트 / 지수비트 : 8비트 / 가수비트 : 23비트
    - 정규화 작업 : 110.110111 => (+1) * 1.10110111 * 2의2승 / -0.00123 => (-1) * 1.23 * 2의마이너스2승
    - 음수를 표현할때 부호 절대값 방식을 사용함
    - ex) 234.48 => 11101010.0111101011100001 = 1 * 1.11010100111101011100001 * 2의7승
      - 부호비트 = 0
      - 지수비트 : 10000110(7+127 = 134)
      - 가수비트 : 11010100111101011100001
    - ex) -234.48 => 11101010.0111101011100001 = (-1) * 1.11010100111101011100001 * 2의7승
      - 부호비트 = 1
      - 지수비트 : 10000110(7+127 = 134)
      - 가수비트 : 11010100111101011100001
    - ex) 3.14 => 11.0010001111010111000011 => 1 * 1.10010001111010111000011 * 2의1승
      - 부호비트 : 0
      - 지수비트 : 100000000(1+127 = 128)
      - 가수비트 : 10010001111010111000011
      - 0 100000000 10010001111010111000011 => 10진수 변한 => 지수 : 128 - 127 = 1 / 가수 : 10010001111010111000011 = 1.10010001111010111000011 => 1.10010001111010111000011 * 2의1승 = 11.0010001111010111000011 => 3.1400001049041748046875 => 값이 오차가 생김!
    - float 정밀도 : 6 ~ 9자리 / double 정밀도 : 15 ~ 18 <= 범위가 있다는 것이 이상한데 그 이유를 아래에 설명
      - float 정밀도 : 6자리 : 10진수 실수를 float(double)에 저장했다가 다시 그걸 10진수 실수로 변환한뒤, 원래 10진수 실수와 동일한 유효 숫자로 맞출 때 원래 값이 그대로 나올 수 있는 최대 유효숫자 수는 6자리이다
      - float 정밀도 : 9자리 : 서로 다른 수가 정말 다르다는 걸 알려면 최대9번째 유효숫자까지 확인해야 한다는것

~~~c#
//float 정밀도 : 6자리

static void Main(string[] args)
{
    long i = 123456000000000;
    float f = i;
    i = (long)f;
    Console.WriteLine(i);
}

출력
123455999574016 <= 6자리 그 다음에 7번째에서 반올림 하면 123456이 나오게됨. 그러므로 어떤 유효숫자 다음의 수는 그 유효숫자가 되기 위한 근접 수로 표현 하게됨
~~~

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 불대수
  - 드 모르간의 법칙 => 전체를 뒤집으면 결과가 같음
  - if(!(age >= 20 && height >= 140)) = if(age < 20 || height < 140)
  - if (!(student.Age < 25 || student.TermNum == 2)) = if(student.Age >= 25 && student.TermNum != 2)

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 빅오 표기법(시간복잡도)
  - O(1) : 반복문이 없음, 상수 => 오직 한 단계만 거침
  - O(log n) : 분할 알고리즘 ex)이진탐색 => 필요한 단계들이 연산마다 특정 요인에 의해 줄어듬 
  - O(n) : for문 하나
  - O(n^2) : 이중 for문 => for문이 밖에 있으면 2n이됨
  - O(2^n) : 피보나치
  - O(n!) : 모든 도시를 단 한번만 방문한 뒤 다시 첫 도시로 돌아오는 경로, 완전탐색

<img src="https://user-images.githubusercontent.com/39178978/156878962-9f1d688b-9d06-40cd-ae2b-918bb9040f24.png" width="600" height="350"/>

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 알고리즘
  - 자료구조에 쌓인 데이터를 활용해 어떤 동작들을 만들어 가는것

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 자료구조
  - 데이터를 원하는 규칙 또는 목적에 맞게 저장하기 위한 구조
  나중에 더 추가하기...
 
###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)
 
<br/>
<br/>

# 컴퓨터가 사진을 다루는법(그래픽 카드의 원리, VGA)
  - 컴퓨터가 사진을 다루는법(그래픽 카드의 원리, VGA)
    - 16비트 사용시 : 하이컬러
    - 24비트 사용시 : 트루컬러
    - 32비트 사용시 : 트루컬러 + 알파 채널

픽셀 하나에 필요한 비트 수가 16,24,32개라는 의미로써, 이렇게 사진도 비트들이 모여서 정해진 컬러의 빛을 쏘아 표현하게 된다.

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 컴퓨터가 글자를 다루는법
  - 아스키 코드와 같이, 1:1로 문자와 특정한 비트를 대응해서 표현한다.
  - 다양한 인코딩 규격이 있으며, 인코딩 규칙을 참고하면 된다

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 진법
  - 수를 표현하는 방법
  - 2진법, 8진법, 10진법, 16진법 등
  - ex) 2진법 : 2개의 숫자를 사용하여 수를 표현하는 방법 => 표현법 0b (0,1)
  - ex) 16진법 : 16개의 숫자를 사용하여 수를 표현하는 방법 => 표현법 0x (1,2,3,4,5,6,7,8,9,A,B,C,D,E,F)

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 8진법, 16진법, 32진법
  - 비트는 단위가 작아서 비트 8개 모인 바이트를 기본 단위로 사용하게 되는데, 8진법이나, 32진법 같은 경우 비트수 3개, 5개 이기 때문에 메모리 단위로 데이터를 저장하기에는 딱딱 끊어지지 않아서 적합하지는 않는다. 그에 비해서 16진법은 비트수4개로(1바이트에 16진수 자리는 2개) 잘 들어맞기 때문에 적합하다고 할 수 있다

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 진수변환
  - 10진수 -> 다른진수 바꿀때, 10진수 수를 다른진법에 해당하는 수로 나누어서 나머지쪽 부터 확인하면 됨

10진수 -> 2진수
<img src="https://user-images.githubusercontent.com/39178978/155839336-a1ef1e91-29be-4e67-be07-40d3033794f8.jpg" width="250" height="350">

<br/>

10진수 -> 8진수
<img src="https://user-images.githubusercontent.com/39178978/155839339-cf8fdeaf-9b35-44f3-b043-fb04b08722ed.jpg" width="250" height="350">

<br/>

  - 2진수 -> 8진수 : 2진수를 세 자리씩 끊어서 8진수 한자리로 변환
  - 8진수 -> 2진수 : 8진수 한 자리를 2진수 세자리로 변환

<img src="https://user-images.githubusercontent.com/39178978/155839708-eb10184a-2afb-470e-9e08-e393bb5cf27d.jpg" width="250" height="350">

  - 2진수 -> 16진수 : 2진수를 네 자리씩 끊어서 16진수 한자리로 변환
  - 16진수 -> 2진수 : 16진수 한 자리를 2진수 네자리로 변환

<img src="https://user-images.githubusercontent.com/39178978/155839703-3b9e8489-f6fd-4482-a5f2-afe51fa010d1.jpg" width="250" height="350">

<br/>

  - 8진수 -> 16진수 : 2진수를 거쳐서 변환 하는것이 편함

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 비트,바이트
  - 비트 : 컴퓨터의 구성요소인 트랜지스터에 전기가 흐르면 1, 흐르지 않으면 0 으로, 트랜지스터의 상태를 기록하는 최소 단위를 비트라고 한다
  - 바이트 : 비트가 8개 모인 데이터

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 비트, 음수와 양수의 관계 및 수의표현, 및 최하위 비트로 짝수 홀 수 판단
  - 비트당 표현 가능한수 2가지, 즉 2의 n승가짓수로 표현 가능
  - 부호 있는 자료형은 양수에서 0을 포함함으로 범위로는 음수가 1개소 더 많이 표현 가능
    - ex) sbyte인 경우 8비트 이기 때문에 표현 가능한 수는 2의 8승으로 256가짓수. 0을 양수에 포함 시키고 절반씩 나누게 되면 음수는 128가지 양수는 0을 제외한 127가지, 즉 [-128~127]까지의 수를 표현 가능
    - ex) ㅁㅁㅁㅁㅁㅁㅁㅁ 8개의 비트가 있다면 맨 위쪽의 최상위 비트 가짓수가 나머지 표현 가능한 비트의 수많큼이 되므로, 음수는 최상위 비트가 1로 표현 된다고 볼 수 있다.
    - 자료형의 크기보다 크기가 커지거나 작아지면 '오버플로우' 또는 '언더플로우'가 발생한다
    - 최하위 비트가 0이면 짝수, 1이면 

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 비트마스킹(bit masking)
  - 각각의 비트에 하나의 기능을 만든후, 그것을 키고 끄고 하는식으로 이용
  - 하나의 비트만을 켜고 싶을 경우
    - 어떤수에 |(비트 합 연산)을 하고, 켜고 싶은 비트만을 1 로 해두기 ex) 0b0000 1000
  - 하나의 비트만을 끄고 싶을 경우
    - 어떤수에 &(비트 곱 연산)을 하고, 끄고 싶은 비트만을 0 으로 해두기 ex) 0b1111 0111
  - 특정 비트 토글하기
    - 어떤수에 xor연산을 하고, 토글 하고 싶은 비트만을 1 로 해두기 ex) 0b0000 1000

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 증감 연산자
  - 증감 연산자(++ , --)
    - 증감 연산자가 앞쪽에 있으면 증감 해주고 계산
    - 증감 연산자가 위쪽에 있으면 계산후 증감

~~~c#
int num = 0;
Console.WriteLine(++num + ++num + ++num); // 6
~~~

~~~c#
int num = 0;
Console.WriteLine(num++ + num++ + num++); // 3
~~~

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 비트이동연산자
  - 비트이동연산자(<<[왼쪽으로이동], >>[오른쪽으로이동])

~~~c#
int num = 1; //num = 0b0001
int num2 = num << 3; //num2 = 0b1000
Console.WriteLine(num2); //num2 = 8
~~~

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 비트연산자
  - 비트연산자(&[and], |[or], ^[xor], ~[not])
  - 연산자 우선순위 : & -> ^ -> |

~~~c#
0b0011 & 0b0010 => 0b0010
0b0011 | 0b0010 => 0b0011
0b0011 ^ 0b0010 => 0b0001
~0b0011 => 0b1100
~~~

  - xor 연산자로 두수 바꾸기

~~~c#
static void Main(string[] args)
{
    int a = 3;
    int b = 8;

    a = a ^ b;
    b = b ^ a;
    a = a ^ b;

    Console.WriteLine($"a : {a}, b : {b}");
}

출력
a : 8, b : 3
~~~

###### [컴퓨터 기본수학](#컴퓨터-기본수학)
###### [Top](#top)

<br/>
<br/>

# 운영체제
  - [32비트와 64비트](#32비트와-64비트)
  - [기억 장치의 종류](#기억-장치의-종류)
  - [HDD의 논리적 구조와 SSD](#hdd의-논리적-구조와-ssd)
  - [API, Kernel, System Call, Interrupt](#api-kernel-system-call-interrupt)
  - [DMA(Direct Memory Access)](#dmadirect-memory-access)
  - [CPU와GPU](#cpu와gpu)
  - [Virtual Memory](#virtual-memory)
  - [Process와 Thread](#process와-thread)
  - [Process간 통신 IPC, SOKET, MESSAGE PASSING](#process간-통신-ipc-soket-message-passing)
  - [메모리관리](#메모리관리)
  - [동기/비동기](#동기/비동기)

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# 32비트와 64비트
  - CPU가 처리하는 데이터의 최소 단위인 레지스터의 크기가 몇 바이트 인지 나타내는것
  - 데이터를 처리할때 CPU에서 처리하게 되는데, 매번 데이터를 가져오면 시간이 걸리니 저장하게 된다
  - 레지스터의 용량이 클 수록 메모리에서 더 많은 데이터를 가져와 저장하기 때문에 속도가 빨라진다
  - 32비트 = 2의 32승 = 4,294,967,296개의 숫자를 표현 가능하며, 4,294,967,296개의 메모리 주소를 저장할 수 있다(메모리 주소는 1바이트 단위 이므로 4,294,967,296바이트 메모리 주소를 저장 가능)(4,294,967,296바이트 = 4GB)

  8bit = 1Byte

  1024Byte = 1MB

  1024MB = 1KB

  1025KB = 1GB

  - 32비트 레지스터는 램에서 한번에 표현할 수 있는 메모리가 4GB가 된다(하지만 실제 레지스터는 작동중에, 일부가 메모리 주소 외에 다른 임시 값을 저장하는데 사용되기 때문에 실제 한계는 더 적어진다)
  - 64비트 레지스터는 32비트 레지스터보다 엄청나게 더 많은 메모리 주소를 저장 가능하지만, 현재는 64비트 전체를 다 쓰지는 않는 다고 한다.

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# 기억 장치의 종류

![image](https://user-images.githubusercontent.com/39178978/214212250-33440444-d5f1-4cf2-8c14-ea3581ca4a36.png)

  - 출처 : https://www.youtube.com/watch?v=LMwVUzJQSdU&list=PLXvgR_grOs1BQCziQ_MpM877BdBxwbMzA&index=8 

<br/>

  - Cache memory : CPU에서 연산을 하기 위해서 데이터들을 Register까지 불러와야 하는데, Register와 RAM간의 속도 차이 때문에 중간에 있는 Cache memory가 그 간극을 메꿔주게 된다.

  - 기억공간의 관리
    - 레지스터 : 개별 기억공간마다 고유 이름을 붙인다
    - 주 기억장치(RAM) : 일련번호를 붙인다
    - 보조기억장치 : 트랙과 섹터 번호를 붙여 관리한다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# HDD의 논리적 구조와 SSD

![image](https://user-images.githubusercontent.com/39178978/214212383-6363c427-92e5-4c0b-bc83-8c934572a939.png)

  - 포맷 : HDD는 데이터를 트랙과 섹터로 나누어 관리하고 있는데, 그러한 트랙과 섹터를 집어 넣는 작업을 포맷이라고 하며, 그렇기 때문에 저장되어진 정보는 전부 지워지게 된다
  - 조각모음 : HDD에 데이터가 저장될때, 연속적으로 저장되어지지 않았을때, 그러한 정보들을 연속적으로 배치하기 위한 작업(연속적으로 되어 있지 않다면 데이터를 사용하는 데 있어서 시간이 더 걸린다)
  - 파일복구 : 파일을 완전히 지웠다고 해도, HDD상에서는, 덮어 쓸 수 있는 상태의 위치가 될뿐, 아직 그곳에 데이터를 덮어 쓰지 않았다면 그것을 찾아가서 파일을 복구 하는것
  - HDD와 SSD의 차이
    - 하드디스크는 내부에 있는 디스크가 돌면서 원시적으로 읽어내기 때문에, 물리적인 속도의 한계가 있지만 SSD는 플래시 메모리를 이용하여 논리적인 구조로 이루어져 있기 때문에 속도가 굉장히 빠르다
    - SSD가 충격에 훨씬 안전하다
    - SSD가 훨씬 가볍다
    - SSD는 배드블록이 발생한다(수명이 존재 하며, 하나의 블록에 쓰고, 지웠다를 반복하면 그 블록을 쓸 수 없게 된다)

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# API, Kernel, System Call, Interrupt
  - 컴퓨터는 3가지의 구조로 나눌 수 있다
    - 피지컬
      - H/W(하드웨어 영역)
    - 로지컬(= Virtual)
      - Kernel(운영체제 영역)
      - User(유저 영역)
  - 운영체제는 커널 영역에서 유저 레벨을 도와주고, 하드웨어 영역을 관리한다
  - 메모리나, 장치에 접근하기 위해서는 User모드가 아닌 Kernel모드가 되었을때 접근이 가능하며, Kernel모드로 모드변경을 하기 위해서는 OS의 System Call을 호출하여 변경해야 한다
  - Interrupt
    - 컴퓨터는 다른 주변기기와 통신(입출력)을 할때 Interrupt가 발생한다
      - 컴퓨터 기기들은 저마다의 고유한  Interrupt를 가지고 있어서 컴퓨터가 처리해주어야 할 일이 자신에게 발생했을때 운영체제에게 IRQ(Interrupt Request)를 보내어 컴퓨터를 사용하게 된다. 
      - blocking IO
        - Interrupt가 발생하면 프로세스가 잠시 멈췄다가, Interrupt가 끝나면 다시 진행한다
      - non-blocking IO
        - Interrupt가 발생해도 프로세스가 멈추지 않는다.
    - I/O과정은 기본적으로 이렇게 되기 때문에, 커널모드에 함수가 실행되는 것과,  인터럽트 발생 때문에 속도가 잘 나오지 않는다.
      - 1. 유저모드에서 함수 실행
      - 2. 커널모드에서 함수 실행
      - 3. RAM 메모리에 올라감
      - 4. 비디오 하드웨어 에게 전송(인터럽트)
      - 5. 모니터에게 전송(인터럽트)
    - 주변기기를 고성능을 사면, 비동기가 되기 때문에 속도가 빨라진다
    - DirectX : 유저 레벨에서 커널 쪽 단계를 스킵하고, 유저 레벨에서 비디오 드라이버에 바로 액세스할 수 있도록 한 기술. 이를 통해 고성능 게임을 구동하는 것

<br/>

![image](https://user-images.githubusercontent.com/39178978/214212779-5289a666-8670-46e4-bb7c-6c8708db52ea.png)

<br/>

  - System Call / Library Call 
    - System Call은 결국, 어디선가가, 하드웨어와 메모리에 접근하기 위해서 커널 함수를 실행한다고 생각하면 되지 않을까?
    - stdio.h와 같은 헤더 안에 System Call과 Library Call이 있으며, System Call은 OS의 Kernel에 서비스를 요청할 때에 호출하는 함수를 말한다.
    - Library Call도 결국은 System Call을 wrapping한 것이기 때문에, 결국 System Call을 호출하게 된다.
    - System Call을 너무많이 호출하면 시스템 성능에 영향을 주기 때문에, Library Call은 System Call을 적게 호출하면서, 개발을 쉽게 할 수 있도록 기능을 효과적으로 제공해준다
  - System Call 호출 과정
    - ex) stdio.h 헤더 안에 있는 printf를 사용했을시, 내부적으로 System Call을 출력할 수 있는 부분이 있으며, 그로 인해 어떤 System Call을 출력할지 컴파일러가 number을 세팅하게 됨 -> printf는 내부적으로 write을 사용하게 되고 이것은 sys_write System Call을 사용함 -> write가 call number 7번이다 라고 컴파일러가 결정하는것
    - 커널과 컴파일러와 서로 합의된 규칙하에 적용이 된다. 즉, 사용할 커널 함수 number는 컴파일러를 쓰는 회사가 결정하는 것이며, 그 컴파일러를 쓰는 회사와 커널과의 호환이 되어야 한다. 따라서 OS가 다르면 System Call 번호에 해당하는 함수들이 다르기 때문에 컴파일러는 OS별로 다르게 해석해주어야 한다.
  - API
    - stdio.h
      - C언어에서 사용하는 표준 입출력 API함수
      - 내부적으로 OS의 System Call을 이용하여 Kernel의 도움을 받아서 장치를 사용하게 된다(ex. printf는 내부적으로 System Call을 호출하여 terminal에 출력한다)
    - Win32API
      - 윈도우 운영체제에서 사용하는 C언어 기반의 API(C++에서도 사용 가능). 윈도우에서 실행되는 모든 종류의 어플리케이션은 내부적으로 WinAPI함수를 호출 하는 형태가 된다
      - windows.h인클루드 하여 사용
        - 다양한 함수와, 모든 데이터 타입, 윈도우 API의 함수들을 사용하기 위한 정의 들이 들어 있다(C 및 C++헤더 파일)
        - win32프로그램에는 인클루드가 되어 있음
        - mfc에는 내부적으로 다른 방법으로 인클루드가 되어 있음
      - 윈도우 운영체제를 설치 할때, 안에 내장되어 있는 함수들이라고 보면 되고, 그 함수들이 있기에, 장치 독립적으로 같은 함수를 호출함으로써 같은 기능을 쓸 수 있게 된다.
      - WinAPI가 없던 때에는, 장치를 사용할때, 각각의 장치에 대한 제어 코드를 하나하나 만지면서, 장치마다 설명서를 보고 해야 했지만, 지금은 제어 코드를 디바이스 드라이버가 가져가게 되었고, 윈도우가 제공해 주는 api함수를 사용함으로써 쉽게 장치 기능을 쓸 수 있게 됐다.
      - 정적 라이브러리 형태가 아닌 DLL(동적 라이브러리)형태로 제공되기 때문에, 윈도우 버전이 올라가면서, 윈도우 DLL이 개선되면, 프로그램 기능도 개선되기도 하지만, 호환성에 문제가 생기기도 한다
      - 윈도우에서 System Call 라이브러리는 ntdll.dll이고, Win32API도 내부적으로 ntdll.dll함수를 호출한다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# DMA(Direct Memory Access)
  - CPU와 Device장치의 통신
    - 1. CPU에서 RAM메모리의 일정 부분을 할당에 데이터 복사
    - 2. RAM내부에서 RAM내부로 데이터 복사
    - 3. RAM에서 Device로 데이터를 보낼때 Device RAM으로 데이터 복사
    - Process 가 데이터를 송신할 때
      - 1. File (Socket) 에 send (write)
      - 2. 소켓에 딸려있는 I/O Buffer에 차곡차곡 복사됨
      - 3. 커널 영역의 TCP/IP 레이어에 내려오면서 Segmentation 발생
      - 4. 커널의 버퍼들에 데이터가 복사됨
      - 5. 커널의 드라이버를 통해 NIC에 전달
        - 5-1 만약 NIC에도 RAM이 있다면 이곳에 한번더 들어가 복사되어 이동된다
      - 6. 외부로 이동
      - 그런데 프로세스 영역의 메모리와, 소켓의 메모리와, 커널의 메모리와는 모두 RAM 의 어딘가 이기 때문에 비효율적이다.
    - 이러한 과정이 굉장히 비효율적이기 때문에 DMA가 등장
  - DMA : CPU 에서 일정 유저 RAM영역을 OS가 Lock을 걸고  다이렉트로 Device RAM 영역에 데이터를 복사시키거나, 데이터를 Device RAM 으로 부터 받는다
    - 윈도우의 IOCP가 이러한 원리를 활용한 것이다
  - 가상환경(VM) : 기존 유저 영역을 유저/커널 영역으로 간주하고, 커널 영역을 H/W 로 간주하는 Guest OS 를 만드는 것
    - 두 VM이 데이터를 주고받을 때 (실제론 커널 영역에 있는) NIC 두 개를 통해서 양쪽 유저 영역이 데이터를 주고 받는게 아니라, "했다 치고" 실제론 메모리 영역에 데이터를 copy 해버린다. 이렇게 해서 성능을 끌어올릴 수 있다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# CPU와GPU
  - CPU의 코어는 그렇게 많지 않지만, 복잡한 고차원적인 연산이 가능하다
  - GPU의 코어는 몇천개 단위로 많고, 단순한 반복작업을 하는데에 최적화되어 있다
    - 그래픽의 벡터 연산 : 3D그래픽은 많은 폴리곤으로 이루어져 있으며, 폴리곤이 세밀할수록 표면을 보다 매끄럽게 표현할 수 있으며, 폴리곤이 세밀할수록 연산해야 되는 좌표가 많아진다 그렇기 때문에 그래픽 작업은 기본적으로 단순한 ‘좌표 계산’이라고 표현된다
    - 딥러닝, 머신러닝, 빅데이터 : 수천만 개의 학습 데이터를 이용해 연산을 수없이 반복하여 데이터로부터 특징을 추출, 즉 매우 반복적인 알고리즘 계산

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# Virtual Memory
  - 1차 메모리(RAM), 2차 메모리(HDD의 Swap영역)를 합쳐서 하나의 연속된 메모리로 추상화 한것
    - OS는 Virtual Memory를 Process에게 할당한다
    - User어플리케이션은 그냥 RAM을 쓴다고 하지만 그것은 가상 메모리가 될것이고, 그것은 1차,2차 메모리를 합쳐서 연속된 메모리를 추상화한것을 사용하게 된다
  - 32bit기준 으로 설명하는 Virtual Memory
    - 한 Process의 Virtual Memory안에서 User, kernel에서 사용하는 메모리로 나누어서 쓰게 된다. User에서 앞부분은 OS가 차지 하게 되기 때문에 그 영역은 사용하지 못하게 된다
  - 관리
    - User모드에서 Process의 Virtual Memory를 관리하는 단위는 Page가 된다
    - H/W에서 물리 Memory를 관리하는 단위는 Segment가 된다
    - 매핑 테이블을 통해 각 Process가 사용하고 있는 Page나 Segment의 위치를 매핑 하고 있다.
      - 보통, 가상 주의의 단위인 Page와 물리 주소의 단위인 Segment의 길이를 똑같이 맞추고, 테이블을 통해서 매핑 하여 관리하게 된다
      - Process가 오작동 해서, 종료가 됐을 때 매핑 테이블을 확인해서 그 메모리를 사용하지 않고 있다고만해서 메모리를 깔끔하게 다 수거할 수 있다.
      - 관리적인 의미로 아주 뛰어나게 된다.
      - OS가 접근 권한(rwx)을 확인 할때 테이블을 확인하고, 그것이 읽기만 되는지 쓰기만 되는지, 실행만 되는지 확인해서 작업을 하게 된다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# Process와 Thread
  - 한 Process는 최소 1개 이상의 Thread를 갖는다
  - Thread는 개별화된 흐름과 전용 스택을 갖는 실행의 단위
    - 스택은 보통 1MB정도의 크기이고, 재귀함수를 만들때 일반적으로 저 크기를 넘어가면 오버플로우를 내밷는다
  - 모든 Thread는 자신이 속한 Process의 가상 메모리 공간을 공유한다
  - Thread생성시 가장 중요한것은 동기화 하는 것이다
    - 동기화를 잘 하지 못하면 레이스컨디션이 발생한다(=두 개 이상의 프로세스 혹은 스레드가 공유 자원을 서로 사용하려고 경합(Race)하는 현상)
  - Process에 속한 모든 Thread는 Process의 Virtual Memory로 메모리 공간이 제약 된다

  - PCB(Process Control Block), TCB(Thread Control Block)
    - PCB
      - OS의 스케줄러가 스케줄링 해줌
      - OS의 스케줄러에 의해 Context Switching되는 프로세스의 정보 단위
      - CPU의 Core몇개로 몇천개가 되는 Process를 돌리는데, 그것을 시분할 사용하고 있지만, 너무 빠르게 하고 있기 때문에 사람의 눈에는 동시 실행 되는 것처럼 보인다
      - 어떤 Process가 타임 아웃이 되었을때 그 상태를 PCB에 저장해 두었다가 디스패치가 되면 이어서 작업하게 된다
    - TCB
      - 프로세스에 있는 Thread라이브러리에 의해 스케줄링 됨
      - Thread라이브러리에의해 Context Switching되는 Thread의 정보 단위
  - Thread 는 Queue구조에서 무언가를 퍼와서 작업하게 된다!!

개발 툴 추천 : MS사의 프로세스 탐색기(https://learn.microsoft.com/ko-kr/sysinternals/downloads/process-explorer)


###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# Process간 통신 IPC, SOKET, MESSAGE PASSING
  - 프로세스 끼리 통신하는 것은 IPC(공유메모리), SOKET, MESSAGE PASSING이렇게 3가지가 있다
    - 공유메모리는, 시스템 호출을 통해서 메모리를 할당하기 때문에, 컴퓨터를 끄거나, 할당을 직접 해제 하지 않는이상 프로그램의 종료에 의해서 없어지지 않는다. 속도가 빠르며, 다량의 데이터를 교환할때 유리하다
    - MESSAGE PASSING은 속도가 매우 느리며, 적은 양의 데이터를 전달할때 사용한다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# 메모리관리
  - 많은 프로세스가 RAM을 사용하려고 하지만, RAM은 제한적 이기 때문에, CPU가 판단하여 연산이 많이 필요 없는 Process를 Page단위로 하여 2차 메모리로 보내거나 하는 식으로 관리하게 된다
    - Swap In : HDD -> RAM
    - Swap Out : RAM -> HDD

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# 동기/비동기
  - 동기, 비동기는 User mode어플리케이션 입장에서 일어난다
  - 동기
    - 프로세스가 OS에게 뭔가를 해주라는 요청을 보낸다. 그것이 Kernel영역으로 가서 OS가 작업을 하면 프로세스가 던지 함수를 리턴해 주기 때문에 프로세스는 현재 쓰레드가 거기서 기다리게 된다
  - 비동기
    - 프로세스가 OS에게 뭔가를 해주라는 요청을 보낸다. 그것이 Kernel영역으로 가서 Kernel영역에 있는 큐에 할일을 메모리에 복사해두고, 함수가 리턴된다. OS는 그것이 차례대로 처리되고, 완료가 되면, 콜백함수를 호출하거나, 이벤트를 보내거나 하게 된다.

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# Garbage Collection(GC), Automatic Reference Counting(ARC)
  - Heap 영역에서 동적으로 할당했던 메모리 중 필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거하는 프로세스
<br/>

  - Garbage Collection(GC)
    - 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들다
    - 가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 오버헤드가 발생
    - Stack메모리를 전부 확인하면서, 어떤 데이터가 힙메모리를 참조하고 있는지 전부 확인한 후에, 참조되고 있지 않은 힙메모리를 전부 제거한다
    - 순환참조까지 전부 해결할 수 있다
    
<br/>

  - Automatic Reference Counting(ARC)
    - 언제 메모리에서 해제되는지 컴파일과 동시에 결정할 수 있다
    - ARC 는 클래스 인스턴스가 참조될 때(강한 참조 시) 레퍼런스 카운트를 증가시킨다, 그 이후 레퍼런스가 0이 되는 구간에 메모리 해제 코드를 컴파일러가 집어 넣는다. 즉, 컴파일시에 결정이 된다.
    - 두 객체가 서로를 참조하여, 참조순환이 발생되면 메모리가 해제 되지 않는다는 단점이 있다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

# 스택, 힙, 코드, 데이터영역
  - OS에서 프로세스가 바라보는 메모리 영역은 크게 코드(Code), 데이터(Data), 힙(Heap), 스택(stack) 영역으로 나뉘어진다. 
  - Code 영역
    - 실행할 코드와 매크로 상수가 기계어의 형태로 저장
    - 컴파일 타임에 결정
    - 중간에 코드를 바꿀 수 없게 Read-Only 로 지정
    - CPU는 코드 영역에 저장된 명령을 하나씩 가져가서 처리한다
  - Data 영역
    - 전역 변수와 정적(static) 변수가 저장되는 영역
    - 전역변수/static 값을 참조한 코드는 컴파일 하고 나면 Data 영역의 주소값을 가르키도록 변경됨
    - Read-Write로 지정
  - Stack 영역 
    - 지역변수, 매개변수, 리턴값, 돌아올 주소 등등이 저장되고 함수 호출시 기록하고 종료되면 제거
    - 후위선출(LIFO) 방식
    - 컴파일 타임에 크기가 결정
    - 재귀함수가 너무 깊게 호출되거나 함수가 지역변수를 너무 많이 가지고 있어 stack 영역을 초과하면 stack overflow 에러가 발생
  - Heap 영역
    - malloc() 또는 new 연산자를 통해 메모리를 할당
    - Heap은 런타임에 결정
    - 스택보다 할당할 수 있는 메모리 공간이 많다
    - 메모리 영역을 접근해야 하기 때문에 다른 자료구조에 비해서 데이터를 읽고 쓰는게 느리다

###### [운영체제](#운영체제)
###### [Top](#top)

<br/>
<br/>

***

# Window시스템기초
  - [보안DACL](#보안dacl)
  - [Process, Thread, _beginthreadex, 동기화](#process-thread-_beginthreadex-동기화)
  - [Context Switch](#context-switch)
  - [Sleep()](#sleep)
  - [Windows시스템 메모리 운용 방법](#windows시스템-메모리-운용-방법)
  - [Window 프로세스 기본 힙할당](#window-프로세스-기본-힙할당)
  - [보호모드](#보호모드)

###### [Window시스템기초](#window시스템기초)
###### [Top](#top)

<br/>
<br/>

# 보안DACL
  - ID : 식별자
  - Handle : 제어
  - 보안수준
    - SYSTEM > Admin > User

<br/>

  - DACL(DiscretionaryAccessControlList) : 보안 객체에 대한 접근 허용/차단 정보를 가진 데이터 구조
    - 대표적인 보안객체
      - 파일과 폴더
      - 프로세스와 스레드
      - 파일 매핑 객체
      - 파이프
      - 토큰
      - 윈도우 스테이션 및 데스크톱
    - ACL의 리스트이다
    - ACL(AccessControlList)은 ACE의 리스트 이다
    - ACE(AccessControlEntry)
      - 윈도우 시스템에서 접근제어를 위한 기본 정보
      - 권한에 따라 접근을 제한다는 것은 ACE를 수정 편집한다는 의미
      - ACE의 핵심 정보는 SID(SecurityIDentifier)이며 사용자나 그룹을 식별한다
  - SACL(SystemAccessControlList)
    - (파일 같은)보안 객체에 대한 접근 로그를 남기를 근거 정보
    - Write권한이 없는 사용자의 쓰기 시도발생 시 로그 저장(감사 자료)
  - 프로세스 수준 접근 통제
    - 보안 객체 접근 시 대상 객체와 접근주체(즉, Process)에 대한 권한 비교
    - 객체에 대한 DACL과 프로세스가 가진 Access token을 비교한 것(token안에 SID가 들어 있다)
    - 가진 권한과 허용된 접근에 따라 OS가 통제
    - 로그인을 하면 OS가 그 계정에 권한을 부여해 주는데, 프로세스나 스레드를 만들때 보안 객체를 상속 받는다는 의미가 이러한 접근 부분이다
  - Access token
    - 구조체
    - 프로세스나 스레드가 갖는 보안 수준에 대한 정보와 의미를 포괄
    - 사용자 계정 특권
    - 대표적으로 SID정보
    - CreateProcess함수를 통해서 Process를 생성하고, 보안 객체를 상속받던지, 따로 주던지 하는 과정을 거치게 된다

###### [Window시스템기초](#window시스템기초)
###### [Top](#top)

<br/>
<br/>

# Process, Thread, _beginthreadex, 동기화
  - 스레드 생성
    - 한 Process는 최소 1개이상의 Thread를 갖는다(메인 스레드)
    - Thread는 개별화된 흐름과 전용 스택(기본적으로 컴파일 할때 1MB를 할당받는다)을 갖는 실행의단위이다
    - 모든 Thread는 자신이 속한 Process의 가상 메모리 공간을 공유한다
    - 개별 ID와 핸들을 가진다
  - 스레드 속성
    - ID와 핸들
    - 우선순위(Highest, Above normal) : CPU의 연산 자원을 어떤 스레드가 우선적으로 가져가는가
    - 상태(Run, Suspended, Terminated)
    - 친화력 : 현재 스레드는 코어 몇번 몇번을 사용해서 연산을 할것인지?
  - _beginthreadex
    - CreateThread와 사용법이 완전히 같다
    - 윈도우에서는 CreateThread보다, _beginthreadex함수를 사용해서 쓰레드를 생성하자
    - C-Runtime library가 제공하는 함수 중 정적변수 혹은 전역변수를 사용하는 함수를 멀티스레드 환경에서 문제를 야기한다, 내가 만든 함수가 아니라, 제공되는 함수이고, 그 함수안에서 멀티 스레드로 동시에 돌아가면 문제가 야기될 수 있다는것.  TLS를 적용해서 해결해야 한다
    - strtok 같은것
    - 하지만 _beginthreadex으로 돌아가는 스레드는 TLS가 적용되어 있기 때문에 신경쓰지 않아도 된다

<br/>

  - 스레드(Thread) 동기화
    - 임계구간 코드가 여러 스레드에서 동시에 실행되는 일을 막는 것
      - 임계구간은 보통Critical section으로 구현한다
    - 연산 시점감지(스레드 종료전, 중간에 시점을 알리고 싶을때)
      - 연산 시점감지는 보통 Mutex, Semaphore, Event 로 구현한다
      - Event 를 대부분 쓴다고 보면 된다
    - 동기화 객체를 이용해 구현
      - Critical section : 스레드 동기화 하는데에만 사용가능(비용 낮음)
      - Mutex, Semaphore
      - Event(Set/Reset 상태)
    - WaitForSingleObject
      - 어떤 핸들에 Set되는 시점을 확인한다
    - 임계영역 기반 동기화
      - 어떤 하나의 데이터에 동시에 두개의 스레드(Thread)가 접근하여 데이터를 쓸때 임계영역을 설정해서, 하나의 스레드(Thread)만 들어가도록 해야 한다
      - 임계 영역을 넓게 잡게 되면, 비효율이 발생한다.
    - 스레드 친화력 조절
      - SetThreadAffinityMask라는 함수로 조절한다

<br/>

  - 세마포어(Semaphore)
    - Kernel오브젝트 이며, 비싼 자원이다(Critical section은 Kernel오브젝트가 아니다)
    - Critical section과 다른점은 임계 영역 지점에 1개가 아닌 n개가 접근해야 할때 Semaphore를 사용한다
    - 특정 영역(실행 코드 구간)에 대해 2개이상 n개 이하 스레드가 동시 접근 할 수 있도록 제어
    - 서버 개발 시 안정적인 서비스가 이루어지도록 동시처리 사용자 세션 개수를 제한할때 많이 사용

<br/>

#Critical section,_beginthreadex사용예제
#MFC
#AppDlg.h
~~~c++
public:
	char* g_pszBuffer;
	CRITICAL_SECTION g_cs;
	static UINT WINAPI ThreadFunc1(LPVOID lpParam);
	static UINT WINAPI ThreadFunc2(LPVOID lpParam);
	void SetString(const char* pszData);
	BOOL GetString(char* pszData);
~~~

<br/>

#AppDlg.cpp
~~~c++
BOOL CMFCApplication1Dlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	g_pszBuffer = NULL;

	// Critical section생성
	::InitializeCriticalSection(&g_cs);

	UINT dwThreadId = 0;
	HANDLE hThread = (HANDLE)::_beginthreadex(
		NULL, 
		0, 
		ThreadFunc1, 
		this,
		0, 
		&dwThreadId);

	if (hThread == NULL) {
		AfxMessageBox(_T("Thread 생성 실패"));
		return FALSE;
	}

	::CloseHandle(hThread);

	hThread = (HANDLE)::_beginthreadex(
		NULL,
		0,
		ThreadFunc2,
		this,
		0,
		&dwThreadId);

	if (hThread == NULL) {
		AfxMessageBox(_T("Thread 생성 실패"));
		return FALSE;
	}

	char szBuffer[64] = { 0, };
	for (int i = 0; i < 5; i++)
	{
		::Sleep(500);
		GetString(szBuffer);
		OutputDebugStringA(szBuffer);
	}

	::WaitForSingleObject(hThread, INFINITE);
	::CloseHandle(hThread);

	// Critical section반납
	::DeleteCriticalSection(&g_cs);

	return TRUE;  // 포커스를 컨트롤에 설정하지 않으면 TRUE를 반환합니다.
}

. . . 

UINT CMFCApplication1Dlg::ThreadFunc1(LPVOID lpParam)
{
	CMFCApplication1Dlg* pDlg = static_cast<CMFCApplication1Dlg*>(lpParam);

	while (TRUE)
	{
		::Sleep(1);
		pDlg->SetString("ThreadFunc1\n");
	}
	return 0;
}

UINT CMFCApplication1Dlg::ThreadFunc2(LPVOID lpParam)
{
	CMFCApplication1Dlg* pDlg = static_cast<CMFCApplication1Dlg*>(lpParam);

	while (TRUE)
	{
		::Sleep(1);
		pDlg->SetString("ThreadFunc2\n");
	}
	return 0;
}

void CMFCApplication1Dlg::SetString(const char* pszData)
{
	::EnterCriticalSection(&g_cs);
	if (g_pszBuffer != NULL)
	{
		free(g_pszBuffer);
		g_pszBuffer = (char*)malloc(64);
		sprintf_s(g_pszBuffer, 64, "%s", pszData);
	}
	else
	{
		g_pszBuffer = (char*)malloc(64);
		sprintf_s(g_pszBuffer, 64, "%s", pszData);
	}
	::LeaveCriticalSection(&g_cs);
}

BOOL CMFCApplication1Dlg::GetString(char* pszData)
{
	// 자식스레드가 하나라도 통과되어 있으면 부모 스레드는 여기서 대기하게 된다
	::EnterCriticalSection(&g_cs);
	if (g_pszBuffer != NULL)
	{
		sprintf_s(pszData, 64, "%s", g_pszBuffer);
		free(g_pszBuffer);
		g_pszBuffer = NULL;

		::LeaveCriticalSection(&g_cs);
		return TRUE;
	}

	::LeaveCriticalSection(&g_cs);
	return FALSE;
}
~~~

<br/>

#세마포어(Semaphore)예시
  - 함수 인자 두번째, 세번째에 임계지점에 몇개까지 접근할 수 있게 할지 결정 할 수 있다
#MFC
#AppDlg.h
~~~c++
public:
	static UINT ThreadSemaphore(LPVOID pParam);
~~~

<br/>

#AppDlg.cpp
~~~c++
// 디버그 콘솔을 출력하기 위한 설정
#pragma comment(linker, "/entry:WinMainCRTStartup /subsystem:console")

static HANDLE g_hSema;
static TCHAR g_StringList[10][64];

BOOL CMFCApplication1Dlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	g_StringList[10][64] = { 0, };

	g_hSema = ::CreateSemaphore(NULL, 3, 3, NULL);

	UINT nThreadId = 0;
	HANDLE hThread = NULL;

	for (int i = 0; i < 10; i++)
	{
		hThread = (HANDLE)::_beginthreadex(
			NULL,
			0,
			ThreadSemaphore,
			(LPVOID)i,
			0,
			&nThreadId);

		if (hThread == NULL) {
			AfxMessageBox(_T("Thread 생성 실패"));
			return FALSE;
		}
	}
	
	::CloseHandle(hThread);

	while (1)
	{
		system("cls");

		for (int i = 0; i < 10; i++)
		{
			_putws(g_StringList[i]);
			//OutputDebugString(g_StringList[i]);
		}

		::Sleep(1000);
	}

	return TRUE;  // 포커스를 컨트롤에 설정하지 않으면 TRUE를 반환합니다.
}

. . .

UINT CMFCApplication1Dlg::ThreadSemaphore(LPVOID lpParam)
{
	while (TRUE)
	{
		::wsprintf(g_StringList[(int)lpParam], _T("%d thread is waiting!\n"), (int)lpParam);
		::Sleep(500);

		DWORD dwWaitResult = ::WaitForSingleObject(g_hSema, INFINITE);
		::wsprintf(g_StringList[(int)lpParam], _T("%d running!!!!!!!!!!!!!!\n"), (int)lpParam);
		::Sleep(500);
		::ReleaseSemaphore(g_hSema, 1, NULL);
	}
	return 0;
}
~~~

<br/>

#스레드(Thread)친화력 조절 예제
#MFC
#AppDlg.h
~~~c++
public:
	static UINT ThreadFunction(LPVOID pParam);
~~~

<br/>

#AppDlg.cpp
~~~c++
BOOL CMFCApplication1Dlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();


	UINT nThreadId = 0;
	HANDLE hThread = NULL;

	hThread = (HANDLE)::_beginthreadex(
		NULL,
		0,
		ThreadFunction,
		NULL,
		0,
		&nThreadId);

	if (hThread == NULL) {
		AfxMessageBox(_T("Thread 생성 실패"));
		return FALSE;
	}

	for (int i = 0; i < 8; i++)
	{
		// 코어를 선택할때는 0000 0000 라는 비트 Mask를 사용한다
		// 0000 0001 : 1번 코어
		// 0000 0010 : 2번 코어
		// 0000 0100 : 3번 코어
		// 0000 1001 : 1번, 4번 코어 context switch
		::SetThreadAffinityMask(hThread, 0b00000001 << i);
		::Sleep(5000);
	}

	::CloseHandle(hThread);

	return TRUE;  // 포커스를 컨트롤에 설정하지 않으면 TRUE를 반환합니다.
}

UINT CMFCApplication1Dlg::ThreadFunction(LPVOID lpParam)
{
	int nTemp = 0;
	while (1)
	{
		++nTemp;
	}
	
	return 0;
}
~~~

<br/>

#WaitForSingleObject사용예제
  - WaitForSingleObject에 쓰레드(Thread)핸들을 넘겨주면 그 쓰레드(Thread)가 종료될때 반환하게 된다
#MFC
#AppDlg.h
~~~c++
public:
	static DWORD WINAPI ThreadFunction(LPVOID lpParam);
~~~

<br/>

#AppDlg.cpp
~~~c++
BOOL CMFCApplication1Dlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();


	DWORD dwThreadId = 0;
	HANDLE hThread = CreateThread(
		NULL, 
		0, 
		ThreadFunction, 
		(LPVOID)"PATAM",
		0, 
		&dwThreadId);
	if (hThread == NULL) {
		AfxMessageBox(_T("Thread 생성 실패"));
		return FALSE;
	}

	::WaitForSingleObject(hThread, INFINITE);
	::CloseHandle(hThread);

	OutputDebugString(_T("메인쓰레드 끝\n"));

	return TRUE;  // 포커스를 컨트롤에 설정하지 않으면 TRUE를 반환합니다.
}

. . .

DWORD WINAPI CMFCApplication1Dlg::ThreadFunction(LPVOID lpParam)
{
	OutputDebugString(_T("쓰레드 시작\n"));
	Sleep(1000);
	OutputDebugString(_T("쓰레드 끝\n"));
	return 0;
}
~~~


###### [Window시스템기초](#window시스템기초)
###### [Top](#top)

<br/>
<br/>

# Context Switch
  - 2개 이상의 Thread가 존재하고, 각각의 Thread가 CPU연산 자원을 할당 받아서 사용하게 될때, 현재 까지의 상태정보를 저장하고, 상태를 변환하는 과정을 왔다 갔다 하는것
  - Thread의 문맥정보를 백업하는 곳은 레지스터 이다
  - Context Switch는 문맥정보, 상태정보를 저장한 레지스터를 참조해서 복귀하게 되고, 이러한 과정에서 오버해드(overhead)가 발생하게 된다

###### [Window시스템기초](#window시스템기초)
###### [Top](#top)

<br/>
<br/>

# Sleep()
  - 스레드를 일정 시간 동안 Suspend시켰다가 시간이 지나면 자동으로 Resume되어 Run상태로 전환
  - 보통 설정한 시간 보다 더 많은 시간이 흐르며 정확성이 떨어짐
  - 우연에 맡기는 코드가 만들어짐
  - WaitForSingleObject에서의 대기하는 시간도 정확히 그 시간보다는 같지 않다
  - QueryPerformanceCounter라는 함수를 이용해서, 실제 프로그램 실행 시간을 측정 할 수 있다, 즉 Sleep을 했을때 실제 시간이 얼마나 흘렀는지 확인 할 수 있다
  - 정밀한 동기화에는 사용할 수 없다

###### [Window시스템기초](#window시스템기초)
###### [Top](#top)

<br/>
<br/>

# Windows시스템 메모리 운용 방법
  - 가상 메모리 시스템 직접 활용
    - 가상 메모리 : Process가 시작되면 OS는 그 Process에 VMS를 할당한다.
    - 32bit라면 4GB를 할당한다(2GB : USER, 2GB : Kernel)
      - USER에 stack, heap, static등 전부 들어간다
        - USER에서 첫번째 null과 기본적으로 사용하지 못하게 하는 부분들이 있기 때문에 실제적으로는 2GB보다 조금 작은 부분이된다
      - 실제적인 4GB를 할당하는것이 아니라 논리적으로 할당한다
      - Kernel의 2GB는 모든 어플리케이션에서 사실은 같은 곳을 가리키게 된다(즉 OS의 같은 영역을 가리킨다)
      - VMS는 전부 Page단위로 관리된다.
      - 어떤 VMS의 하나의 Page에 접근했을때 그것이 실제로는, RAM에 있을수도 있고 SSD,HDD의 하드 디스크 영역에 있을 수도 있다
      - Process는 각각 VMS를 할당받고, VMS의 같은 위치에도 실제적으로는 각각 다른 위치의 RAM,SSD,HDD를 가리키게 된다.
      - OS는 최대한 RAM영역을 사용하려 하지만 부족하면 SSD,HDD을 사용할수도 있으며, RAM->SSD,HDD : Page-out, RAM<-SSD,HDD : Page-in이 일어나기도 한다(이것을 스왑이 일어난다고 한다)
      - VMS장점
        - 특정 Process가 죽었을때 그 VMS에 할당된것을 전부 없애기 용이하다.
        - 입출력을 할때 각각의 VMS에서 하기 때문에 안전하다.
        - 특정 Process가 임의로 다른 Process의 VMS에 접근할 수 없도록 막는다
      - VMS단점
        - 관리 오버헤드가 발생한다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/b7962e10-9db5-4c9e-b19c-3da50e555a98)

  - 메모리 맵
  - 힙
    - 크기가 작은 데이터(4KB 이하) 할당 시 매우 유용
    - 할당 단위나 페이지 경계를 고려하지 않음

<br/>

  - 메모리는 페이지단위(Page)로써 4kb단위로 관리된다. 즉 메모장을 열어서 4kb미만의 데이터를 넣어서 저장하게 되면, 용량이 작은것은 그대로 이지만 관리적 측면에서 4kb만큼은 다른것을 사용할 수 없게 된다

<br/>

  - Windows환경 메모리 할당 함수
    - malloc(), new
      - C/C++에서 사용하며 프로세스 기본 Heap영역(1MB)사용
    - Local/GlobalAlloc()
      - Heap영역 내부에서 다시 Local, Global영역을 사용
      - Win16 호환성을 위해 존재하는 구형
      - Clipboard, OLE에서 여전히 사용 중
    - HeapAlloc()
      - 가상 메모리 공간 중 일부를 할당 받아 빠르게 사용
        - 데이터 크기가 1MB가 아니여도, malloc호출즉시 1MB를 이미 할당하기 때문에, 1MB미만을 Heap영역에 할당하고 다시 할당하면 처음에 1MB의 영역안에서 할당 되게 된다, 그래서 빠르다
      - malloc을 호출하면 내부적으로 호출하는 함수
    - VirtualAlloc()
      - 대용량 메모리(1MB이상) 사용시 활용
        - HeapAlloc() 함수가 내부적으로 호출

<br/>

  - Window 메모리 시스템
    - 모든 프로세스는 Private address space를 가진다(VMS)
    - 가상 주소 공간은 분할되어 있으며 이를 (메모리) 파티션 이라 한다
    - 가상 메모리 공간을 사용하기 위해서는 예약해야함
    - 대부분의 CPU는 보통 64KB단위(Allocation size)로 관리
      - 하드웨어 끼리는 64KB단위로 왔다 갔다 한다는것
    - 할당하는 메모리 영역의 시작 주소는 64KB로 나누어 떨어지는 위치 에서 시작
    - 예약된 메모리 공간을 사용하려면 반드시 실제 물리 메모리 영역을 매핑해야 하며 이를 ‘물리 메모리를 Commit한다’라고 표현함
      - Commit하지 않고 미리 할당받아 놓는 식으로 빠르게 나중에 Commit하여 사용할 수 있다
    - Commit된 물리 메모리를 사용할 필요가 없다면 Decommit하여 해제
      - Decommit하게 되면, 실제 메모리와 연결이 끊어지고 예약만 되어 있는 공간으로 남게 된다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/d8e840c4-a5a3-428b-8d04-9623515a570d)


###### [Window시스템기초](#window시스템기초)
###### [Top](#top)

<br/>
<br/>

# Window 프로세스 기본 힙할당
  - 프로세스 실행 시 OS는 프로세스 주소 공간에 기본 힙을 생성(1MB)
  - 여러 스레드가 동시에 메모리 할당/해제시 기본 힙의 처리 대기열을 활용해 요청을 순차 처리(동기화가 되어 있다는것)
    - 여러 스레드가 동시에 malloc을 호출해도 Queue의 대기열에 들어가서 순차적으로 할당된다는 뜻
  - 한 프로세스에 여러 힙을 만들 수 있음
  - 1MB -> 1024KB이고, 이것을 Page로 관리하게 됨, 비어 있는 힙 공간을 채우는 식으로 할당됨, 할당된 공간을 Block혹은 Chunk라고 불린다
  - API
    - GetProcessHeap
      - 프로새스스가 생성될때 만들어지는 기본힙을 가져옴
    - HeapCreate/Destroy
    - HeapAlloc/Free
    - HeapReAlloc
    - HeapSize

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/8c86b585-828d-4ff0-afcf-69b25d1e3eb5)

###### [Window시스템기초](#window시스템기초)
###### [Top](#top)

<br/>
<br/>

# 보호모드
  - USER쪽 메모리에서 static은 R만 되는 부분, RW만 되는 부분으로 나누어진다
    - Page단위에는 + R, RW라는 부분도 같이 포함되게 된다
    - 문자열 상수 같은 경우는 Static에 R모드로 들어가게 된다
  - 메모리를 예약하는 행위, COMMIT하는 행위, 내 Process, 남의 Process의 Page의 보호모드(R, RW)를 바꾸기 위해서는 VirtualAlloc, VirtualAllocEx를 사용해야 한다
  - 실행코드, 즉 기계어또한 쓰기(W) 할 수 있게 바꿔서 다른 코드를 집어 넣을 수 있다
  - 함수에 Ex가 들어가면 첫번째 매개 변수에 HANDLE이 들어가게 되고 남의 Process에도 사용할 수 있다
  - VirtualAlloc : 메모리 할당
    - 3번째 인자 : 예약인지, COMMIT인지 조절
    - 4번째 인자 : RWX조절
  - Stack, heap등 데이터 영역은 보안모드에서 실행(X)이 되면 안된다
    - DEP라는 것이 OS수준에서 데이터 영역이  실행(X)되지 못하게 막는다
  - 실행코드인 기계어와 같은 곳에서는 R-X만 가능하게 된다
  - VirtualProtect : 할당된 메모리에 RWX를 바꿔준다
  - VirtualQuery : 가능/불가능한 페이지를 구분할 수 있다
  - VirtualLock/Unlock
    - 가상 메모리 상에서 어떤 공간을 Lock을 건다, 이 메모리에 대해서 Lock이 걸려 있는 동안 다른 Process가 접근하거나, 다른곳에서 사용하는 것이 불가능해 진다

<br/>

#MFC
#AppDlg.cpp
~~~c++
BOOL CMFCApplication2Dlg::OnInitDialog()
{
	CDialogEx::OnInitDialog();

	const char* pszHello = "Hello World!\n";
	OutputDebugStringA(pszHello);

	DWORD dwOldProtect = 0;
	::VirtualProtect((LPVOID)pszHello, 16, PAGE_READWRITE, &dwOldProtect);

	strcpy_s((char*)pszHello, 16, "qweqweqweqwe\n");
	OutputDebugStringA(pszHello);

	return TRUE;
}
~~~

###### [Window시스템기초](#window시스템기초)
###### [Top](#top)

<br/>
<br/>

***

# 암호기술
  - [Hash](#hash)
  - [대칭키(Symmetric key)](#대칭키symmetric-key)
  - [비대칭키 체계(SSL)](#비대칭키-체계ssl)

###### [암호기술](#암호기술)
###### [Top](#top)

<br/>
<br/>

# Hash
  - 단방향(함수) : 나온 결과 값으로 넣은 값을 알 수가 없다
  - 결과 : 입력과 상관 없이 길이가 일정
  - 대표적 알고리즘 : MD-5, SHA-1,128,256,354,512
  - Hash와 보안의 3대요소
    - 기밀성(C) : 암호기술
    - 무결성(I) : Hash
      - 보안의 3대 요소 중 무결성을 Hash로 구현한다
    - 가용성(A) : DR(재해대책) ex) 랜섬웨어
  - 해시 충돌 해결
    - chaining
      - 동일한 값이 Hash로 나오면, 해당 Bucket에 chaining 형태로 뒤로 데이터가 붙게 된다
    - open addresssing
      - 비어 있는 Bucket을 찾아 간다.(비어있는 Bucket을 찾아가는 알고리즘도 다양하다)
  - 블록체인
    - 분산저장 체계
    - 특정한 Block단위의 첫번째 Block을 Hash하고, 두번째 Block안에 첫번째 Block의 Hash를 넣는다. 따라서, 데이터를 임의로 수정하기 위해서는, 마지막 Block의 의존 되어 있던 맨위까지 전부다 수정을 해야 한다. Hash는 역으로 계산하는것이 거의 불가능 하기 때문에 그것을 전부다 수정하는 것은 불가능하다고 봐야 한다(동일한 블록체인을 동시에 여럿이서 소유하기 때문에 더욱 위변조가 어렵다)
    - 작업증명, 지분증명, 합의 알고리즘
      - 여러대의 컴퓨터가 블록체인 네트워크에 참여하게 될때, 새로운 여러 블록이 동시에 생성된다. 한국에서 A, 미국에서 B, 유럽에서 C, 이때 블록을 A-B-C, B-A-C, C-A-B 등등 어떤 블록체인을 골라야 할지 합의 해야 한다.(어떤 블록을 고를지 합의할 때 사용하는 것 : 합의 알고리즘)
        - 비트코인은 강제적인 비효율을 발생시켜 블록 생성 속도를 지연시키는 합의 알고리즘인 작업증명으로 이 문제를 해결했다
        - 블록체인 네트워크에는 단 하나의 블록체인만 존재해야 하기 때문에

###### [암호기술](#암호기술)
###### [Top](#top)

<br/>
<br/>

# 대칭키(Symmetric key)
  - XOR를 통해 암호화
  - 0100 0001 이란 데이터가 있을때(원문, 평문), KEY가 1011 1011 이라고 한다면 XOR를 통해서 1111 1010이란 값을 얻을 수 있다(암호문), 이러한 암호문을 다시  KEY에 XOR를 하면, 0100 0001 이란 원문이 나오게 된다
  - 클라이언트가 만드는 session key라고 생각해도 된다

###### [암호기술](#암호기술)
###### [Top](#top)

<br/>
<br/>

# 비대칭키 체계(SSL)
  - 암호화와 복호화를 하는 key가 다를때 비대칭키라고 한다
  - 대칭키를 인터넷상에서 사용할 수 없는 이유는, 특정 네트워크와 통신할때 암호화된 데이터를 보낸후, 그것을 풀기위한 대칭키도 보내야 하기 때문에, 암호화한 이유가 없어지기 때문. 그래서 비대칭키가 나오게 된다
  - 네이버와 통신 한다고 할때, 네이버는 암호화할 키만 전해주고, 복호화할 키는 본인이 가지고 있는다. 따라서, 상대방에 데이터를 보낼때는 네이버가 준 암호화키로 만들어서 보내주게 된다
암호화 키는 공개되어 있기 때문에 public이다, 복호화키는 private이다
  - 과정
    - 1. 키 쌍 생성
        - PC Public, PC Private, Server Public, Server Private
    - 2. 키 교환(IKE)
        - 각각 Public키를 교환 한다
          - Public키는 암호화 하는데에만 사용한다
    - 3. 각 서로 데이터를 보낼때는 서로가 보내준 Public키를 이용해서 암호화해서 보내주고, 서로가 데이터를 받을 때문 자신의 Public키로 암호화 한것을 받은것이기 때문에 자신이 가지고 있는 키 쌍인 Private키를 사용해서 복호화 한다
    - 1번의 키 쌍을 생성할때 전산 자원을 너무 사용하기 때문에 보통은 통신전에 미리 키쌍을 생성해서 hdd같은 곳에 저장해서 다회성으로 사용하게 된다
    - 효율성으로 보면 대칭키(AES-128) > 비대칭키(RSA 2048)
      - 그래서 대칭키를 많이 쓰려고 한다.
    - 과정(보통 아래와 같이 대칭키와, 비대칭키를 섞어 사용한다)
      - 1. Server의 키 쌍 생성
        - 통신 전에 Server Public, Server Private을 만든다, hdd와 같은 곳에 어딘가에 저장한다
      - 2. PC는 대칭 키(Symmetric key)를 생성한다(= 세선키, SSeionkey)
      - 3. 키 교환(IKE)
        - PC는 Server의 Server Public를 받는다
        - Server는 PC의 Symmetric key를 Server Public으로 암호화해서 받는다
      - 4. 데이터 교환은, PC에서 PC의 Symmetric key로 암호화 해서 보내고, Server에서도 PC의 Symmetric key로 복호화해서 사용한다
      - PC인 클라이언트에서 암호화 복호화할 키인 Symmetric key를 만들기 때문에 인터넷으로 넘어갈 곳에서 굉장히 안전하다. 왜냐하면 클라이언트 마다 다른 키를 사용하게 될 것이기 때문에

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/ce115a42-0dfa-4554-91a5-697e91cfc7ee)

  - 비대칭키 시스템 해킹
    - MITM공격을 성공한 해커는, PC와 Server의 중간에 껴 들어가서, Server의 Public키를 가로채서, 해커의 Public키를 PC로 보낸다. PC는 해커의 Public키로 암호화를 한후 전송하게 되고, 해커는 자신의 Private키를 이용해 그것을 복호화 해서 PC의 대칭키를 얻어 낸다. 해커는, Server다시 데이터를 보낼때, Server의 Public키를 사용해서 암호화 한후 보낸다(이렇게 하면 PC와 Server는 서로 데이터를 교환 한 줄만 안다)
    - 클라이언트 PC는 Server가 보내준 Public키를 어떻게 신뢰 할 수 있을지 확인해야 한다
    - 이것을 방지 하기 위해서 인증 기관이 등장한다
    - 과정
      - 1. 특정 기관에 CA와 제휴를 맺어서 CA의 Public키를 PC에 내장한다(certmgr.msc), 윈도우 업데이트 같은것을 할때 같이 키도 업데이트 하게 된다
      - 2. Server는 자체적으로 비대칭키를 만들지 않고, CA밑에 있는 RA에 요청한다.
      - 3. RA가 인증서를 만들어서 Server에 준다. RA의 private키도 같이 준다. 인증서안에는 RA의 Public키 및 많은 데이터가 들어가고, Hash도 들어가고, 암호화도 되어 있다. RA의 인증서는 CA의 Private키로 암호화 되어 있다
      - 4. Server는 클라이언트PC에 인증서를 전달한다. PC는 그것을 보고 더 쉽게 신뢰할 수 있고 검증할 수 있다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/09e7694b-78e1-4a20-b8e8-13ee26cf5faa)

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/8f6d659d-ddb9-4a4f-b5e1-b950a91390a1)

  - 정리
    - 1. 클라이언트가 웹 사이트에 접속 요청을 보내면
    - 2. 서버 측의 인증서를 클라이언트에게 전송한다.
    - 2-1. RA가 제공하는 인증서에는, 인증서의 내용을 종합해 해시화한 값을 암호호한 값이 들어있다. 그 암호화를 CA Private키로 하는것
    - 2-2. 만일 인증서를 내가 받았을때, 가지고 있는 CA Public키로 복호화된 해시 값과, 인증서에 들어있는 내용물을 다시 해시값으로 만들어 비교해 동일한 값이 아니라면 변조 되었음을 의미한다
      - 이과정을 통해, 신뢰할 수 있는 기관인지, 변조되지 않았는지 알 수 있다
    - 2-3. 이러한 신뢰할 수 있는 인증서 공개 키는 웹 브라우저에 등록이 되어 있다.
    - 3. 내 PC에 어떤 인증서가 날아 왔을때, 특정 CA의 Public키로 그것을 복호화에 성공하면, 서버 인증서에 내장되어 있는 Public키를 꺼내 사용하게 된다
    - 4. 클라이언트가 데이터를 보낼때 서버 Public키로 암호화 해서 데이터를 보내게 된다

###### [암호기술](#암호기술)
###### [Top](#top)

<br/>
<br/>

***

# Network기초
  - [컴퓨터구조, 네트워크 계층](#컴퓨터구조-네트워크-계층)
  - [Port, IP, MAC](#port-ip-mac)
  - [LAN, WAN](#lan-wan)
  - [Host, Switch, End-point, Network](#host-switch-end-point-network)
  - [IP주소 종류](#ip주소-종류)
  - [DNS](#dns)
  - [웹 서비스 구조](#웹-서비스-구조)
  - [GET, POST](#get-post)
  - [네트워크 데이터 단위](#네트워크-데이터-단위)
  - [패킷의 생성 원리](#패킷의-생성-원리)
  - [Router의 구조, Inline, Out of path](#router의-구조-inline-out-of-path)
  - [Proxy](#proxy)
  - [TCP/IP 송수신 원리](#tcpip-송수신-원리)
  - [소켓(Socket) 입/출력 버퍼](#소켓socket-입/출력-버퍼)
  - [L2스위치](#l2스위치)
  - [TCP/IP통신시 MAC주소 변화](#tcpip통신시-mac주소-변화)
  - [L2스위치 작동원리, ARP](#l2스위치-작동원리-arp)
  - [TTL](#ttl)
  - [3 way handshake, 4 way Handshaking](#3-way-handshake-4-way-Handshaking)
  - [MTU, Packet 단편화](#mtu-packet-단편화)
  - [Unicast, Broadcast, Multicast](#unicast-broadcast-multicast)
  - [서브넷팅](#서브넷팅)
  - [공유기 작동원리](#공유기-작동원리)
  - [부하분산(Load Balancer)](#부하분산load-balancer)
  - [VPN작동원리(L3, IPSec)](#vpn작동원리l3-ipsec)
  - [네트워크 보안 종류](#네트워크-보안-종류)

<br/>

Network기초 부분은 유투브에서 널널한 개발자 로 활동중이신, 최호성님의 강의를 보고. 많은 부분에서 정리와, 캡쳐한 내용임으로 출처를 밝힙니다!

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 컴퓨터구조, 네트워크 계층

  - 컴퓨터의 구조
    - 하드웨어
    - 소프트 웨어
      - 시스템 소프트웨어(Kernel)
      - 애플리케이션(User)

  - 네트워크의 계층적 구분
    - OSI 7 LAYER 와 DoD Four-Layer Model 의 2가지가 있다
      - OSI 7 LAYER 에서의 구분
        - 7 응용
        - 6 표현
        - 5 세션
        - 4 전송
        - 3 네트워크
        - 2 데이터링크
        - 1 물리계층
      - DoD Four-Layer Model 에서의 구분
        - 4 Application
        - 3 Transport
        - 2 Network
        - 1 Access

  - DoD Four-Layer Model 으로 설명하는 것이 조금더 간단하고, 아래 그림을 설명해 보면
    - Access 계층에 ‘네트워크 인터페이스 카드(Network Interface Card)’ 인 ‘NIC’이 있고 그 ‘NIC’인 하드웨어를 움직일 수 있는 Device Driver가 있으며, 그 위에 IP, TCP가 존재하고 맨 위에 Application인 Process가 있다.
    - 네트워크 에서, Application에서 kernel쪽으로 데이터를 보낼때 이것을 추상화하면 File의 형태로 추상화 하는데, 이것을 Socket이라고 한다
    - Socket이란? : TCP, IP Socket 이라고 했을때, TCP를 User 모드 Application Process가 접근 할 수 있도록 File형식으로 추상화한 인터페이스

![image](https://user-images.githubusercontent.com/39178978/209421150-33508b05-4493-4918-95ac-a9e1ebd443ac.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# Port, IP, MAC

  - 각각은 어떤 식별자 인가?
    - MAC주소 : 네트워크 인터페이스 카드(Network Interface Card)’ 인 ‘NIC’ 에 대한 식별자(NIC은 쉽게 LAN카드라고 할 수 있음)
      - 보통 노트북에는 유선 LAN카드와 무선 LAN카드가 있기 때문에 MAC주소가 2개 있다고 생각하면 된다
      - 맥 주소는 변경 가능하다(Virtual MAC)
    - IP주소 : Host에 대한 식별자(Host : 인터넷에 연결된 컴퓨터)
      - IP주소는 NIC하나에 N개를 바인딩 할 수 있음, 즉 컴퓨터는 IP주소가 여러개 될 수 있음
      - IPv4(32비트, 약43억개), IPv6(128비트) 로 2가지가 있다
        - NET기술 때문에 IPv4체계를 아직까지 대부분 사용하면서 인터넷을 쓰고 있다!(인터넷 하나를 쪼개는 공유기의 보급때문에!)
      - IPv4는 8비트씩 4번을 끊는 식으로 관리한다(000,000,000,000)
      - IPv4는 Network ID와 Host ID로 나뉜다.
        - Netmask : IPv4주소에서 Network ID길이가 얼마인지 나타내는 것
        - ex) IPv4주소 : 192.168.60.14이고 Netmask가 255.255.255.0일때 AND연산을 진행(위의 예제 에서는 192.168.60.0 이 Network ID가 된다, 192.168.60.14/24 이렇게 표기 하기도 한다)
    - Port번호 : 프로세스 식별자, 서비스 식별자, 인터페이스번호
      - 16비트 정보(0~65535)
      - Socket을 생성할때 붙는 번호라고 생각하면되고, 인터넷 정보가들와서 TCP수준까지 올라 왔을때 Port번호를 보고 어떤 프로세스로 갈지 결정하게 된다

![image](https://user-images.githubusercontent.com/39178978/209421715-e1f32dcb-5e9b-4843-818e-127289022ba4.png)

![image](https://user-images.githubusercontent.com/39178978/209421721-45a2eec7-c8c3-41ad-8d35-cac96a155712.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# LAN, WAN

  - LAN : MAC주소에 기초해서 작동하는 네트워크(방송주소에 닿는 수준까지)
  - WAN : IP주소에 기초해서 작동하는 네트워크

![image](https://user-images.githubusercontent.com/39178978/209421744-dd724c67-5983-4d81-9006-a07dfac3e6f5.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# Host, Switch, End-point, Network

  - Host : 컴퓨터가 인터넷에 연결되어 있으면 그 컴퓨터를 Host라고 한다
  - Switch :  네트워크 자체를 이루고 있는 컴퓨터(Router, Firewall, IPS 등)
    - Switch의 역할은 Switching이며 Router는 길을 찾기 위해(경로 선택의 근거는 ‘라우팅 테이블’이다), Firewall 과 IPS 를 보안을 위해 작업을 하게 된다
    - MAC주소를 Switching하면 L2스위치, IP를 Switching하면 L3스위치 라는 식으로 불리게 되고, L1~L7로 갈수록 비싸진다
  - End-point : 네트워크를 이용하는 이용 주체(Peer, Server, Client 등)
  - Network : Router(패킷 경로를 찾아 주는 L3 스위치의 일종으로 생각해도 좋다) + DNS의 집합체

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# IP주소 종류

  - Global IP(공인IP) : xxx.xxx.xxx.xxx 32비트
    - 오로지 하나뿐인 IP
  - Private IP(사설IP) : xxx.xxx.xxx.xxx 32비트
    - LAN이라고 일컬을 수 있다.
    - 공유기가 Global IP를 공유해 주기 때문에 사용할 수 있게 된다
    - 각각 클래스 별로 사설 IP주소가 정해져 있다
      - A : 8비트(네트워크) + 24비트(호스트) : 10..
      - B : 16비트(네트워크) + 16비트(호스트) : 172.16..
      - C : 24비트(네트워크) + 8비트(호스트) : 192.168..
  - Loopback
    - 127.0.0.1이며, 호스트 자신을 의미한다
    - Process 1번과 2번이 있을때 목적지 서버 주소를 127.0.0.1로 보내게 되면, IP에서 NIC으로 내려가지 않고, 다시 올라가게 된다

![image](https://user-images.githubusercontent.com/39178978/209421778-b0336755-8313-42cf-aef2-dc3eddf4f0dc.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# DNS

  - 분산형 DB구조를 가지며, 계층구조를 가지고 있다
  - 최 상단에 Root DNS가 13대 존재한다
  - www.naver.com
    - www : 호스트 네임
    - naver.com : 도메인 네임
  - 모든 컴퓨터는 IP주소로 통신하지만 외우기 어렵기 때문에 DNS를 도입하여 외우기 쉬운 문장으로 표현한것
  - 인터넷에서 도메인 네임을 쳤을때 일어나는 일
    - 1. PC메모리의 DNS Cache를 확인
    - 2. Hosts File을 확인(윈도우 에서)
    - 3. Root DNS에게 확인
      - 공유기는 DNS포워딩을 지원하기 때문에 응답을 대리 하기도 한다
      - 공유기가 응답하지 않을경우는, IPS가 제공하는 DNS에게 물어본다
      - Root DNS가 직접 IP주소를 알려주는 것이 아니며, 연관되어 있는 각각의 DNS목록 들을 보내주며 계층적으로 계속 내려가게 된다
        - 응답시에 계속 이런 절차를 가지면 효율이 떨어지기 때문에 응답시에는 유효기간을 같이 보내주게 된다(PC메모리의 DNS Cache)

![image](https://user-images.githubusercontent.com/39178978/209421832-e58ac85f-89c2-46f3-a02d-d8526ec2cb3a.png)

  - Root DNS에 직접 묻기
    - 1 CMD창에서 "nslookup - <Root DNS IP주소>"
    - 2 CMD창에서 찾고 있는 DNS이름 입력 "www.naver.com"
    - 3 Root DNS는 다른 목록들을 보내주게 되고, 다른 목록에게 다시 물어보는 식으로 진행 한다

![image](https://user-images.githubusercontent.com/39178978/209421860-8fed26b7-bf0f-4a78-bdff-5f07ec5d7f8e.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 웹 서비스 구조
  - 1 HTML탄생 -> 문서 뷰어 역할수행(링크 타고 문서이동)
    - 웹클라이언트(웹브라우저) <-> 인터넷 <-> 웹서버
    - 상호간 TCP/IP의 연결 위에서 HTTP통신을 하게 된다.
      - 웹브라우저가 HTTP통신을 통해서 웹서버에 HTML파일을 요청하면 웹서버는 HTML파일을 송부해줌
      - HTML파일을 받은 웹브라우저는 2가지를 수행
        - 1 - Parser가 구분분석을 해서 자료구조를 생성한다(DOM)
        - 2 - 화면에 렌더링을 하게 된다

![image](https://user-images.githubusercontent.com/39178978/209432617-0eff1553-7357-494c-9bda-186c5b344c22.png)

<br/>

  - 2 CSS의 탄생
    - 클라이언트가 서버에 요청하는 방식으로 ‘단방향’방식.
    - HTML : 자료구조, CSS : UI

  - 3 JavaScript, WAS의 탄생
    - 클라이언트, 서버의 양방향 상호작용의 등장
    - 예전에는 웹서버가 모든 송수신을 담당했지만, 웹이 발전하면서 처리하고 연산해주는 것이 하나 별도로 생겨나게 된다(WAS의 등장)
      - 클라이언트가 동적인 입력과, 정보를 보내게 되었을때, HTTP는 상태를 저장할 수 없는 프로토콜 이므로 각자가 데이터를 저장할 수 있는 저장소가 필요하게 됐다.
      - 웹 서버 -> 데이터 베이스에 상태 저장, 웹 브라우저 -> Cookie에 상태 저장.
      - 동적으로 생성된 HTML 송부가능
      - MVC모델 탄생
    - 웹 브라우저에 연산을 할 수 있는 SW을 집어 넣게 되고 그 언어인 JavaScript가 탄생
    - 웹의 3대 요소
      - 1 - 구문 분석을 해주는 Parser
      - 2 - 렌더링을 해주는 엔진
      - 3 - 연산을 해주는 스크립트 엔진

  - 4 WAS
    - WAS는 미들웨어(Middleware)의 일종.
      - 미들웨어(Middleware) : 운영 체제에서 제공하지 않는 서비스와 기능을 어플리케이션에 제공하는 소프트웨어
      - 데이터관리, 메시지, 인증 및 API 등 관리는 주로 미들웨어를 통해 처리된다
    - 일반적으로 프레임 워크로 개발이 이루어지게 되며, JAVA언어로 많이 개발된다(Spring boot)
    - JAVA코드가 아닌 스크립트 언어만으로 해결 할 수 있다.(node.js, PHP 등)

  - 5 웹 서비스의 성능
    - 1 - WAS 연산 속도
    - 2 - DB 응답 속도
      - 속도를 높이기 위해 튜닝을 한다
    - 3 - 클라이언트 -> 웹서버 응답 속도(즉, 네트워크 속도)
    - 1번 2번을 모니터링 하는 것이 APM 이다(ex : 스카우터(Scouter), 제니퍼(JENNIFER) )

  - 6 RESTful API
    - 예전의 웹은 GET, POST방법을 통해서, HTML + CSS + JavaScript + 사진 등등을 직접 받았지만, 지금은 데이터만 날아 오는식으로 발전됐다(XML, JSON)
      - 클라이언트가 데이터만 받아서 HTML을 생성(자신의 OS에 맞는 HTML생성, JavaScript(React.js, Vue.js, Angular 등))
    - 어떤 웹 시스템을 하나의 기능으로 보고, CRUD(생성,읽기,쓰기,삭제)기능을 제공하게 되고, 이때 HTTP기반으로 클라이언트가 URL을 던져서 CRUD(생성,읽기,쓰기,삭제)기능을 함수형태로 CALL하게 되는데 이것을 RESTful API라고 한다.

  - 7 보안
    - 웹 서버 앞단에 보안으로 꼭 들어가는 3가지
      - IPS
      - SSL
      - WAF

![image](https://user-images.githubusercontent.com/39178978/209432772-98891c0d-ca1d-42c8-a4ef-1c2076874846.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# GET, POST
  - 클라이언트와 서버 사이에 이루어지는 요청과 응답 데이터를 전송하는 방식

<br/>

  - GET type
    - localhost:8080/jsp-test/bmi/output.jsp?name=홍길동&birth=19910315
      - localhost = URL/IP 
      - :8080 = WAS port number  
      - /jsp-test = context root 
      - /bmi/output.jsp = web page경로 
      - ? = 웹페이지와 파라미터 구분. 
      - name = 파라미터값의name 
      - 홍길동 = 파라미터의 값.
      - & = 파라미터와 파라미터 구분
    - Select적인 성향을 가지고 있으며, 서버에서 데이터를 가져와서 보여주기만 하는 용도로 사용한다, 서버의 값이나 상태를 바꾸지 않는다(게시판 리스트 보기, 글보기 등)
    - 한번 접근하면 캐싱을 하기 때문에 두번째 접근할때 속도가 빨라진다
  - POST type
    - localhost:8080/jsp-test/bmi/output.jsp
      - localhost = URL/IP 
      - :8080 = WAS port number  
      - /jsp-test = context root 
      - /bmi/output.jsp = web page경로
    - 한글이 깨지게 된다. 한글을 인코딩해줘야 한다
    - 데이터를 가져와서 서버의 값이나 상태를 저장하거나 수정할 수 있다(글쓰기, 글 수정, DB값 수정)

<br/>

  - http의 기본 포트는 80이고, https의 기본 포트는 443이기 때문에 통신을 할때 기본 포트는 생략해도 되며, 기본 포트가 아닌 경우에는 꼭 명시 해줘야 한다

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 네트워크 데이터 단위
  - Socket수준 : Stream
  - TCP수준 : Segment
      - TCP수준에서의 최대 길이를 MSS라고함(MSS가 MTU보다 작다)
      - MSS는 특별한 이유가 없다면 TCP/IP헤더가 각각 20바이트 임으로 -40을 해서 1460이 된다.(하위 수준으로 내려갈때 각각 헤더가 붙게 됨!)
  - IP수준 : Packet
      - IP수준 에서의 최대 길이를 MTU라고 함(기본적으로 1500 바이트)
      - 따라서 Packet의 크기를 일반적으로 1500바이트이다(TCP,IP헤더 포함), 만일 1500바이트를 넘는다면 2개의 Packet으로 쪼개져서 가게 된다
  - 하드웨어 수준 : Frame

  - User수준인 어플리케이션 process가 추상화한 File에 다가 Stream데이터를 Write하고, kernel수준으로 내려간 Stream데이터가 TCP에서 Segment화 된다. 그것이 인터넷에서 전송 가능한 형태인 Packet으로 캡슐화 후, 실제로 Packet 실어 나를때는 또 캡슐화 하여 Frame이 되어 전송 된다

![image](https://user-images.githubusercontent.com/39178978/209432848-c48ccb71-2e5c-4756-b060-3b9df931e86c.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 패킷의 생성 원리
  - Packet의 생김새
    - Header(IP l TCP)
      - Payload를 실어 나르기 위한 데이터가 들어 있다
      - Header에는 IP(L3), TCP(L4)순으로 Header가 붙어 있게 된다
    - Payload
      - 일반적으로 IP l TCP 가 각각 20바이트로 Header로 붙기 때문에 1460바이트가 된다
      - Payload를 조사하는 것을 DPI라고 한다

  - 프로세스가 소켓에 입출력을 시도 하면 메모리에 저장된 Stream이라는 데이터를 일정한 크기로 자른후, 캡슐화 하여 Packet을 만들고(IP, TCP헤더), 다시 캡슐화 하여 Frame을 만들어 내보낸다

![image](https://user-images.githubusercontent.com/39178978/209432879-5eea2a38-dd77-44f9-b65a-e1573cb1d04a.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# Router의 구조, Inline, Out of path
  - Router(Inline방식)(packet단위를 다룸)
    - 라우터에는 내부로 연결되는 NIC과 외부로 연결되는 NIC이 존재한다
    - 방화벽과 라우터는 둘다 L3스위치에 속하고 IP로 통신한다
      - 방화벽은 보안적인 이유로 Bypass or Drop을 결정
    - 내부적으로 라우터는 Bypass or Drop 인지 결정하고 어디로패킷을 보낼지 지정해줌(이과정을 lnline처리라고 함)
    - Inline구조이며 데이터가 타고 가는 과정은 아래와 같다
    - 아래와 같이 한번 저렇게 H/W -> Kernel -> User 단계를 크로스 하며 갈때 전산 비용이 상당히 발생하게 된다(처리 지연이 발생한다)

![image](https://user-images.githubusercontent.com/39178978/209432901-186e34f1-e2eb-4973-a05d-791be4b1c82a.png)

<br/>

  - 처리 수준의 3가지에 따라 처리 속도가 달라진다
    - Process수준에서 처리한 이후 전송
    - IP수준에서 처리한 이후 전송
    - H/W(NIC)수준에서 처리한 이후 전송
      - H/W단계에서 보내는 것이 가장 빠르고, ‘가속했다’라고 말한다

![image](https://user-images.githubusercontent.com/39178978/209432920-d5941ead-7dad-41a1-b241-d53486f9652f.png)

<br/>

  - Inline방식(packet단위를 다룸)
    - Bypass or Drop중에 하나를 선택 하게 되는 장비
    - Inline형태의 장비가 필터링을 하는 방화벽 역할을 한다면 ‘패킷 필터링 방화벽’이라고 말한다

![image](https://user-images.githubusercontent.com/39178978/209432944-f8bdfd76-256c-4d04-8706-f3239f2b8bee.png)

<br/>

  - Out of path(packet단위를 다룸)
    - 중간에 인터페이스 중의 하나의 선을 따서 장치를 설치하고, 포트 미러링을 시켜서, 그곳을 지나가는 것을 전부 감지한다.
    - 포트 미러링 : 네트워크 스위치의 어떤 한 포트에서 보이는 모든 네트워크 패킷 혹은 전체 VLAN의 모든 패킷들을 다른 모니터링 포트로 복제하는데 사용된다.
    - 감지(Sensor)만 하는 Read only방식이다
    - 포트미러링을 데이터를 전부 copy해서 보내주기 때문에 cpu사용량이 크게 늘게 된다(과부하)
    - 사용용도에 따라서, 장애대응센서 혹은 IDS(침임 탐지 시스템)등이 된다

![image](https://user-images.githubusercontent.com/39178978/209432955-cd6d2982-cd65-4f29-b61d-fcffa967bdbc.png)

<br/>

  - Tap스위치
    - Out of path구조는 부하가 걸리게 하기 때문에, copy만을 전문으로 떠주는 장치
    - 다양한 Out of path의 장치들에게 보내게 된다

![image](https://user-images.githubusercontent.com/39178978/209432967-0f55c843-1c2e-4458-b75b-5ad3e8669d87.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# Proxy
  - Socket Stream데이터를 다룬다!
  - 비슷한 기능을 하는 VPN은 Network수준, Proxy는 HTTP(Web)수준에서 사용한다
  - 어떤 PC1번의 Proxy를 PC2번이라고 설정한다면, PC1의 어떤 서버와 TCP/IP통신 할때
    - 1 - PC1번이 Proxy에 접속
      - PC2번에는 Proxy역할을 해주는 Process(소켓이 2개, 하나는 받고, 하나는 보내고)가 존재 한다는것
    - 2 - Proxy가 PC1번에 원래 접속하려고 했던 곳으로 요청을 보냄
    - 3 - 요청 받은 사이트가 response를 Proxy로 보냄
    - 4 - Proxy가 response를 PC1번으로 보냄

  - 4가지 기능
    - 우회
      - Proxy를 사용하면 접속 사이트는 PC1이 접속한 것이 아니라 PC2가 접속 했다고 생각할것이다
      - 하지만 PC2는 PC1의 모든 통신을 감청을 할 수 있다

![image](https://user-images.githubusercontent.com/39178978/209433140-b044ec6c-60f8-4a24-87da-010cfabf3a49.png)

<br/>

  - 분석
    - wireshark같은 프로그램은 packet을 분석하기 때문에 일반적으로 SSL같은 기술로 payload가 암호화 된다
    - 자기 자신을 분석할 때는 Proxy서버를 로컬로 해놓는 다면 첫번째 프로그램의 Socket단계에서 바로 두번째 프로그램으로 접속한후, TCP단계로 내려가게 된다
      - 암호화는 두번째 프로그램에서 하게 된다!
      - 암호화 되기 전에 볼 수 있다는것!
      - EX) Fiddler

![image](https://user-images.githubusercontent.com/39178978/209433161-32ffc654-8f45-4c20-aed0-084526ec22ee.png)

  - 감시와 보호
    - 모든 PC가 IP번호 3.3.3.100을 가진 PC를 Proxy로 설정한다면 모든PC가 어떤 사이트를 접근할 때 3.3.3.100을 통해 접근 하게 된다. 이때 악성코드가 있던 사이트를 방문 하게 되면 그것이 Proxy로 먼저 가게 된다.(Virus Wall역할)

![image](https://user-images.githubusercontent.com/39178978/209433175-66837719-0648-45c3-a7c0-de136afc7239.png)

  - Reverse
    - Server앞단에 Proxy를 둔다면, 어떤 클라이언트가 Server에 접속하려고 할때 사실은 Proxy IP로 접속하는 것이 된다. Proxy는 그런 클라이언트의 요청을 받아 실제 서버에 접속해 그것을 다시 클라이언트로 보내주게 된다
    - 해커가 해당 web을 공격할때 실제 접속은 앞단에 있는 Proxy에게 하는 것이므로, 그것을 판별해 내는 Proxy를 WAF(웹 방화벽)라고 한다
      - 이러한 Server을 위한 Proxy를 Reverse Proxy라고 한다
      - WAF(웹 방화벽)의 감시 단위 또한 Proxy 이므로 Socket Stream데이터를 감시한다

![image](https://user-images.githubusercontent.com/39178978/209433189-8dad8d01-a12c-4386-866b-f49c96bb4a6f.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# TCP/IP 송수신 원리
  - 서버쪽에서 어떤 파일을 가지고 있고, 클라이언트가 요청했을때 그 파일을 보내주는 상황을 가정
    - 프로그램에 Socket이 열려 있고, 프로그램이 Socket에 파일입출력함(Read : Receive, Write : Send)
      - 1. 하드 디스크에 있는 File(ex : 1.4MB)
      - 2. 하드 디스크의 디바이스 드라이버
      - 3. Socket에 입출력전에, 파일을 입출력하기 위한 메모리를 할당함(Buffered I/O)
        - Memory(Buffered I/O)를 할당할때는 개발자가 결정(ex : 64kb)
        - 용량이 큰 파일을 한번에 불러오는 것이 아니라, 끊어서 불러온다
      - 4. Socket에 파일을 입출력
      - 5. TCP(L4)가기전 분해하게 되는데, Buffered I/O에서 페이로드에 분해하여 복사
        - TCP Window Size는 수신측에서 송신측으로 데이터를 얼마나 많이 전송할 수 있는지를 나타내는 값입니다. 이 값은 바이트 단위로 표현되며, 송신측이 전송한 데이터를 수신측이 얼마나 받을 수 있는지 결정합니다. Window Size 크기가 클수록 더 많은 데이터를 한 번에 전송할 수 있으며, 이로 인해 효율적인 데이터 전송이 가능해집니다
      - 6. IP(L3)쪽으로 내려올때, TCP(L4)앞에 Ip해더를 붙여 Packet화 한다, TCP해더에 번호를 표기한다
      - 7. NIC(L2)쪽으로 내려올때(Frame)
        - IP(L3)쪽에서 내려온것을 다시 NIC에서 이더넷 프레임으로 감싸서 캡슐화함(그것을 배송하기 위해, 트럭에 싣는다 고 생각하기)
        - 이더넷 프레임은 물리적인 네트워크 링크에서 전송되는 단위이며, 이더넷 헤더와 트레일러로 둘러싸여 있다.
          - 이더넷 헤더: 출발 MAC 주소와 대상 MAC 주소, 프레임 유형 등의 정보를 포함한다.
          - 패킷 (IP 헤더, TCP 헤더, 페이로드): 이더넷 프레임 내에서 패킷은 IP 헤더, TCP 헤더 및 페이로드로 구성된다.
          - 이더넷 트레일러: 오류 검출을 위한 추가 정보를 포함한다.
        - 해당 IP(L3)에 도착하기까지 택배 박스가 택배트럭을 많이 갈아 타게 됨(IP Packet앞에 ethernet Head가 붙게 되며, 한 컴퓨터로 이동시 붙었다 떨어졌다를 반복한다)
      - 8. 요청된 IP(L3)에 도착(Packet)
        - 역캡슐화가 일어나, Frame은 사라진다(즉, 택배 기사가 택배를 놓고감)
      - 9. TCP(L4)로 올라감
        - 역캡슐화가 일어나, TCP(L4)쪽 Window Size에 붙게됨(즉, 택배상자가 뜯어져서 내용물이 나옴)
      - 10-1. 데이터를 수신받을 컴퓨터의 TCP(L4) Window Size에 대략 Segment가 2개정도 오면, 잘 수신했다는 것으로 ACK를 보냄(이때 1번 2번 잘 수신했고 3번을 달라고 보내면,        - 자신의 Window Size도 같이 보냄)
      - 10-2. 데이터를 보낼 컴퓨터는 1번 2번을 보낸후 ACK를 기다리게됨(Wait함)
        - 이것 때문에 속도 지연이 발생함
        - TCP가 UDP보다 느린 이유
        - 이때 ACK로 받은 Window Size에, 3번데이터가 들어갈 자리가 없다면, 보내지 않게 된다(Wait함)

  - 결론
    - 수신측에서, TCP(L4)에서 File Buffer로 퍼올리는 Read속도가 > Ne수신 속도 보다 빨라야 한다(그렇지 않으면 처리 지연 발생)
    - 무조건 네트워크 에서 장애를 찾을 것이 아니라, 프로그램이나 CPU속도, 점유율이 높을경우 이런것이 늦어져서 수신이 늦을 수가 있다.

![image](https://user-images.githubusercontent.com/39178978/209433321-58b7103a-cdb8-4e0b-8e77-cad9c1d0a4d8.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 소켓(Socket) 입/출력 버퍼
  - Socket에는 buffer가 있으며, 입력,출력 buffer가 따로 존재한다
  - send함수로 인해서, 그 데이터가 Socket 출력 buffer로 복사해 들어간다
  - 윈도우 같은 경우는, getsockopt라는 함수를 통해서 Socket입/출력 buffer를 확인할 수 있다
    - 하지만 윈도우의 같은 경우는 OS가 알아서 해주는 부분이 충분히 있어서 getsockopt으로 나오는 buffer가 큰 의미가 없을 수도 있으며, 다를 수도 있다
  - Socket 마다 고유의 입/출력 buffer의 크기를 다르게 설정할 수 있다
  - Socket에는 기본적으로 네이글 알고리즘(Nagle Algoritm)이 적용된다
    - Nagle Algoritm은 송신에 있어서 버퍼를 둔 뒤 상대방 Host 의 Window 사이즈를 고려한 후, 어느정도 길이만큼의 패킷을 한번에 전송하는 기술이다
  - send와 recv는 1:1로 매핑되지 않는다(Nagle Algoritm)
    - send가 1회 호출될때, recv도 1회 호출 될 것이라는 생각을 하면 안된다!
    - send의 인터벌이 중요하며, 빠르게 3번을 보내면, 그것을 전부 담아낼 수 있는 크기의 recv는 1번 호출로 다 담아내게 된다.
      - Socket에 있는 출력 buffer에 쌓이게 되고, 이것이 한번에 전송되게 된다(여러가지 지연 문제로 인해서)

<br/>

  - 1 bit씩 send를 했지만, 여러가지 지연원인 때문에 출력 buffer에 쌓이게 되면게 8bit가 전송된 것들도 보인다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/edbe2cda-b803-42da-9ef9-ac0de387210e)

<br/>

  - 게임같은 경우는, 버튼 하나만 클릭해도 반응을 해야 하기 때문에, send로 한것이 Socket 출력 buffer에 쌓이지 않고, 무조건 갈 수 있도록 세팅해줘야 한다
    - 윈도우 같은 경우는 setsockopt함수로 옵션을 TCP_NODELAY로 지정해 줘야 한다
  - 양방향 연결을 할시에는, 서버는 클라이언트가 살아 있는지 주기적으로 신호를 보내서 좀비세션인지 아닌지 확인하는 하트비트를 보내주어야한다

<br/>

  - bps : 초당 bit 수
  - pps : 초당 packet의 수
  - pps보다 bps가 높은 것이 좋다

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# L2스위치
  - MAC주소 : cmd창에서 -> ‘ipconfig /all’명령어 -> 물리적주소
  - L2스위치는 2종류가 있다
    - L2 Access : Endpoint와 직접 만나는 스위치
    - L2 Distribution : Access스위치와 연결되는 스위치
  - uplink : 상위 계층 스위치로 연결되는 라인
    - Link-up, Link-down과 의미가 전혀 다르니 헷갈리지 말자

![image](https://user-images.githubusercontent.com/39178978/209433490-3b740c70-3128-457e-b67f-48aa8022545d.png)

<br/>

  - 예를 들어 L2스위치로써 16개를 꼽을 수 있는 장치가 있다면 uplink로 하나 연결해야 하니 최대 15개 컴퓨터 연결이 가능하게 된다

![image](https://user-images.githubusercontent.com/39178978/209433508-9507c35f-92d8-48cc-82c1-a396174ac207.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# TCP/IP통신시 MAC주소 변화
  - 통신시, TCP - IP - NIC수준으로 이동하게 되며, IP - NIC수준 이동시 캡슐화가 된다
    - IP Packet앞에 ethernet Head가 붙게 된다
  - L2통신시에는 IP주소는 보지 않고, MAC주소만 보기때문에 L2통신에 MAC주소는 중요하다.
  - 각 라우터는 Packet 수신자의 IP와 목적지 IP를 보고, 가장 빠른 길로 갈 수 있는 다음 라우터의 MAC주소만 바꿔서 간다고 생각할 수 있다

![image](https://user-images.githubusercontent.com/39178978/209433549-6c47eb61-a8cb-400d-a46f-728d6f9f4f0f.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# L2스위치 작동원리, ARP
  - ARP : IP주소로 MAC주소를알아내는 프로토콜
  - Broadcast를 쏴서 찾고 있는 IP를 가진 컴퓨터가 응답을 Unicast로 하게 된다
  - 그러한 ARP를 조작하는 것을 ARP Spoofing이라고 한다

![image](https://user-images.githubusercontent.com/39178978/209433578-bd159143-9ac8-4f16-b6f9-d818aef04a12.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# TTL
  - TTL(Time To Live) : Hop을 하나 지나갈때마다 TTL을 하나 줄이게 된다. 0이 되면 Packet이 사라지게 된다
    - 라우터에 Looping이 발생했을때, 라우터의 cpu점유율이 뛰고 망가질 수 있기 때문에 TTL이 0이 되면 없어지게 된다.
    - TTL이 0이되었던 라우터에서 ICMP를 보내주게 된다(보안 때문에 설정해 놓지 않았다면 보내지 않는다)
  - Hop : 라우터와 라우터 사이의 간극

![image](https://user-images.githubusercontent.com/39178978/209433602-164a8df7-406a-4e88-9ad9-601d0d2a195a.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 3 way handshake, 4 way Handshaking
  - 3 way handshake는 4계층인 TCP전송 프로토콜에서 이루어진다.
    - TCP 3 Way Handshake는 TCP/IP프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에 먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정이다.
      - Client > Server : TCP SYN
      - Server > Client : TCP SYN ACK
      - Client > Server : TCP ACK
    - 주고 받는 단위 :  Segment
    - Server는 Client의 Seq번호를 받고, 응답해줌
      - Seq번호는 32bit 난수를 생성해서 교환한다(보안 때문에)
        - 아래 그림에서는 클라이언트가 Seq로 1000을 가지고 있고, 서버가 잘 받았다고 1001을 보내면서, 자신의 Seq 4000번을 보내고 클라이언트는 잘 받았다는 것으로 4001을 보내는 사진이다
      - MSS사이즈 및 정책을 교환한다
      - 가장 작은 MSS로 하향 평준화 하여 맞춘다
      - 정책 : 혼잡제어
        - 네트워크가 문제가 있어서 수신이 안되거나, 데이터를 받지 못하는 상황
    - 3 way handshake을 한다는것
      - Seq교환, MSS교환, 정책 교환
      - 보안이 전혀 되어 있지 않다
  - STEP1 : 클라이언트는 서버에 접속을 요청하는 SYN 패킷을 보낸다. 이때 A클라이언트는 SYN 을 보내고 SYN/ACK 응답을 기다리는SYN_SENT 상태가 된다.
  - STEP2 : 서버는 SYN요청을 받고 클라이언트에게 요청을 수락한다는 ACK 와 SYN flag 가 설정된 패킷을 발송하고 클라이언트가 다시 ACK으로 응답하기를 기다린다. 이때 서버는 SYN_RECEIVED 상태가 된다
  - STEP3 : 클라이언트는 서버에게 ACK을 보내고 연결된다

![image](https://user-images.githubusercontent.com/39178978/209433642-03d0d76c-a5be-4aad-98d9-706d279b2393.png)

<br/>

  - 3 way handshake는 서버가 클라이언트를 accept하여 클라이언트 소켓을 만들기도 전에 클라이언트의 connect함수만으로 일어난다

<br/>

  - 4 way handshake는 세션을 종료하기 위해 수행된다
    - STEP1 : 클라이언트가 연결을 종료하겠다는 FIN플래그를 전송
    - STEP2 : 서버는 일단 확인메시지를 보내고 자신의 통신이 끝날때까지 기다린다
    - STEP3 : 서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 FIN플래그를 전송
    - STEP4 : 클라이언트는 확인했다는 메시지를 전송
      - 클라이언트의 마지막 TIME_WAIT는 Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로 인해 FIN패킷보다 늦게 도착하는 상황이 발생했을경우를 대비해서 Client는 Server로부터 FIN을 수신하더라도 일정시간(디폴트 240초)동안 세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치는 것을 말한다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/a300f7cb-5f8a-4e35-8ffb-5ee5eacdb2f8)

<br/>

  - 정상적인 통신 종료는, 클라이언트가 서버에게 통신을 끊자고 보내는 것이며, 그렇게 해야 클라이언트 쪽에서 TIME_WAIT가 발생한다. 서버가 먼저 끊자고 통신을 보내서 서버 자체가 TIME_WAIT가 발생하면 안된다(= 좋은 설계가 아니다)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# MTU, Packet 단편화
  - Packet이 단편화가 일어나면, 잘려진 뒤쪽에도 IP해더를 복사해서 붙이게 되며, Offset값을 붙여서 어느 지점에서 잘렸는지 알 수 있게 한다
  - 수신받는 측에서 보통 단편화된 것들을 조립하게 된다
  - 현재는 거의 발생하지 않지만, VPN때문에 간혹 발생하게 된다
  - 단편화가 나지 않도록 하향평준화 시키면 된다

![image](https://user-images.githubusercontent.com/39178978/209433664-5262225f-bed6-4c62-99e9-7e27ca98653f.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# Unicast, Broadcast, Multicast
  - Unicast : 내부 네트워크 망 안에서 통신 하는것(PC1 과 PC24가 통신)
  - Broadcast : Broadcast주소는 HOST주소가 2진수로 전부다 1일때를 가리킨다
    - PC1이 Broadcast 주소로 전달을 하게 되면, 내부 네트워크 안에 있는 모든 IP에 전달 되게 된다.
      - IP : XXX.XXX.XXX.255
      - MAC : FF FF FF FF FF FF
    - Broadcast를 하게 되면, 그 순간은 어느 IP에서도 신호를 쏠 수 없게 된다. 네트워크 효율을 떨어 뜨리며, 최소화를 해야 한다.

![image](https://user-images.githubusercontent.com/39178978/209433702-52260eb2-8bc0-4925-b056-d992c62937aa.png)

<br/>

  - Multicast : 한 IP에서, 특정한 여러 IP로 지정해서 보내고 싶을때
    - 어떤 등록된 IP는 신호를 받고 사용하게 되지만, 등록되지 않은 IP가 받았을 경우, 받자 마자 무시를 하게 된다
      - 즉, L2수준에서는 Broadcast처리가 되기 때문에, 효율을 떨어뜨리게 됨으로 ‘SDN’이 등장하게 됨

![image](https://user-images.githubusercontent.com/39178978/209433744-a45b1c34-2541-40eb-bd8b-ecb7501a8b50.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 서브넷팅
  - 사설IP를 더욱 나누어서 쓰기 위해서 사용함
  - 서브넷 마스크 bit수를 1증가시키면, Network ID값이 1bit증가되고 Host ID를 나타내는 bit가 1 줄어들게 된다
  - https://code-lab1.tistory.com/34

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 공유기 작동원리
  - NAT-Table을 참고해서 작동 된다
    - 1 - 최초의 Packet을 보고, 송신, 수신 에 대한 IP, Port를 적어 놓는다
    - 2 - Port번호를 변경시켜서 수신된 곳에 보낸다
      - 이때는 공유기 IP와, 공유기가 바꾼 Port번호로 가게 된다
    - 3 - 수신된 곳에서 Response를 보내서, 공유기가 수신 받는다
    - 4 - Packet을 열어서, IP, Port를확인하고, NAT-Table을 참고해서 처음 수신했던 PC로 Response보낸다
  - 공유기 안쪽의 사설IP에 있는 다른 PC 2대가, 외부에 있는 사이트에 접속했을 때, 사이트는 같은 IP인 공유기가 2번 접속 했다고 생각하게 된다
  - F/W기능을 수행한다
    - 내부에 있는 PC에서 송신할때 NAT-Table에 그것들을 보관 하고 나중에 참고해서 보내주기 때문에, 해커가 접속하게 됐을 때, NAT-Table에 존재하지 않기에 자동으로 F/W기능을 하게 된다

![image](https://user-images.githubusercontent.com/39178978/209433787-ba919305-b58d-4184-840b-ef56d5c69959.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 부하분산(Load Balancer)
  - 공유기와 같은 원리로 작동된다, 서버에 골고루 접속시킬 수 있도록 작동
  - 보통2대를 사용하게 된다
    - 1대만 쓰게 된다면, 1개가 고장나면 큰일이 나기 때문

![image](https://user-images.githubusercontent.com/39178978/209433803-0a1edd9f-1a4a-439d-9c15-c63b08cf117d.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# VPN작동원리(L3, IPSec)
  - 내부망 안에 있는 Server는 내부에서만 접근이 가능한데, 외부에서 접근하기 위해 VPN을 사용하여 ‘터널링’한다.
  - 라우터나, 보안장치가 전부 VPN을 지원해야 한다(SG = SecureGate를 지원해야 한다)
  - VPN프로그램을 설치 해야 한다
  - 내부망 IP주소를 외부로 하나 할당하게 된다
  - 순서
    - 1 - VPN 프로그램을 깔면, Virtual NIC Driver가 생김
    - 2 - 그곳에 내부망 IP를 할당한다
    - 3 - Virtual 로 만들어진 IP를 탄후, 본래의 IP를 타고 가게 된다
      - IP, TCP 헤더가 2개씩 붙게 된다
      - 헤더가 하나더 붙기 때문에 MTU 1500을 초과하게 되어 단편화가 발생되니, Payload를 기본적으로 1460보다 더 작게 만들어 헤더가 하나더 붙었을때 초과 되지 않게 만든다
    - 4 - 공유기가 그 IP를 받게 되고, 그것을 디캡슐화 시킨다

![image](https://user-images.githubusercontent.com/39178978/209433861-7cd9c8ee-d239-4185-a296-03a020ae46a0.png)

<br/>

![image](https://user-images.githubusercontent.com/39178978/209433865-3919c937-5db1-4d58-9f22-d5d5c92a1ca7.png)

<br/>

![image](https://user-images.githubusercontent.com/39178978/209433873-d3215dfa-4e57-4c0a-a48a-071dfc2aa89a.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

# 네트워크 보안 종류
   - 1 - L1~L3 : NAC(Network Access Control) + Probe + IP관리 시스템
      - IP주소(Packet), MAC주소(Frame) 을 봄
      - 네트워크에 아무나 접근 못하게 하는것
        - 1 - L2 Port(Interface)를 다운시켜서 통신을 못하게함
        - 2 - HTTP 통신을 리다이렉트(Redirect)시킨다
        - 3 - DHCP통제(주소를 자동으로 할당 받지 못하게 만들어서 인터넷 못하게함)
        - 4 - ARP Spoofing
          - 네트워크의 장애원인중의 하나게 될 수 있으니 유의하기
   - 2 - L1~L2(무선에서만) : WIPS
      - MAC주소(Frame) 을 봄
      - 몰래 무선 네트워크를 쓰지 못하도록 차단

![image](https://user-images.githubusercontent.com/39178978/209434051-1a383ac2-0db2-47fd-8e27-f0393f6a82ea.png)

<br/>

  - 3 - L3~L4 : FW(Packet filter), Screening Router
    - Port주소(Segment), IP주소(Packet) 을 봄
    - F/W의 동작 방식 : Stateful Inspection
      - TCP에서 연결을 할때, 연결을 전이하는 과정중에서 순서가 정상적인지, 정상적이지 않은지 확인한다.
  - 4 - L5~ : WAF(웹 어플리케이션 방화벽 -> Proxy형태로 되어 있음)

  - 5 - L3~L4 : VPN(IPSec)
    - 망 수준에서의 보안을 제공함 -> Gage to Gage, Gage to End Point
      - 터널링을 통해서 망 접속을 제공해줌
  - 6 - L5~ : SSL VPN(Proxy형태로 되어 있음)

  - 7 - 망분리, 망연계

  - 3번, 4번을 합쳐서 Hybrid FW이라고함
  - 3번, 4번, 5을 합쳐서 UTM(Unified Threat Management, 통합 위협 관리) 라고 한다
    - 하나에 기능이 다 들어가 있기 때문에 성능이 떨어 질 수 밖에 없으면, 기본적으로 중,소 기업에서 사용하게 된다

  - 1~7번까지는 네트워크 보안 인프라에 해당함
    - 수동적인 성향이 있음
    - 보안 ‘정책’이 중요함
      - 설치, 설정

![image](https://user-images.githubusercontent.com/39178978/209434145-42647182-e038-4c4d-b47a-154e1de91685.png)

<br/>

  - 수동적인 보안의 한계로, 능동적인 보안 솔루션이 등장
    - ‘Rule’이 중요함

  - 1 - L3~ : IDS, IPS (네트워크 침입 탐지 시스템)
    - IDS, IPS 하는 일은 같지만 설치 구조가 다름(DPI를 함)
    - NIDS : Out of path구조
    - IPS  : Inline구조

  - 2 - Sandbox
    - 악성코드를 집어 넣어서, 어떤 반응을 일으키는지 확인한다

  - 3 - MPS(8번, 9번을 합친 솔루션)

  - 8번, 9번, 10번 같은 솔루션은 클라우드와 연계되어 ‘평판 시스템’을 갖는다

  - 4 - 많은 데이터로 인해, 통합으로 관리해야할 필요가 생김
    - 엔터프라이즈 서비스 관리(ESM)가 생김

  - 5 - 수많은 로그가 쌓임에 따라 그것을 분석하고 대처할 SIME(보안 정보 및 이벤트 관리)도 생기게됨
    - 분석을 AI(인공지능)으로 진행하는 경우가 많아짐

![image](https://user-images.githubusercontent.com/39178978/209434191-098a4286-e83b-4ced-879d-8780a973788d.png)

###### [Network기초](#network기초)
###### [Top](#top)

<br/>
<br/>

***

# Network활용
  - [http와 Socket통신과 TCP](#http와-socket통신과-tcp)
  - [서버 상태 확인하기](#서버-상태-확인하기)
  - [wireshark(패킷 분석 프로그램)](#wireshark패킷-분석-프로그램)
  - [Ping테스트](#ping테스트)
  - [네트워크 경로 추적(tracert)](#네트워크-경로-추적tracert)
  - [내부 서버 만들기](#내부-서버-만들기)
  - [CSR,SSR,TTV,TTI](#csr,ssr,ttv,tti)
  - [웹 어셈블리(WebAssembly 혹은 WASM)](#웹-어셈블리webassembly-혹은-wasm)

###### [Network활용](#network활용)
###### [Top](#top)

<br/>
<br/>

# http와 Socket통신과 TCP
  - TCP는 4계층인 전송계층이며, http는 7계층인 응용계층으로써 TCP를 기반으로 하게 된다. 소켓(Socket)은 OS커널에 구현되어 있는 프로토콜 요소에 대한 추상화된 인터페이스이다, 예를 들어 블루투스 장치라면, 블루투스 소켓이라고 하고, IRDA라는 적외선 장치라는 IRDA 소켓 이라고 한다.
  - TCP통신은 3-way-handshake라는 과정을 거치고 연결이 이루어진다. 그리고 연결을 종료할때는 4-way-handshake를 거치게 된다. 또한 양방향 통신이 된다. 양방향 통신이란, 클라이언트단과 서버단이 서로 연결되어 있을때 양방향(클라이언트 -> 서버, 서버 -> 클라이언트) 으로 요청을 보내 통신을 할 수 있게 해주는 것이다. 또한, 클라이언트단과 서버단의 연결이 끊어지지않고 계속 연결을 유지해주어 실시간 소통이 가능하다.
  - http통신을 할때도, 연결할 때, 연결을 끊을때 TCP계층을 이용하지만, 데이터를 전송하는 부분은 HTTP로 이루어지게 된다. 한마디로, HTTP 통신을 하기위해서는 OSI 계층에서 TCP 기반인 4계층에서 3-way-handshake로 연결과정을 거치고 7계층에서 HTTP 기반으로 데이터 전송을 하고 다시 4계층에서 4-way-handshake로 연결을 끊는 과정을 거쳐야 한다. 또한 http 프로토콜은 단방향으로 설계되었다.

###### [Network활용](#network활용)
###### [Top](#top)

<br/>
<br/>

# 서버 상태 확인하기
  - 와이어 샤크로 패킷 확인시, 컴퓨터 1대에서 서버와 클라이언트 모두를 사용할때는 루프백 인터넷으로 학인한다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/c3e24dc7-4929-485f-8e45-690601b5f2a4)

<br/>

  - netstat -ano | find “25000”
  - 서버가 실행되지 않았을 경우아무것도 나오지 않음

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/d61a07c6-7bd7-400c-ae0c-c2377f14b196)

<br/>

  - 서버가 실행됬을 경우

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/4956f19e-194c-4ba8-a86d-509dfeee1de1)

<br/>

  - 클라이언트가 실행되고, 서버에 접속해서 3핸드 쉐이크를 통해 연결

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/615b6f6e-5512-4d5c-bedd-b33c25e973c8)

###### [Network활용](#network활용)
###### [Top](#top)

<br/>
<br/>

# wireshark(패킷 분석 프로그램)
  - Outbound : 데이터가 나가는것
  - Inbound : 데이터가 들어오는것
  - Filter는 Bypass(, Drop을 시킬 수 있으며, Sensor(항상 Bypass)는 그러한 것은 없고 감시(수집)만 한다
 
  - 인터넷에서 데이터가 들어올때, kernel단계인 IP의 단계 전에, 필터 및 센서 프로그램을 설치 할 수 있어서, Inbound , Outbound  된 패킷을 확인 할 수 있다.

  - wireshark
    - 설치하면 Sensor가 설치가 된다(Npcap)

![image](https://user-images.githubusercontent.com/39178978/209434291-a00a78ca-1240-4934-bc2e-d60d0e15ea1b.png)

<br/>

  - Frame단위의 데이터들을 확인할 수 있다
  - wireshark에 있는 목록을 file로 만들면 Trace File이라고 불린다

<br/>

  - 구성/설명

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/8c7e192c-80d9-4089-ae54-f93e0a6bd958)

  - 1. 필터 검색을 통해서 원하는 패킷을 찾는다
  - 2. 패킷 데이터들 목록(실제로는 Frame값 들이 들어있다)
  - 3. 텍스트로 나오는것
  - 4. 16진수로 나오는것

<br/>

  - 레이아웃 변경도 가능하다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/1ff74eda-91f4-4b0e-9458-d042530481f9)

<br/>

  - 라이브 캡쳐에 사용할 것을 더블클릭으로 들어간다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/5e1c3781-a3e3-4989-a9ae-0bf983dd01a1)

<br/>

  - 특정한 것을 열로써 적용해서 편하게 볼 수 있다
  - 이런 칼럼이 많아지면 느려질 수 있다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/55470207-e2ef-44d9-8014-02de24df14b5)

<br/>

  - 각각목록에 따라서 컬러를 바꿀 수도 있다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/811fcfc8-2695-4144-9800-de25b9737b4d)

<br/>

  - 특정 패킷을 따라가기를 하면, 전부 재조립해서 보여준다
    - 조립한 이후에 리스트에 조립할 데이터만 보여준다
    - 정말 편리한 기능중 하나!

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f5979e0c-6c4c-4ffe-b3af-5c2956205b19)

<br/>

  - 리스트를 클릭후, Ctrl + 1 ~ 9를 통해서, 조립될 리스트의 컬러만을 바꿔준다
  - TCP는 순서가 있지만 UDP는 순서가 없기 때문에 조립할때도 UDP는 오는 순서대로 조립을 하게 된다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/ddb85437-6883-4681-8eaa-fa88675c3be4)

<br/>

  - 객체 내보내기를 통해서, 파일을 검색하고, 재조립해서 볼 수가 있다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/c5bda765-6af9-459d-aff0-ee39ba1c56c2)

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/f2bf7c70-fe3f-4a74-b523-1bc11fdd4091)

<br/>

  - 통계의 종단점, 즉 앤드포인트로 가면 통계치를 볼 수 있음
    - 각각이 패킷을 얼마나 많이 유도 했는지 볼 수 있고, 필터로 적용을 하게 되면 그것만 필터해서 보여줌

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/c4e2b25a-264e-4224-ac8c-8bcf76af94bb)

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/fe4fdaad-b7d5-4a90-8439-7de3740655eb)

<br/>

  - 네트워크 장애 4가지
    - H/W
      - 잃어버림
      - 순서가 잘못들어옴
    - K
      - 재전송 요구
    - U
      - Window Size 문제, 어플리케이션 I/O버퍼가 가득찼다

<br/>

  - HTTPS통신
    - SSL =  TLS
    - 서버의 인증서에, public키와 private키가 있고, 그것을 통해  브라우저의 Session key를 암호와 한다.  Session key는 브라우저가 만드는 것이며 이것을 알 수 있다면 복호화를 할 수 있다
    - 브라우저가 Session key를만들때 log를 남기게 할 수 있다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/185f569a-3a70-4e14-99a6-5ef512bc5734)

<br/>

  - 아래에 해당 파일을 찾아 넣으면 복호화가 된다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/64d1f32b-38db-44cc-8490-f1fa87133f0d)

###### [Network활용](#network활용)
###### [Top](#top)

<br/>
<br/>

# Ping테스트
  - 상대 컴퓨터에 일정한 크기의 패킷을 보내어 상대 컴퓨터가 응답하는지를 점검하는 명령어
  - ping [ip주소]
  - 손실이 없다면, 패킷의 주고 받음이 같아야 한다

![20231002_212345](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/a90f018d-20ef-4816-aa74-d249043dabdf)

  - ping옵션 사용 명령어 : ping /?
  - 인터넷 연결이 정상적인지 확인하기 위해서는 인터넷 회사와 같은 고정적인 IP주소를 가진 곳으로 날려 보면 된다
    - SK DNS : 219.250.36.130
    - KT DNS : 168.126.63.1
    - LG DNS : 164.124.101.2
    - Google : 8.8.8.8
  - ping [도메인] 을 입력하면 ip를 구할 수 있다
  - TTL(Timer to live)
    - TTL은 목적지 장비의 기본 홉수를 기준으로 출발지에서부터 시작하여 라우터(L3)를 하나 거칠 때마다 1씩 감소하며, 목적지에 도착했을 때 남은 홉수를 나타낸다
    - 패킷이 살아있는 홉수를 제한함으로써 트래픽의 과부하를 막는다
    - ping은 ICMP(internet control message protocol)을 이용하여 통신 하며, ICMP를 지원하지 않는 기기를 대상으로는 ping을 할 수가 없다
    - ping명령어는 상대 컴퓨터에 일정한 크기의 패킷을 지속적으로 보낼 수 있기 때문에 악의적으로 패킷을 전송시켜 서비스가 불가능하게 할 수 있다 따라서, 응답이 없거나, 요청시간이 만료되었다는 말이 나와도 상대 컴퓨터에 문제가 있다고 보기 어렵다

###### [Network활용](#network활용)
###### [Top](#top)

<br/>
<br/>

# 네트워크 경로 추적(tracert)
  - tracert [ip]

![20231002_213248](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/453c5ae8-273a-45ea-8f38-4f813e361ba2)

  - 최대 30홉까지의 경로를 나타낸다
  - ping에서 사용하는 ICMP를 사용한다
  - 중간의 * 표시는 보안상의 이유로 라우터 또는 장비의 IP가 외부에 노출되지 않도록 하기 위해 ICMP가 차단되어 있어 응답하지 않는 경우이다
  - tracert 옵션 사용 명령어 : tracert /?

###### [Network활용](#network활용)
###### [Top](#top)

<br/>
<br/>

# 내부 서버 만들기
  - 192.168.0.1 라우터에 접속하기
  - 고급설정 -> NAT/라우터 관리 -> 포트포워드 설정
  - 내부IP, 외부 포트, 내부 포트를 설정한다
  - 내부IP : 어떤 IP에 보낼껀지
  - 외부포트 : 외부에 어떤 포트를 통해서 들어오게 할껀지(서버에 접속하려고 하는 프로그램은 이 포트로 접속해야 한다)
  - 내부 포트 : 현재 서버로써 실행되고 있는 프로그램의 포트

![20231002_213258](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/34f82cbe-6df6-4997-ba09-96515e7e2a48)

###### [Network활용](#network활용)
###### [Top](#top)

<br/>
<br/>

# CSR,SSR,TTV,TTI
  - CSR(Client Side Rendering)
    - 1.클라이언트가 서버에서 index.html파일을 받아온다(html파일은 텅텅 비어 있기 때문에 사용자 에게는 아무것도 보여지지 않는다)
    - 2.index파일에 링크되어 있는 js파일을 요청
    - 3.서버는 클라이언트에게 js파일을 전해 준다
    - 4.그 후 사용자는 웹사이트를 볼 수 있게 된다(사용자가 클릭할 수도 있다)

TTV : 사용자가 웹사이트를 볼 수 있음
TTI : 클릭을 하거나 인터랙션이 가능함

  - SSR(Server Side Rendering)
    - 1.클라이언트가 서버에서 요청을 보내면, 서버에서 이미 잘 만들어진 index파일을 준다
    - 2.사용자가 웹 사이트를 볼 수가 있다
    - 3.하지만 아직 동적으로 인터랙션 할 수 있는 js파일을 받지 않았기 때문에, 클릭과 같은 아무 것도 처리 할 수가 없다
    - 4.그 후 js파일을 요청하게 되고, js파일을 받은 후에야 클릭과 같은 인터랙션을 할 수 있게 된다

사용자가 웹사이트를 보는 시간과, 그것을 인터랙션 하는 시간의 공백 기간이 있는 편이다

###### [Network활용](#network활용)
###### [Top](#top)

<br/>
<br/>

# 웹 어셈블리(WebAssembly 혹은 WASM)
  - 1. git clone https://github.com/emscripten-core/emsdk.git
  - 2. cd emsdk
  - 3. ./emsdk install latest(emsdk install latest)
  - 4. ./emsdk activate latest(emsdk activate latest)
  - 5. emsdk_env.bat

Dir : hello.cpp
~~~C++
#include <iostream>
int main() {
  std::cout << "Hello WebAssembly!" << std::endl;
  return 0;
}
~~~

  - 6. emcc hello.cpp -o hello.html
    - emcc로 생성된 HTML 파일을 직접 브라우저에서 열면 일부 보안 정책 때문에 웹 어셈블리 코드가 실행되지 않을 수 있다. 브라우저가 파일 URL (file://) 에서 AJAX 요청을 차단하기 때문에
    - 터미널에서 직접 html파일을 실행하자
      - emrun hello.html

<br/>

  - gpt답변….

Q. 일반 콘솔이 아닌, mfc로 되어진 프로젝트 파일을 웹 어셈블리화 하는것은 어떻게 해?

A. MFC (Microsoft Foundation Classes)는 Microsoft가 제공하는 C++ 클래스 라이브러리로, Windows 응용 프로그램 개발을 위한 다양한 GUI 요소와 통합 개발 환경을 제공합니다. 이는 특히 Windows 운영 체제에 특화되어 있으며, Windows API에 대한 래퍼 함수를 제공하여 Windows 응용 프로그램 개발을 쉽게 만듭니다.

그러나 Emscripten과 WebAssembly는 브라우저에서 실행되도록 설계된 기술이므로, Windows나 MFC와 같은 플랫폼에 종속적인 코드를 그대로 변환하는 것은 불가능합니다. 브라우저 환경은 파일 시스템이나 네트워크, UI와 같은 시스템 리소스에 직접 접근하는 것을 제한하며, MFC와 같은 특정 운영 체제의 UI 툴킷을 사용하는 것도 불가능합니다.

따라서 MFC 응용 프로그램을 웹으로 이식하려면, GUI를 HTML, CSS, JavaScript와 같은 웹 기술을 사용하여 재구현해야 합니다. 그리고 시스템 리소스에 대한 액세스는 브라우저 API나 Emscripten이 제공하는 API를 사용하여 재구현해야 합니다.

웹에서 복잡한 GUI를 구현하기 위한 다양한 라이브러리와 툴킷이 있으므로, 해당 응용 프로그램의 요구 사항에 맞는 것을 선택하여 사용할 수 있습니다. 예를 들어, React, Vue, Angular와 같은 프레임워크를 사용할 수 있고, WebGL이나 Three.js를 사용하여 3D 그래픽을 구현할 수 있습니다.

그러므로 기존의 MFC 프로젝트를 웹으로 이식하는 작업은 많은 시간과 노력을 필요로 하며, 웹 개발에 대한 충분한 지식이 필요합니다.

###### [Network활용](#network활용)
###### [Top](#top)

<br/>
<br/>

***

# 리버싱
  - 파일을 직접 실행해 파일, 레지스트리, 네트워크 등을 관찰하여 프로그램의 행위를 분석
  - 컴파일된 바이너리(exe, dll, sys 등)를 디스어셈블(disassemble) 도구를 이용하여 어셈블리 코드로 변환하여 필요한 작업을 수행하는 것

<br/>

  - 분석 방법
    - 정적 분석
      - 파일을 실행하지 않고 분석하는 방법
      - 파일의 겉모습을 분석(겉핥기 식)
    - 동적 분석
      - 파일을 실행하고 분석하는 방법
      - 파일 깊이 들어가서 분석하고 관찰

<br/>

  - 정적 분석 도구
    - IDA
  - 동적 분석 도구
    - Cheat Engine
    - Ollydbg
    - x64dbg
    - x32dbg
    - IDA

<br/>

  - x64dbg
    - 실행 파일을 오픈 하거나, 드래그앤 드랍해 놓으면 파일이 딱 멈추게 된다

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/560c5cce-c193-49f8-839e-9df3ffe3ee7c)

<br/>

  - 창설명
    - 어셈블리 코드창
    - 덤프창
    - 스택 창
    - 레지스터 창
  - 어셈블리 코드창에서 더블클릭하면 그 안으로 들어가게 됨
    - F2단축키 : 중단점 설정
    - F8단축키 : 한줄한줄 실행
    - F7단축키 : 함수 안으로 들어가기

###### [리버싱](#리버싱)
###### [Top](#top)
