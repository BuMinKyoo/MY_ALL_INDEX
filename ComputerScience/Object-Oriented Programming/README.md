<br/> 

###### Top

- [개체지향 프로그래밍이란?/필요성/개체란?](#개체지향-프로그래밍이란?필요성개체란?)
- [OOP의 4대 특성](#oop의-4대-특성)
- [클래스(Class)](#클래스class)
- [Class베스트 프랙티스](#class베스트-프랙티스)
- [개체 모델링](#개체-모델링)
- [static, 싱글턴, 내포 클래스](#static-싱글턴-내포-클래스)
- [상속(inheritance)](#상속inheritance)
- [상속을 이용한 개체 모델링](#상속을-이용한-개체-모델링)
- [상속 vs 컴포지션](#상속-vs-컴포지션)
- [다형성](#다형성)
- [추상 메서드/클래스](#추상-메서드클래스)
- [인터페이스(interface)](#인터페이스interface)
- [인터페이스 vs 구현, 의존성 주입](#인터페이스-vs-구현-의존성-주입)
- [디자인 패턴](#디자인-패턴)
- [예외](#예외)
- [SOLID설계 정신](#solid설계-정신)

<br/>
<br/>

***

# 개체지향 프로그래밍이란?/필요성/개체란?
  - 개체지향 프로그래밍이란?
    - OOP : Object-Oriented Programming
    - 프로그래밍 패러다임 중 하나
    - 프로그램을 구성하는 기본 요소를 개체로 보려는 노력
    - OOP프로그램이란?
      - 상호작용하는 개체들의 집합
      - 절차적 프로그래밍은 실행할 명령어의 목록을 프로그램으로 봤음
  - 개체지향 프로그래밍의 필요성
    - 1. 절차적 언어는 데이터의 비인간화
    - 2. 절차적 언어는 데이터가 많아지면 관리가 힘듦
    - 3. 보완책으로 구조체(struct)를 사용
      - 데이터를 그룹으로 묶어 새로운 데이터형을 만드는 방법
      - 이 그룹을 마치 하나의 ‘변수처럼 사용
      - 구조체의 한계
        - 데이터와 동작이 분리되어 있음
        - 어떤 구조체가 어떤 함수랑 연관 있는지 찾기 복잡함

<br/>

// c언어에서의 구조체
~~~c
struct Human
{
	int age;
	float height;
}
~~~

<br/>

  - 데이터와 동작, 즉 변수와 함수를 하나로 묶을 수 있는 방법을 찾고자 함
    - c언어 같은 경우는 그것을 파일단위로 구별해서 저장함으로써 구현하기도 했음

<br/>

  - 절차적 프로그래밍은 매우 객관적
    - 기계어는 위에서 아래로 차례대로 실행됨
    - 어셈블리 명령어는 거의 모든 경우 기계어로 1:1 치환가능
    - c언어로 작성한 코드 한 줄은 보통 어셈블리 명령어 몇 개로 치환 가능
    - 함수 호출은 특정 메모리 위치로 jmp해서 순서대로 명령어를 실행하는 것
    - 그 명령어 실행 결과에 따라 레지스터 또는 메모리에 저장된 데이터가 변경
    - 어떤 프로그램이라도 최종적으로는 절차적으로 돈다!
    - 기준은 바로 작동하는 기계이기 때문에 절차적 프로그래밍은 매우 객관적이다.
    - 이 패러다임에 프로그래머의 주관이 개입할 여지가 적다

<br/>

  - 개체지향 프로그램은 사람이 기준
    - OOP는 기계처럼이 아니라 사람처럼 생각하자는 운동
    - 하지만 ‘사람처럼’ 이라는 말 자체가 매우 주관적
    - 사회와 기술이 발전함에 따라 사람들이 사고방식도 변함
  - OOP는 주관적
    - 역사 동안 다양한 학설 및 의견이 등장하고 사라짐
    - 개체에 대한 정의조차 다양했음
    - 오늘날에도 어떤 자료를 보고 배웠냐에 따라 OOP의 정의를 달리함
      - 어떤 시대에 나온 자료를 봤는가?
      - 어느 쪽 진영에서 주장한 내용을 배웠나?
      - 여러 진영의 상충되는 주장을 답습해서 모순된 주장을 하는 사람도 있음
  - 다수가 따르는 OOP 개념이 있음
    - 다행이 Jaca, C#, C++ 등의 주류 OOP 언어들이 교통정리를 끝냄
    - 많은 사람들이 이를 따르고 있음
  - 개체(object)
    - 개체란 서로 연관 있는 상태와 동작을 가지고 있다
      - 캡슐화란 개념의 일부
    - 사람들은 기본적으로 세상을 개체들의 모음으로 본다

###### [개체지향 프로그래밍이란?/필요성/개체란?](#개체지향-프로그래밍이란?/필요성/개체란?)
###### [Top](#top)

<br/>
<br/>

***

# OOP의 4대 특성
  - 보통 4가지 특성이 있다 함
  - 문헌에 따라 3대 특성 혹은 7대 개념이라고 하기도 함
  - 3대 특성
    - 캡슐화(encapsulation)
    - 상속(inheritance)
    - 다형성(polymorphism)
  - 4대 특성
    - 캡슐화(encapsulation)
    - 상속(inheritance)
    - 다형성(polymorphism)
    - (데이터) 추상화( (data) abstraction)
  - 7대 개념
    - 캡슐화(encapsulation)
    - 상속(inheritance)
    - 다형성(polymorphism)
    - (데이터) 추상화( (data) abstraction)
    - 연관(association)
    - 컴포지션(composition)
    - 집합(aggregation)

<br/>

  - 캡슐화
    - 데이터와 그 데이터에 작용하는 메서드를 하나로 묶음
      - = 클래스를 만드는것
    - 정보숨기기 : 개체 안에 있는 데이터를 외부로부터 보호
      - = 클래스 안에 멤버 변수를 private로 만드는것 -> 직접 접근하지 못함
  - 상속
    - 이미 존재하는 개체를 기반으로 확장된 개체를 만드는 방법
    - 확장된 개체
      - 기존의 개체에 속한 데이터와 동작을 모두 물려 받음
      - 여기에 다른 데이터나 동작을 추가할 수 있음
    - 실용적인 용도 : 코드 중복을 막음
      - 여러 개체에 공통되는 데이터와 동작을 부모 개체로 만듦
      - 여러 개체는 각각 그 부모 개체를 상속 받음
      - 그 후 자기에게만 필요한 데이터나 동작을 추가
    - = 코드 중복을 막고, 다형성을 만들어줌
  - 다형성
    - 많은 사람들이 OOP의 핵심이라 여기는 특징
    - 같은 지시를 내렸는데 다른 종류의 개체가 동작을 달리하는 것
      - 같은 지시 : 동일한 함수 시그니처 호출
      - 달리 동작 : 개체의 종류에 따라 실제로 실행되는 함수 구현 코드가 다름, 절차적 언어에서 이런 일을 하려면 if문을 사용해야 했음
      - 어떤 함수 구현이 실행될지는 실행 중에 결졍됨, 이를 늦은 바인딩(late binding)이라고 함, 일반적인 함수 호출은 이른 바인딩(early binding)이것은 컴파일 중에 결정됨
      - 다형성의 혜택을 받으려면 상속 관계가 필요
        - 부모 개체에서 함수 시그니처를 선언
        - 자식 개체에서 그 함수를 다르게 구현(오버라이딩)
        - 실용적인 용도 : 다른 종류의 개체를 편하게 저장 및 처리 가능
        - 예 : 부모의 형(type)을 저장하는 배열에 모든 자식 개체를 저장
          - for문 하나로 모든 개체를 순회하며 동일한 함수를 호출
          - 그러면 각 개체가 자신의 종류에 따라 다른 동작을 함
    - 위와 같은 것 말고 다른 두 형태의 다형성이 존재
      - 에드혹 다형성
        - 함수 오버로딩, 연산자 오버로딩
        - 즉, 함수명은 같은데 매개변수 목록이 다름
      - 매개변수 다형성
        - C#과 Java의 제네릭(Generic)
        - C++의 템플릿
      - 허나 둘다 일반적으로 다형성이라고 안 부름
        - 면접에서 다형성이란 무엇인가? 라는 질문은 이 둘을 묻는게 아님
        - OOP하고도 상관 없음
  - (데이터)추상화
    - (데이터)추상화
      - 개체 사용 시 그 안에 정확히 어떤 데이터가 있는지 알 필요 없음, 개체 안에 있는 데이터에 직접 접근 불가, 그 대신 개체의 함수를 통해 접근, 즉, 캡슐화는 데이터 추상화를 이루는 방법 중 하나
        - = private멤버 변수와 setter/getter를 사용하는것
        - = 어떤 구체적인 것에 직접 손대지 않겠다는 것
        - = 가령, get하는 함수를 시,분,초 3개인데, 실제 class안에는 초 단위 로만 데이터가 저장되어 있다던지 한다는것. class를 사용하는 사람들은 그 안에 어떤 데이터가 있는지 알수 없는것, 즉 내부에서 도는 데이터와, 밖에서 보는 데이터가 일치 하지 않을 수도 있다
      - 단점
        - 동작 없이 데이터만 있는 클래스는 쓸데없는 코드만 늘어남
        - 어떻게 추상화를 해야 하는지 뚜렷한 객관적 기준이 없음
    - 추상화
      - 다형성을 통한 추상화
        - = 여러 클래스에서 공통분모를 뽑아 부모 클래스를 만드는 과정
        - = 자식마다 달리 작동하는 구현을 부모의 메서드 시그니처로 일반화하는 과정
      - 추상 클래스(abstract class)나 인터페이스(interface)를 사용하는 추상화
  - 연관
    - 어떤 개체가 제공하는 기능을 다른 개체가 이용하는 관계
    - 종종 상속과 비교해서 설명
      - 상속은 자식 개체가 부모 개체의 모든 것을 내포하는 관계
      - 연관은 한 개체가 다른 개체를 참조하는 관계
      - 실세계에서 개체들이 상호작용하는 모습은 보통 연관과 비슷함
    - 세부적으로 다시 집합과 컴포지션으로 나누기도 함
      - 특히 UML이란 다이어그램을 그릴때
      - 이 셋을 구분하지 않고 다 합쳐서 컴포지션이라 하기도 함

<br/>

![image](https://github.com/BuMinKyoo/MY_ALL_INDEX/assets/39178978/ff40fafc-0286-437b-a556-e32fd678b919)

<br/>

  - 컴포지션
    - 합성, 조합, 조립, 구성 등 다양한 번역어가 존재
    - 여러 개의 부품(그 자체로 개체)을 조립해서 새 개체를 만드는 방법
    - 집합과의 차이
      - 컴포지션에서는 부품 그 자체로는 존재 의의가 없음
      - 컴포지션에서는 조립품이 소멸할 때 부품도 같이 소멸(즉, 부품은 조립품의 수명을 따름)
  - 집합
    - 역시 여러 개체를 모아 다른 개체를 만들지만 별도로도 존재 가능
      - 예 : A 대학에 등록한 학생들
    - 컴포지션과의 차이
      - 각 개체들이 따로 따로 살아남을 수 있음
      - 예 : A대학이 문을 닫아도 학생들은 여전히 다른 대학에 등록 가능

###### [OOP의 4대 특성](#oop의-4대-특성)
###### [Top](#top)

<br/>
<br/>

***

# 클래스(Class)

###### [클래스(Class)](#클래스class)
###### [Top](#top)

<br/>
<br/>

***

# Class베스트 프랙티스

###### [Class베스트 프랙티스](#class베스트-프랙티스)
###### [Top](#top)

<br/>
<br/>

***

# 개체 모델링

###### [개체 모델링](#개체-모델링)
###### [Top](#top)

<br/>
<br/>

***

# static, 싱글턴, 내포 클래스

###### [static, 싱글턴, 내포 클래스](#static-싱글턴-내포-클래스)
###### [Top](#top)

<br/>
<br/>

***

# 상속(inheritance)

###### [상속(inheritance)](#상속inheritance)
###### [Top](#top)

<br/>
<br/>

***

# 상속을 이용한 개체 모델링

###### [상속을 이용한 개체 모델링](#상속을-이용한-개체-모델링)
###### [Top](#top)

<br/>
<br/>

***

# 상속 vs 컴포지션

###### [상속 vs 컴포지션](#상속-vs-컴포지션)
###### [Top](#top)

<br/>
<br/>

***

# 다형성

###### [다형성](#다형성)
###### [Top](#top)

<br/>
<br/>

***

# 추상 메서드/클래스

###### [추상 메서드/클래스](#추상-메서드/클래스)
###### [Top](#top)

<br/>
<br/>

***

# 인터페이스(interface)

###### [인터페이스(interface)](#인터페이스interface)
###### [Top](#top)

<br/>
<br/>

***

# 인터페이스 vs 구현, 의존성 주입

###### [인터페이스 vs 구현, 의존성 주입](#인터페이스-vs-구현-의존성-주입)
###### [Top](#top)

<br/>
<br/>

***

# 디자인 패턴

###### [디자인 패턴](#디자인-패턴)
###### [Top](#top)

<br/>
<br/>

***

# 예외

###### [예외](#예외)
###### [Top](#top)

<br/>
<br/>

***

# SOLID설계 정신

###### [SOLID설계 정신](#solid설계-정신)
###### [Top](#top)

<br/>
<br/>
